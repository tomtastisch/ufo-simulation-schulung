dump_path: /Users/tomwerner/PycharmProjects/ufo-simulation-schulung/dumps/28714926292_complete_dump.yaml
root: /Users/tomwerner/PycharmProjects/ufo-simulation-schulung
hash: 2e8825b0d879eeca610d2a1891c58ded1c6900b4ecb65dc3291fff48584abf9d
dirs:
  - src
  - src/core
  - src/core/simulation
  - src/core/simulation/command
  - src/core/simulation/exceptions
  - src/core/simulation/infrastructure
  - src/core/simulation/infrastructure/config
  - src/core/simulation/observer
  - src/core/simulation/physics
  - src/core/simulation/state
  - src/core/simulation/synchronization
  - src/core/simulation/synchronization/decorators
  - src/core/simulation/synchronization/primitives
  - src/core/simulation/utils
  - src/task
  - src/task/angle
  - src/task/autopilot
  - tests
  - tests/core/simulation/command
  - tests/core/simulation/exceptions
  - tests/core/simulation/infrastructure
  - tests/core/simulation/observer
  - tests/core/simulation/physics
  - tests/core/simulation/state
  - tests/core/simulation/synchronization
  - tests/core/simulation/utils
  - tools
  - tools/setup
  - tools/setup/domain
  - tools/setup/steps
  - tools/setup/steps/base
  - tools/setup/ui
  - tools/setup/ui/output
  - tools/setup/ui/progress
  - tools/setup/ui/resources
  - tools/setup/utils
files:
  - rel_path: dum_creator.py
    hash: f6e6ded888e43451e7e2d7b95e2e397b4bca7c24948192eb260b5b649233bafe
    content: |
      #!/usr/bin/env python3
      from __future__ import annotations
      
      import hashlib
      import secrets
      import yaml
      from datetime import datetime, timezone
      
      from pathlib import Path
      from typing import Any
      
      EXCLUDES = {".git", ".venv", "__pycache__", "dumps", "dump"}
      
      
      class LiteralStr(str):
          """Marker für YAML-Block-Strings (|)."""
          pass
      
      
      def _literal_str_representer(dumper: yaml.Dumper, data: LiteralStr) -> yaml.ScalarNode:
          # Immer als Block-Scalar schreiben: |
          return dumper.represent_scalar("tag:yaml.org,2002:str", data, style="|")
      
      
      class LiteralDumper(yaml.SafeDumper):
          """SafeDumper mit Unterstützung für LiteralStr."""
          pass
      
      
      # Registrieren des Repräsentanten für unseren Typ beim LiteralDumper
      LiteralDumper.add_representer(LiteralStr, _literal_str_representer)
      
      
      def hash_bytes(data: bytes) -> str:
          return hashlib.sha256(data).hexdigest()
      
      
      def should_exclude(path: Path) -> bool:
          return any(part in EXCLUDES for part in path.parts)
      
      
      def _next_dump_code() -> int:
          """Erzeugt eine numerische, zeitbasierte Prüfziffer.
      
          - Basis: Millisekunden seit einer festen Epoche (2025-01-01 UTC)
          - Monoton wachsend mit der Zeit (unter Annahme monotone Uhr)
          - Unabhängig von Dateien oder Index-Dateien
          - Die Anzahl der Stellen ist mindestens 6, nach oben nicht künstlich begrenzt
          """
          epoch = datetime(2025, 1, 1, tzinfo=timezone.utc)
          now = datetime.now(tz=timezone.utc)
          delta_ms = int((now - epoch).total_seconds() * 1000)
      
          # Untergrenze 6-stellig sicherstellen
          if delta_ms < 100_000:
              return 100_000 + delta_ms
          return delta_ms
      
      
      def collect_files(root: Path) -> dict[str, dict[str, Any]]:
          files: dict[str, dict[str, Any]] = {}
      
          for path in sorted(root.rglob("*")):
              if should_exclude(path):
                  continue
              if path.suffix not in {".py", ".toml"}:
                  continue
      
              content = path.read_text(encoding="utf-8")
              digest = hash_bytes(content.encode("utf-8"))
              rel_path = path.relative_to(root).as_posix()
      
              files[rel_path] = {
                  "rel_path": rel_path,
                  "hash": digest,
                  "content": LiteralStr(content),
              }
      
          return files
      
      
      def main() -> None:
          cwd = Path.cwd()
      
          print("Pfad eingeben, der gedumpt werden soll.")
          print(f"Leer lassen = aktuelles Verzeichnis: {cwd}")
          raw = input("> ").strip()
      
          print("Name für die YAML-Datei eingeben (ohne .yaml, leer = complete_dump):")
          name_raw = input("> ").strip()
      
          if not raw:
              target = cwd
          else:
              if raw.startswith("cd "):
                  raw = raw[3:].strip()
              target = Path(raw).expanduser()
      
          target = target.resolve()
      
          if not target.exists():
              print(f"Fehler: Pfad existiert nicht: {target}")
              raise SystemExit(1)
      
          if not target.is_dir():
              print(f"Fehler: Pfad ist kein Ordner: {target}")
              raise SystemExit(1)
      
          print(f"Sammle Python-Dateien unter: {target}\n")
      
          files = collect_files(target)
      
          # Verzeichnisliste aus rel_paths ableiten, "." ausblenden
          dir_set: set[str] = set()
          for rel_path in files.keys():
              parent = Path(rel_path).parent
              if str(parent) != ".":
                  dir_set.add(parent.as_posix())
      
          dirs = sorted(dir_set)
      
          # Stabiler Snapshot-Hash über alle File-Hashes in deterministischer Reihenfolge
          snapshot_hash = hash_bytes(
              "\n".join(files[k]["hash"] for k in sorted(files.keys())).encode("utf-8")
          )
      
          # Dumps immer in einem Unterordner "dumps" ablegen
          dumps_dir = target / "dumps"
          dumps_dir.mkdir(exist_ok=True)
      
          # Basisnamen bestimmen (ohne laufende Nummer / Präfix)
          if not name_raw:
              base = secrets.token_urlsafe(5)
          else:
              # Nutzer darf auch schon .yaml/.yml angeben – wir normalisieren auf .yaml
              # und entfernen evtl. vorhandene Endung zuerst.
              base = name_raw
              if base.lower().endswith((".yaml", ".yml")):
                  base = Path(base).stem
      
          # Prüfziffer rein aus der Zeit generieren (unabhängig von Dateien/Index)
          code = _next_dump_code()
          yml = f"{code}_{base if base else "dump"}.yaml"
          out_path = dumps_dir / yml
      
          dump: dict[str, Any] = {
              "dump_path": str(out_path),
              "root": str(target),
              "hash": snapshot_hash,
              "dirs": dirs,
              "files": [files[k] for k in sorted(files.keys())],
          }
      
          with out_path.open("w", encoding="utf-8") as fh:
              yaml.dump(
                  dump,
                  fh,
                  Dumper=LiteralDumper,
                  sort_keys=False,
                  allow_unicode=True,
                  width=88,
              )
      
          print("Fertig. Ausgabe gespeichert in:")
          print(out_path)
      
      
      if __name__ == "__main__":
          main()
  - rel_path: pyproject.toml
    hash: 68ef369e4c33f8061bf839849d2033000e8992e17f315217ef65d33bc858363e
    content: |
      [project]
      name = "ufo-simulation-schulung"
      version = "1.0.0"
      description = "UFO/Drohnen-Simulation mit Autopilot-Schulungsvorlage für Anfänger"
      readme = "README.md"
      license = { text = "MIT" }
      authors = [{ name = "tomtastisch", email = "tomtastisch@icloud.com" }]
      
      keywords = ["simulation", "education", "ufo", "autopilot", "python"]
      classifiers = [
          "Development Status :: 4 - Beta",
          "Intended Audience :: Education",
          "License :: OSI Approved :: MIT License",
          "Programming Language :: Python :: 3",
          "Programming Language :: Python :: 3 :: Only",
      ]
      
      requires-python = ">=3.11"
      dependencies = [
          "PyQt5>=5.15.11",
          "PyQt5-sip>=12.17.1",
          "numpy>=2.3.5",
          # "rich>=13.0.0",  # ENTFERNT, da Rich nicht mehr verwendet werden soll
          "pyyaml>=6.0.3"
      ]
      
      [project.optional-dependencies]
      dev = [
          "pytest>=8.0.0",
          "pytest-timeout>=2.3.1",
          "threadpoolctl>=3.5.0",
          "py-spy>=0.3.14",
          "black>=24.4.0",
          "flake8>=7.0.0",
          "import-linter>=2.0.0",
      ]
      
      [project.urls]
      Repository = "https://github.com/tomtastisch/ufo-simulation-schulung"
      Issues = "https://github.com/tomtastisch/ufo-simulation-schulung/issues"
      
      [tool.setuptools]
      package-dir = {"" = "src"}
      
      [tool.setuptools.packages.find]
      where = ["src"]
      
      [tool.setuptools.package-data]
      core = [
          "simulation/ressources/*.png",
      ]
      
      [tool.setup]
      # Explizite Reihenfolge aller Steps
      steps = ["create_env", "dependencies", "import_linter", "tests"]
      
      # Optional: bestimmte Steps deaktivieren
      exclude = ["import_linter"]  # Beispiel: Import-Linter vorübergehend abschalten
      
      # Optional: globale Setup-Flags
      auto_install = true
      
      # Optionaler generischer Erweiterungspunkt:
      [tool.setup.options.tests]
      marker = "not slow"
      max_workers = 4
      
      # Spezifische Linter-Konfiguration:
      [tool.setup.linter]
      # "all" | "forbidden" | "layers"
      contracts = "layers"
      
      [tool.pytest.ini_options]
      # Pytest-Konfiguration für die UFO-Simulation
      testpaths = ["tests"]
      python_files = ["test_*.py"]
      python_classes = ["Test*"]
      python_functions = ["test_*"]
      
      # Timeout-Konfiguration für Deadlock-Erkennung
      timeout = 300
      timeout_method = "thread"
      
      # Test-Output-Einstellungen
      addopts = [
          "-v",
          "--strict-markers",
          "--tb=short",
      ]
      
      # Marker für unterschiedliche Test-Typen
      markers = [
          "slow: Tests die länger als 1 Sekunde dauern",
          "integration: Integration-Tests",
          "threading: Tests mit Threading/Locks",
      ]
      
      # ---------------------------------------------------------------------------
      # LAYERED ARCHITECTURE
      # ---------------------------------------------------------------------------
      
      [[tool.importlinter.contracts]]
      id = "layers-core-simulation"
      name = "core.simulation layered architecture"
      type = "layers"
      layers = [
          # High-Level → Low-Level (höchste Schicht zuerst)
          "(core.simulation.view)", # Optional: Implementierung geplant in Phase 7 (T14)
          "(core.simulation.controller)", # Optional: Implementierung geplant in Phase 6 (T13)
          "core.simulation.command",
          "core.simulation.observer",
          "core.simulation.physics",
          "core.simulation.state",
          "core.simulation.utils",
          "core.simulation.infrastructure.config",
      ]
      
      # ---------------------------------------------------------------------------
      # LOW-LEVEL: config + utils ohne Simulationstypen (T2, T5, T6)
      # ---------------------------------------------------------------------------
      
      [[tool.importlinter.contracts]]
      id = "lowlevel-ohne-simulationstypen"
      name = "config und utils sind unabhängig von Simulationstypen"
      type = "forbidden"
      source_modules = [
          "core.simulation.infrastructure.config",
          "core.simulation.utils.threads",
          "core.simulation.utils.maths",
      ]
      forbidden_modules = [
          "core.simulation.state",
          "core.simulation.physics",
          "core.simulation.command",
          "core.simulation.observer",
          "core.simulation.controller",
          "core.simulation.view",
      ]
      
      # ---------------------------------------------------------------------------
      # PHYSICSENGINE: kennt keine High-Level-Komponenten (T7)
      # ---------------------------------------------------------------------------
      
      [[tool.importlinter.contracts]]
      id = "physics-ohne-highlevel"
      name = "PhysicsEngine kennt keine High-Level-Komponenten"
      type = "forbidden"
      source_modules = [
          "core.simulation.physics.engine",
      ]
      forbidden_modules = [
          "core.simulation.state.manager",
          "core.simulation.observer",
          "core.simulation.command",
          "core.simulation.controller",
          "core.simulation.view",
      ]
      
      # ---------------------------------------------------------------------------
      # STATEMANAGER: ohne High-Level-Abhängigkeiten (T8)
      # ---------------------------------------------------------------------------
      
      [[tool.importlinter.contracts]]
      id = "statemanager-ohne-highlevel"
      name = "StateManager ohne High-Level-Abhängigkeiten"
      type = "forbidden"
      source_modules = [
          "core.simulation.state.manager",
      ]
      forbidden_modules = [
          "core.simulation.infrastructure.config",
          "core.simulation.physics",
          "core.simulation.observer",
          "core.simulation.command",
          "core.simulation.controller",
          "core.simulation.view",
      ]
      
      # ---------------------------------------------------------------------------
      # OBSERVER: kein Engine/Executor/View (T9)
      # ---------------------------------------------------------------------------
      
      [[tool.importlinter.contracts]]
      id = "observer-ohne-engine-executor-view"
      name = "Observer ohne Engine/Executor/View-Abhängigkeit"
      type = "forbidden"
      source_modules = [
          "core.simulation.observer.observer",
      ]
      forbidden_modules = [
          "core.simulation.state.manager",
          "core.simulation.physics",
          "core.simulation.command",
          "core.simulation.controller",
          "core.simulation.view",
      ]
      
      # ---------------------------------------------------------------------------
      # HINWEIS: Zukünftige Contracts
      # ---------------------------------------------------------------------------
      # Weitere geplante Contracts (T11, T12, T14) sind in .importlinter-future.toml
      # dokumentiert und werden bei Bedarf hierher verschoben.
  - rel_path: setup_new.py
    hash: c3acef0f13ccdea8bc81b6016be818278730c0ebd0214f6e689ac9a4e3af7e98
    content: |-
      #!/usr/bin/env python3
      """Setuptools-Hilfsskript für Editier-Installationen."""
      
      import sys
      from tools import setup
      
      
      def _run_bootstrap() -> int:
          """Führt das neue Setup-Bootstrap-System aus."""
          from tools.bootstrap import execute
          return execute()
      
      
      if __name__ == "__main__":
          if len(sys.argv) == 1:
              raise SystemExit(_run_bootstrap())
          setup()
  - rel_path: src/__init__.py
    hash: 64aff54ca4b8f2c71adb60e4c194bab35aba94daee7996260c5ab4ba4a0e0386
    content: |+
      """Top-level package marker for tests that import using `src.` prefix.
      
      This file exists to make `import src` work when tests use the `src.core...`
      import style. It intentionally contains minimal code.
      """
      __all__ = []

  - rel_path: src/core/__init__.py
    hash: 63decf98f8a1a86114e76e047399e5fe4c19829b9dfddefe02d6644d5fe66098
    content: |-
      """
      Kernmodule der UFO-Simulation-Schulung.
      
      Bündelt die zentrale Simulation (core.simulation) und stellt sie als Package bereit.
      """
      
      from . import simulation
      
      __all__ = ["simulation"]
  - rel_path: src/core/simulation/__init__.py
    hash: a3458e4b79ad864f76df98484450892d5a2693ec7cb08aeb2d4536df38da3b10
    content: |-
      """
      Kern-Simulationspaket für die UFO-Simulation-Schulung.
      
      Stellt die zentralen Klassen und Konfigurationen der Simulation bereit.
      """
      
      from core.simulation.infrastructure.config import DEFAULT_CONFIG, SimulationConfig
      from .autopilot_base import AutopilotBase
      from .observer import ManeuverAnalysis, Phase
      from .state import UfoState
      from .ufosim import UfoSim
      
      __version__ = "1.0.0"
      __author__ = "tomtastisch"
      __license__ = "MIT"
      
      __all__ = [
          "AutopilotBase",
          "UfoSim",
          "UfoState",
          "Phase",
          "ManeuverAnalysis",
          "SimulationConfig",
          "DEFAULT_CONFIG",
      ]
  - rel_path: src/core/simulation/autopilot_base.py
    hash: 7276213a6ef763e3fd302eacb8a7fd5f3acda587fde15720147d039f0c665fa2
    content: |-
      """
      ABSTRAKTE BASE-KLASSE FÜR AUTOPILOTEN (Nur für Lehrer/Infrastruktur!)
      
      Diese Klasse:
      - Verwaltet die Demo-Implementierung (versteckt)
      - Orchestriert den Flugablauf
      - Handhabt USE_DEMO Logik
      - Definiert abstrakte Methoden für Schüler
      
      Schüler erben von dieser Klasse und implementieren nur:
      - takeoff()
      - cruise()
      - landing()
      
      WICHTIG: Schüler ändern NICHTS in dieser Datei!
      """
      
      from __future__ import annotations
      
      import math
      import time
      
      from abc import ABC, abstractmethod
      from typing import TYPE_CHECKING
      
      if TYPE_CHECKING:
          from .ufosim import UfoSim
      
      class AutopilotBase(ABC):
          """
          Abstrakte Basis-Klasse für Autopiloten.
      
          Diese Klasse:
          - Verwaltet die Demo-Implementierung
          - Orchestriert den Flugablauf
          - Kümmert sich um USE_DEMO Logik
      
          Schüler erben von dieser Klasse und implementieren nur:
          - takeoff()
          - cruise()
          - landing()
          """
      
          # Flag für Demo-Modus (wird von der Unterklasse gesetzt)
          USE_DEMO: bool = True
      
          def __call__(self, sim: "UfoSim") -> None:
              """
              Einstiegspunkt - wird von UfoSim aufgerufen.
      
              Diese Methode ist FINAL und nicht zu verändern!
              """
              destinations = sim.get_destinations()
              if not destinations:
                  print("[Autopilot] Keine Ziele definiert")
                  return
      
              target_x, target_y = destinations[0]
              target_alt = 10.0
      
              print(f"[Autopilot] Mission: Fliege zu ({target_x}, {target_y})")
              print(f"[Autopilot] Mode: {'DEMO' if self.USE_DEMO else 'DEINE IMPLEMENTIERUNG'}\n")
      
              if self.USE_DEMO:
                  self._demo_flight(sim, target_x, target_y, target_alt)
              else:
                  # Schüler-Implementierung
                  self.takeoff(sim, target_alt)
                  self.cruise(sim, target_x, target_y)
                  self.landing(sim)
      
              print("[Autopilot] Mission beendet\n")
      
          # ========================================================================
          # DEMO-IMPLEMENTIERUNG (verborgen vor Schülern)
          # ========================================================================
      
          @staticmethod
          def _demo_flight(
              sim: "UfoSim", target_x: float, target_y: float, target_alt: float
          ) -> None:
              """
              Interne Demo - Schüler können das studieren aber nicht ändern.
              """
              print("[DEMO] ▶ Phase 1: Takeoff")
              sim.state.delta_v = 10.0
              sim.state.i = 45
              start = time.time()
              while sim.state.z < target_alt and time.time() - start < 30.0:
                  time.sleep(0.1)
              print(f"[DEMO]   → Erreichte Höhe: {sim.state.z:.1f}m\n")
      
              print("[DEMO] ▶ Phase 2: Cruise")
              sim.state.i = 0
              dx = target_x - sim.state.x
              dy = target_y - sim.state.y
              direction = math.degrees(math.atan2(dx, dy))
              if direction < 0:
                  direction += 360
              sim.state.d = direction
              sim.state.delta_v = 5.0
      
              start = time.time()
              while time.time() - start < 60.0:
                  dist = math.sqrt(
                      (sim.state.x - target_x) ** 2 + (sim.state.y - target_y) ** 2
                  )
                  if dist < 5.0:
                      break
                  time.sleep(0.1)
              print(f"[DEMO]   → Zielgebiet erreicht\n")
      
              print("[DEMO] ▶ Phase 3: Landing")
              sim.state.delta_v = -sim.state.v
              sim.state.i = -20
              start = time.time()
              while sim.state.z > 0.1 and time.time() - start < 30.0:
                  time.sleep(0.1)
              print(f"[DEMO]   → Gelandet\n")
      
          # ========================================================================
          # ABSTRAKTE METHODEN - Schüler implementiert diese!
          # ========================================================================
      
          @abstractmethod
          def takeoff(self, sim: "UfoSim", target_alt: float) -> None:
              """Abstrakte Methode - Schüler implementiert."""
              pass
      
          @abstractmethod
          def cruise(self, sim: "UfoSim", target_x: float, target_y: float) -> None:
              """Abstrakte Methode - Schüler implementiert."""
              pass
      
          @abstractmethod
          def landing(self, sim: "UfoSim") -> None:
              """Abstrakte Methode - Schüler implementiert."""
              pass
  - rel_path: src/core/simulation/command/__init__.py
    hash: 74dc0908cefa3e4683867b8e2a81ee76a4df58eec4b7cfa7a73b25d018ebcf10
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """
      Command-System für deklarative UFO-Steuerung.
      
      Ermöglicht eine deklarative, ereignisbasierte Steuerung der UFO-Simulation
      ohne aktive Warteschleifen oder Polling. Statt imperativen while-Schleifen
      definieren Autopiloten eine Sequenz von Commands, die von der Simulation
      automatisch ausgeführt werden.
      
      Komponenten:
          - CommandType: Enum aller verfügbaren Command-Typen
          - Command: Dataclass für einzelne Steuerkommandos
          - CommandQueue (geplant): Verwaltet Command-Sequenzen
          - CommandExecutor (geplant): Führt Commands gegen StateManager aus
      
      Architektur:
          - command.types → keine Simulationselemente (nur typing)
          - command.types verwendet TYPE_CHECKING für UfoState-Referenzen
          - Kein direkter Import von state zur Laufzeit (nur String-Annotationen)
      
      Design-Prinzipien:
          - Deklarativ statt imperativ: Commands beschreiben "was", nicht "wie"
          - Entkopplung: Keine direkten Abhängigkeiten zu StateManager oder PhysicsEngine
          - Typsicherheit: Vollständige Type-Hints mit TYPE_CHECKING für Zyklusvermeidung
          - Thread-Safety: Wird durch CommandQueue und CommandExecutor gewährleistet
      """
      
      from .types import Command, CommandType
      
      __all__ = [
          "Command",
          "CommandType",
      ]
  - rel_path: src/core/simulation/command/types.py
    hash: 8bace958aa74158b771699a4722607ed7b1e36796f993ab65f59e8ca559207fc
    content: "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"Command-Typen für deklarative\
    \ Steuerung.\"\"\"\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\n\
    from enum import Enum, auto\nfrom typing import TYPE_CHECKING, Any, Callable, Optional\n\
    \nif TYPE_CHECKING:\n    from ..state.state import UfoState\n\n\nclass CommandType(Enum):\n\
    \    \"\"\"\n    Typ der Steuerkommandos.\n    \n    Definiert alle verfügbaren Command-Typen\
    \ für die deklarative\n    Autopilot-Steuerung der Simulation.\n    \"\"\"\n    \n   \
    \ SET_STATE = auto()  # Setze State-Attribut direkt\n    WAIT_CONDITION = auto()  # Warte\
    \ auf Bedingung\n    EXECUTE_FUNC = auto()  # Führe Funktion aus\n    LOG_MESSAGE = auto()\
    \  # Gib Nachricht aus\n\n\n@dataclass\nclass Command:\n    \"\"\"\n    Einzelnes Steuerkommando.\n\
    \n    Statt Warteschleifen definierst du eine Sequenz von Commands.\n    Die Simulation\
    \ führt diese automatisch aus.\n    \n    Attributes:\n        type: Der Typ des Commands\
    \ (SET_STATE, WAIT_CONDITION, etc.)\n        target: State-Attribut (für SET_STATE)\n\
    \        value: Wert (für SET_STATE)\n        condition: Bedingung (für WAIT_CONDITION)\
    \ - nimmt UfoState als Parameter\n        func: Funktion (für EXECUTE_FUNC)\n        message:\
    \ Nachricht (für LOG_MESSAGE)\n        timeout: Timeout für WAIT_CONDITION in Sekunden\n\
    \        \n    Note:\n        UfoState wird nur über TYPE_CHECKING importiert, um Importzyklen\n\
    \        zwischen command/ und state/ zu vermeiden. Die condition Callable\n        verwendet\
    \ String-Annotation für den UfoState-Parameter.\n    \"\"\"\n    \n    type: CommandType\n\
    \    target: Optional[str] = None  # State-Attribut (für SET_STATE)\n    value: Optional[Any]\
    \ = None  # Wert (für SET_STATE)\n    condition: Optional[Callable[[\"UfoState\"], bool]]\
    \ = None  # Bedingung (für WAIT_CONDITION)\n    func: Optional[Callable[[], Any]] = None\
    \  # Funktion (für EXECUTE_FUNC)\n    message: Optional[str] = None  # Nachricht (für\
    \ LOG_MESSAGE)\n    timeout: Optional[float] = None  # Timeout für WAIT_CONDITION\n"
  - rel_path: src/core/simulation/exceptions/__init__.py
    hash: e811b26ce7dd18fac50b6a51615fe18775500225f85f63f3d055e4717d8a32c0
    content: |+
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """
      Exception-Hierarchie für die UFO-Simulation.
      
      Definiert projektspezifische Exceptions für Fehlerbehandlung in
      Simulation, Konfiguration und weiteren fachlichen Bereichen.
      
      Komponenten:
          - SimulationError: Basis-Exception für Simulationsfehler
          - ConfigError: Fehler bei Konfigurationsparametern
      """
      
      from __future__ import annotations
      
      from .simulation import ConfigError, SimulationError
      
      __all__ = [
          "SimulationError",
          "ConfigError",
      ]



  - rel_path: src/core/simulation/exceptions/simulation.py
    hash: 2ac1fd3189a9c89cd286ef9ad88dcf39bc728d3353857075b4eb6768a0f2078d
    content: |+
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """Simulationsspezifische Exception-Klassen."""
      
      
      class SimulationError(Exception):
          """Basis-Exception für alle simulationsspezifischen Fehler."""
      
          pass
      
      
      class ConfigError(SimulationError):
          """Exception für ungültige Konfigurationswerte oder Initialisierungsfehler."""
      
          pass

  - rel_path: src/core/simulation/infrastructure/__init__.py
    hash: fea358e75d18f51d49e9fcf1ed5652dda2cd2b0b5ec406757186900d7105f983
    content: |
      """
      Infrastruktur-Komponenten für die UFO-Simulation.
      
      Stellt grundlegende Dienste bereit (Konfiguration, Logging) ohne
      Simulationslogik. Framework-unabhängig und thread-sicher.
      """
      from core.simulation.infrastructure.config.logging import configure_logging, get_logger
      from core.simulation.infrastructure.config.simulation import SimulationConfig, DEFAULT_CONFIG
      
      __all__ = [
          "SimulationConfig",
          "DEFAULT_CONFIG",
          "configure_logging",
          "get_logger",
      ]
  - rel_path: src/core/simulation/infrastructure/config/__init__.py
    hash: 3199c79f4bed21f6b3e67834b3b7375a064497b449a4c8d32fed79cca6d215f4
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """
      Komponenten:
          - SimulationConfig: Zentrale Konfigurations-Dataclass (immutable)
          - DEFAULT_CONFIG: Standard-Konfigurationsinstanz
          - configure_logging: Logging-System initialisieren (thread-sicher)
          - get_logger: Logger-Factory (thread-sicher)
      
      Architektur-Hinweis:
          Alle Konfigurationsklassen (auch zukünftige) sollten in ./config
          definiert werden, um eine einheitliche Konfigurationsverwaltung
          sicherzustellen.
      """
      from __future__ import annotations
      
      import core.simulation.infrastructure.config.logging
      import core.simulation.infrastructure.config.simulation
      from core.simulation.infrastructure.config.logging import configure_logging, get_logger
      from core.simulation.infrastructure.config.simulation import DEFAULT_CONFIG, SimulationConfig
      
      # Interne API
      __all__ = [
          "SimulationConfig",
          "DEFAULT_CONFIG",
          "configure_logging",
          "get_logger",
      ]
  - rel_path: src/core/simulation/infrastructure/config/logging.py
    hash: d29290d002ac07cd5823e0c98ac8678c30c58b624401101effb5c86e61e7aeb5
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """
      Thread-sichere Logging-Konfiguration und Logger-Factory.
      
      Stellt zentrale Funktionen für Logging-Setup und Logger-Erzeugung bereit.
      Alle Funktionen sind thread-sicher durch @synchronized_module.
      
      Komponenten:
          - configure_logging: Initialisiert das Logging-System (idempotent)
          - get_logger: Factory für konfigurierte Logger
      
      Hinweis zu zukünftigen Erweiterungen:
          Falls eine LoggingConfig-Klasse benötigt wird (z.B. für konfigurierbare
          Log-Levels, Handler, Formatter), sollte diese in simulation.py definiert werden,
          nicht hier. Dies gewährleistet Konsistenz mit anderen Konfigurationen.
      """
      
      import logging
      import threading
      from typing import Optional
      
      from core.simulation.synchronization import synchronized_module
      
      # Flag und Lock für thread-sichere Konfiguration
      _logging_configured = False
      _config_lock = threading.RLock()
      
      
      @synchronized_module(_config_lock)
      def configure_logging(
          level: int = logging.INFO,
          format_string: Optional[str] = None,
          datefmt: Optional[str] = None,
      ) -> None:
          """
          Initialisiert das Logging-System (idempotent, thread-sicher).
      
          Sollte einmalig beim Start aufgerufen werden. Mehrfache Aufrufe haben
          keine zusätzlichen Effekte.
          """
          global _logging_configured
      
          # Thread-sichere Prüfung und Konfiguration (Lock wird durch Decorator verwaltet)
          if _logging_configured:
              return
      
          if format_string is None:
              format_string = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
      
          if datefmt is None:
              datefmt = "%Y-%m-%d %H:%M:%S"
      
          logging.basicConfig(level=level, format=format_string, datefmt=datefmt)
      
          _logging_configured = True
      
      
      @synchronized_module(_config_lock)
      def get_logger(name: str) -> logging.Logger:
          """
          Gibt einen konfigurierten Logger zurück (thread-sicher).
      
          Stellt sicher, dass das Logging-System initialisiert ist, bevor
          der Logger zurückgegeben wird.
          """
          # Stellt sicher, dass Logging konfiguriert ist (thread-sicher durch Decorator)
          if not _logging_configured:
              configure_logging()
      
          return logging.getLogger(name)
  - rel_path: src/core/simulation/infrastructure/config/simulation.py
    hash: 26e1947fc9f0ada11ce11545f4e899e71968ac39b3f40c26ce2bb95398ca360d
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """
      Zentrale Konfigurationsklassen für die UFO-Simulation.
      
      Dieses Modul ist die zentrale Ablage für ALLE Konfigurationsklassen der Simulation.
      Alle Konfigurationen folgen einem einheitlichen Muster:
          - Immutable Dataclasses (frozen=True, slots=True)
          - Basis-Parameter als Instanzvariablen mit Defaults
          - Abgeleitete Werte als Properties
          - DEFAULT_XXX Konstanten für Standard-Konfigurationen
      
      Aktuell enthaltene Konfigurationen:
          - SimulationConfig: Physikalische und visuelle Simulationsparameter
      
      Zukünftige Erweiterungen:
          Weitere Konfigurationsklassen (z.B. NetworkConfig, AutopilotConfig,
          LoggingConfig) sollten hier abgelegt werden, um eine einheitliche
          Konfigurationsverwaltung zu gewährleisten.
      
      Wichtig - Konsistenz-Regel:
          Neue Module sollten KEINE eigenen Config-Dataclasses intern definieren,
          sondern sie hier zentralisieren. Dies vermeidet Inkonsistenzen in der
          Handhabung von Konfigurationen und erleichtert die Wartung.
      
          Beispiel:
              ❌ FALSCH: Config in physics/simulation.py definieren
              ✅ RICHTIG: Config hier definieren und in physics/ importieren
      
      Copyright (C) 2013-2025 R. Gold, tomtastisch (i-ki 1)
      Version: 5.2.0-tw-refactored
      """
      
      from __future__ import annotations
      
      from dataclasses import dataclass
      
      
      @dataclass(frozen=True, slots=True)
      class SimulationConfig:
          """
          Immutable Konfiguration für physikalische und visuelle Simulationsparameter.
      
          Diese Klasse kapselt alle konfigurierbaren Parameter der UFO-Simulation.
          Basis-Parameter sind als Instanzvariablen definiert, abgeleitete Werte
          werden als Properties dynamisch berechnet.
      
          Verwendung:
              # Standard-Konfiguration nutzen
              config = DEFAULT_CONFIG
      
              # Custom-Konfiguration erstellen
              config = SimulationConfig(vmax_kmh=20.0, dt=0.05)
      
              # Werte ablesen
              max_speed_ms = config.vmax_ms  # Property, automatisch berechnet
          """
      
          # === Basis-Physik-Parameter ===
          dt: float = 0.1  # Zeitschritt in Sekunden
          vmax_kmh: float = 15.0  # Maximale Geschwindigkeit in km/h
          acceleration_kmh_per_step: float = 1.0  # Beschleunigung pro Schritt in km/h
      
          # UAV-Geometrie
          uav_radius_m: float = 0.5  # Radius des UAV in Metern
          uav_height_m: float = 0.3  # Höhe des UAV in Metern
      
          # Maximale Beschleunigungen
          max_lateral_accel_ms2: float = 5.0  # Maximale Querbeschleunigung in m/s²
          max_vertical_accel_ms2: float = 3.0  # Maximale vertikale Beschleunigung in m/s²
      
          # Winkel-Parameter
          inclination_min_deg: int = -90
          inclination_max_deg: int = 90
          inclination_step_deg: int = 1
          direction_full_circle_deg: int = 360
      
          # === Abgeleitete Schwellenwerte (automatisch berechnet) ===
          @property
          def vmax_ms(self) -> float:
              """Maximale Geschwindigkeit in m/s."""
              return self.vmax_kmh / 3.6
      
          @property
          def kmh_to_ms(self) -> float:
              """Umrechnungsfaktor km/h zu m/s."""
              return 1.0 / 3.6
      
          # Landungsparameter
          safe_landing_v_absolute_kmh: float = 1.0  # Absolute sichere Landungsgeschwindigkeit
          safe_landing_v_relative_factor: float = 0.15  # Relative sichere Geschwindigkeit (Faktor von vmax)
          safe_landing_max_vz_absolute_ms: float = 1.0  # Maximale sichere vertikale Geschwindigkeit
      
          @property
          def safe_landing_v_threshold_kmh(self) -> float:
              """Sichere Landegeschwindigkeit (min von absolut und relativ)."""
              return min(self.safe_landing_v_absolute_kmh, self.vmax_kmh * self.safe_landing_v_relative_factor)
      
          @property
          def safe_landing_v_threshold_ms(self) -> float:
              """Sichere Lande-Geschwindigkeit in m/s."""
              return self.safe_landing_v_threshold_kmh * self.kmh_to_ms
      
          @property
          def safe_landing_max_vz_ms(self) -> float:
              """Maximale vertikale Geschwindigkeit für sichere Landung in m/s."""
              return self.safe_landing_max_vz_absolute_ms
      
          @property
          def landing_touchdown_z_eps(self) -> float:
              """Höhen-Epsilon für Touchdown (abgeleitet von UAV-Geometrie)."""
              return self.uav_height_m * 0.33  # ~0.1m bei height=0.3m
      
          @property
          def max_sink_rate_ms(self) -> float:
              """Maximale sichere Sinkrate in m/s."""
              return 2.0
      
          @property
          def safe_landing_inclination_max_deg(self) -> float:
              """Maximale sichere Neigung bei Landung in Grad."""
              return 20.0
      
          @property
          def safe_landing_vertical_tolerance_deg(self) -> float:
              """Toleranz für nahezu-vertikale Landung in Grad."""
              return 20.0
      
          @property
          def landing_detection_height_m(self) -> float:
              """Höhe für Landungsphasen-Detektion in Metern."""
              return 2.0
      
          # === Visualisierungsparameter ===
          window_size: int = 600
          update_interval_ms: int = 100
          shutdown_delay_ms: int = 1000
          crash_display_duration_ms: int = 2000
      
          # Viewport
          view_margin_factor: float = 0.8
          view_min_scaling: int = 1
          view_max_scaling: int = 100
          min_coordinate_epsilon: float = 1.0
      
          # HUD-Elemente
          hud_start_radius: float = 6.0
          hud_dest_out_radius: float = 6.0
          hud_dest_in_radius: float = 3.0
          hud_ufo_dot_radius: float = 4.0
          hud_text_margin: float = 12.0
          hud_text_line_height: float = 13.0
          hud_scale_length_m: float = 10.0
      
          # === Simulation-Steuerung ===
          speedup_min: int = 1
          speedup_max: int = 25
          speedup_default: int = 1
      
          # === Numerische Stabilität ===
          velocity_epsilon_ms: float = 0.001
          zero_value: float = 0.0
          one_value: float = 1.0
      
          # === Manöver-Erkennung ===
          observer_history_size: int = 50  # Anzahl der gespeicherten Zustände
          observer_analysis_window_size: int = 10  # Anzahl der Zustände für Trend-Analyse
          stagnation_movement_threshold_ratio: float = 0.5  # Bewegungsschwelle (Faktor der erwarteten Bewegung)
          turn_heading_threshold_deg: float = 5.0  # Minimale Richtungsänderung für Turn-Detektion
          climb_vz_threshold_ms: float = 0.5  # Minimale vz für Steigflug-Detektion
          descent_vz_threshold_ms: float = -0.5  # Maximale vz für Sinkflug-Detektion
      
      
      # Globale Standard-Konfiguration
      # Diese wird als Fallback verwendet, wenn keine explizite Konfiguration übergeben wird
      DEFAULT_CONFIG = SimulationConfig()
  - rel_path: src/core/simulation/observer/__init__.py
    hash: 45aed8bced6a1e734e9083800020e6c902cc5c453af8a568ea2ea91788e84429
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """
      Observer-Modul für Phasenbestimmung und Manöveranalyse.
      
      Implementiert rein lesende Analyse-Logik für UFO-Zustände ohne Schreibzugriffe.
      Erkennt Flugphasen und Manöver deterministisch aus Zustandswerten und Historie.
      """
      
      from .heading_delta import normalize_heading_delta
      from .observer import ManeuverAnalysis, StateObserver
      from .phase import Phase, compute_phase
      
      __all__ = [
          "Phase",
          "ManeuverAnalysis",
          "compute_phase",
          "normalize_heading_delta",
          "StateObserver",
      ]
  - rel_path: src/core/simulation/observer/heading_delta.py
    hash: 0334a26579c26877671b052af31ceb23aed8658950acc8600327d59293cf65a7
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """
      Normalisierung von Heading-Differenzen mit Wrap-around-Behandlung.
      
      Dieses Modul stellt Hilfsfunktionen zur Normalisierung von Winkeldifferenzen
      auf den Bereich [-180, 180] Grad bereit.
      """
      
      from __future__ import annotations
      
      
      def normalize_heading_delta(delta_d: float) -> float:
          """
          Normalisiert die Heading-Differenz auf den Bereich [-180, 180].
      
          Behandelt Wrap-around-Fälle korrekt, z.B.:
          - 350° → 10° ergibt +20° (nicht +340°)
          - 10° → 350° ergibt -20° (nicht -340°)
      
          Unterstützt auch mehrfache Umläufe (z.B. 720° → 0°).
      
          Args:
              delta_d: Rohdifferenz zwischen zwei Heading-Werten in Grad
      
          Returns:
              Normalisierte Differenz im Bereich [-180, 180] Grad
              (bei exakt ±180° wird -180° bevorzugt)
          """
          # Auf [-180, 180] normalisieren mit Modulo-Arithmetik
          delta_d = delta_d % 360
      
          # Bei exakt 180° bevorzugen wir -180° für Konsistenz
          if delta_d == 180.0:
              return -180.0
      
          if delta_d > 180:
              delta_d -= 360
          elif delta_d < -180:
              delta_d += 360
      
          return delta_d
  - rel_path: src/core/simulation/observer/observer.py
    hash: e3b8cb13afeb35359837646f5707715b670dc09c0cc8e3c2ff10e39bb53c5b2b
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """
      Observer-Modul für Manöveranalyse.
      
      Dieses Modul enthält die rein lesende Logik zur Analyse der UFO-Zustandshistorie.
      Es implementiert trendbasierte Manöveranalyse ohne Schreibzugriffe auf den State.
      
      Die Phasenerkennung ist in das Untermodul `phase` ausgelagert.
      """
      
      from __future__ import annotations
      
      import itertools
      from collections import deque
      from dataclasses import dataclass, replace as dataclass_replace
      
      import numpy as np
      
      from core.simulation.infrastructure.config import DEFAULT_CONFIG, SimulationConfig, get_logger
      from .heading_delta import normalize_heading_delta
      from .phase import Phase, compute_phase
      from ..state.state import UfoState
      
      # Logger für dieses Modul
      logger = get_logger(__name__)
      
      
      
      # =============================================================================
      # MANÖVER-ANALYSE - Beobachter-Schicht
      # =============================================================================
      
      @dataclass
      class ManeuverAnalysis:
          """
          Strukturierte Auswertung des aktuellen Manövers.
      
          Wird vom StateObserver aus dem Zustandsverlauf abgeleitet.
          """
          phase: Phase
          is_ascending: bool = False
          is_descending: bool = False
          is_turning: bool = False
          is_stagnating: bool = False
          avg_vz: float = 0.0
          avg_heading_change: float = 0.0
      
      
      class StateObserver:
          """
          Beobachter-Klasse für Manöver-Erkennung aus Zustandshistorie.
      
          Hält einen Ringpuffer der letzten N Zustände und leitet daraus
          das aktuelle Manöver ab. Rein lesend, keine Schreibzugriffe auf den State.
          """
      
          def __init__(self, config: SimulationConfig = DEFAULT_CONFIG):
              """
              Initialisiert den Observer mit gegebener Konfiguration.
      
              Args:
                  config: Simulations-Konfiguration für Schwellenwerte
              """
              self.config = config
              self.history: deque[UfoState] = deque(maxlen=config.observer_history_size)
              logger.info(f"StateObserver initialized with history_size={config.observer_history_size}")
      
          def observe(self, state: UfoState) -> None:
              """
              Fügt einen neuen Zustand zur Historie hinzu.
      
              Args:
                  state: Aktueller UFO-Zustand (sollte ein Snapshot sein)
              """
              self.history.append(dataclass_replace(state))
      
          def analyze(self) -> ManeuverAnalysis:
              """
              Analysiert die Historie und gibt eine strukturierte Manöver-Beschreibung zurück.
      
              Returns:
                  ManeuverAnalysis mit Phase und Flags
              """
              if not self.history:
                  return ManeuverAnalysis(phase="idle")
      
              current: UfoState = self.history[-1]
              phase: Phase = compute_phase(current, self.config)
      
              # Standardwerte
              is_ascending: bool = False
              is_descending: bool = False
              is_turning: bool = False
              is_stagnating: bool = False
              avg_vz: float = 0.0
              avg_heading_change: float = 0.0
      
              if len(self.history) >= 3:
                  # Berechne Durchschnitte über letzte N Zustände (aus Config)
                  window_size = self.config.observer_analysis_window_size
                  start_idx = max(0, len(self.history) - window_size)
                  recent = list(itertools.islice(self.history, start_idx, len(self.history)))
      
                  # Vertikale Bewegung
                  vz_values = [s.vz for s in recent]
                  if vz_values:
                      avg_vz = sum(vz_values) / len(vz_values)
                      is_ascending = avg_vz > self.config.climb_vz_threshold_ms
                      is_descending = avg_vz < self.config.descent_vz_threshold_ms
      
                  # Drehung (Heading-Änderung)
                  if len(recent) >= 2:
                      heading_changes = []
                      for i in range(1, len(recent)):
                          delta_d = recent[i].d - recent[i - 1].d
                          # Wrap-around mit Hilfsfunktion normalisieren
                          delta_d = normalize_heading_delta(delta_d)
                          heading_changes.append(abs(delta_d))
      
                      if heading_changes:
                          avg_heading_change = sum(heading_changes) / len(heading_changes)
                          is_turning = avg_heading_change > self.config.turn_heading_threshold_deg
      
                  # Stagnation (kaum Positionsänderung trotz Sollgeschwindigkeit)
                  if len(recent) >= 2:
                      total_distance = 0.0
                      for i in range(1, len(recent)):
                          # NumPy für effiziente Distanzberechnung
                          pos_delta = (
                              recent[i].position_vector - recent[i - 1].position_vector
                          )
                          total_distance += np.linalg.norm(pos_delta)
      
                      avg_distance_per_step = total_distance / (len(recent) - 1)
                      expected_distance = current.vel * self.config.dt
                      # Stagnation, nur wenn Sollgeschwindigkeit > 0 und
                      # tatsächliche Bewegung unter Schwellenwert der erwarteten
                      # Geschwindigkeit in die betrachtet wird
                      threshold_ratio = self.config.stagnation_movement_threshold_ratio
                      is_stagnating = (
                              current.v > 0.0 and
                              expected_distance > 0.0 and
                              avg_distance_per_step < expected_distance * threshold_ratio
                      )
      
              return ManeuverAnalysis(
                  phase=phase,
                  is_ascending=is_ascending,
                  is_descending=is_descending,
                  is_turning=is_turning,
                  is_stagnating=is_stagnating,
                  avg_vz=avg_vz,
                  avg_heading_change=avg_heading_change,
              )
      
          def get_maneuver_description(self) -> str:
              """
              Gibt eine lesbare Beschreibung des aktuellen Manövers zurück.
      
              Returns:
                  String-Beschreibung des Manövers
              """
              analysis = self.analyze()
      
              parts = [f"Phase: {analysis.phase}"]
      
              if analysis.is_ascending:
                  parts.append("climbing")
              elif analysis.is_descending:
                  parts.append("descending")
      
              if analysis.is_turning:
                  parts.append(f"turning (Δd={analysis.avg_heading_change:.1f}°/step)")
      
              if analysis.is_stagnating:
                  parts.append("stagnating")
      
              if analysis.avg_vz != 0.0:
                  parts.append(f"vz={analysis.avg_vz:.2f}m/s")
      
              return ", ".join(parts)
  - rel_path: src/core/simulation/observer/phase.py
    hash: 01b2219827dbab9c8eb3e69c1645f6183ddc1990688267d414cdfadf641c9f4f
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """
      Phasenmodell und Phasenerkennung für UFO-Flugzustände.
      
      Dieses Modul definiert die Flugphasen und implementiert die regelbasierte
      Phasenerkennung basierend auf dem aktuellen UFO-Zustand.
      """
      
      from __future__ import annotations
      
      from typing import Literal
      
      from core.simulation.infrastructure.config import DEFAULT_CONFIG, SimulationConfig
      from ..state.state import UfoState
      
      # =============================================================================
      # PHASENMODELL
      # =============================================================================
      
      Phase = Literal[
          "idle",  # am Boden, noch nicht gestartet
          "takeoff",  # gerade abgehoben, erste Flugsekunden
          "hovering",  # schwebt bewegungslos in der Luft
          "flying",  # aktiver Flug mit Horizontalbewegung
          "landing",  # kontrollierter Sinkflug zum Boden
          "landed",  # sicher gelandet nach Flug
          "crashed"  # abgestürzt (z < 0)
      ]
      
      
      def compute_phase(s: UfoState, config: SimulationConfig = DEFAULT_CONFIG) -> Phase:
          """
          Leitet die Flugphase deterministisch aus dem Zustand ab.
      
          Threadsicher und zustandslos. Verwendet Rule-basierte Evaluation mit
          Prioritätsreihenfolge - erste erfüllte Bedingung bestimmt die Phase.
      
          Phasen:
              - crashed: z < 0 (Crash-Marker)
              - idle: am Boden, noch nie geflogen
              - landed: am Boden nach erfolgreichem Flug
              - takeoff: gerade abgehoben (erste Sekunden in der Luft)
              - hovering: schwebt in der Luft (v ≈ 0, z > 0, vz ≈ 0)
              - landing: kontrollierter Sinkflug nahe Boden (vz < 0)
              - flying: normale Flugphase mit Bewegung
      
          Args:
              s: Aktueller UFO-Zustand
              config: Simulations-Konfiguration
      
          Returns:
              Phase als Literal-String
          """
          has_flown = s.dist > config.zero_value or s.ftime > config.zero_value
      
          # Rules werden in Prioritätsreihenfolge geprüft
          rules: list[tuple[Phase, bool]] = [
              (
                  "crashed",
                  s.z < config.zero_value
              ),
              (
                  "landed",
                  s.z == config.zero_value and s.v == 0.0 and has_flown
              ),
              (
                  "takeoff",
                  s.ftime == config.zero_value and s.v > 0.0 and s.z > config.zero_value,
              ),
              (
                  "landing",
                  s.v > 0.0 > s.vz and
                  config.zero_value < s.z <= config.landing_detection_height_m,
              ),
              (
                  "hovering",
                  s.z > config.zero_value >= abs(s.v) and
                  abs(s.vz) <= config.zero_value
              ),
              (
                  "flying",
                  s.v > 0.0 and s.z > config.zero_value
              ),
          ]
      
          for phase, condition in rules:
              if condition:
                  return phase
      
          return "idle"  # Default-Fall
  - rel_path: src/core/simulation/physics/__init__.py
    hash: f934b383329b55b695758a2738afbc6526fcd9fe543d0cb4fc2d0f68dff3c692
    content: |+
      """
      Physik-Engine für UFO-Simulation.
      
      Kapselt physikalische Berechnungslogik für Bewegung, Beschleunigung
      und Landung. Unabhängig von Threading und Zustandsverwaltung.
      
      Komponenten:
          - PhysicsEngine: Zeitschritt-basierte Integration mit 3D-Vektorrechnung
      """
      
      from .engine import PhysicsEngine
      
      __all__ = ['PhysicsEngine']


  - rel_path: src/core/simulation/physics/engine.py
    hash: 6e64f737a18d4547a18a71e650f65a8b1ef35fcaa5d17591f65a2d47bad08d22
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """Physik-Engine für UFO-Simulation."""
      
      from __future__ import annotations
      
      from dataclasses import replace as dataclass_replace
      from typing import Tuple, Literal
      
      import numpy as np
      
      from core.simulation.infrastructure import SimulationConfig, DEFAULT_CONFIG, get_logger
      from ..state.state import UfoState
      
      logger = get_logger(__name__)
      
      
      class PhysicsEngine:
          """
          Physik-Engine für UFO-Simulation.
      
          Rein funktional - keine Seiteneffekte, arbeitet mit immutable State.
          Thread-sicher durch externes Locking.
          """
      
          def __init__(self, config: SimulationConfig = DEFAULT_CONFIG):
              """Initialisiert PhysicsEngine mit Konfiguration."""
              self.config = config
              logger.debug(f"PhysicsEngine initialized with dt={config.dt}s, vmax={config.vmax_kmh}km/h")
      
          def integrate_step(self, state: UfoState) -> Tuple[UfoState, bool, bool]:
              """
              Führt vollständigen Physik-Integrationsschritt aus.
      
              Returns:
                  (updated_state, simulation_continues, landing_occurred)
              """
              simulation_continues = True
              landing_occurred = False
      
              current_state = state
      
              # Flugzeit hochzählen wenn in der Luft
              if current_state.z > self.config.zero_value:
                  current_state = dataclass_replace(current_state, ftime=current_state.ftime + self.config.dt)
      
              # Automatische Landungsassistenz
              current_state = self._apply_landing_assistance(current_state)
      
              # Zustandsgrößen aktualisieren
              current_state = self._update_velocity(current_state)
              current_state = self._update_direction(current_state)
              current_state = self._update_inclination(current_state)
      
              # Geschwindigkeit umrechnen und Distanz akkumulieren
              vel = current_state.v * self.config.kmh_to_ms
              dist = current_state.dist + vel * self.config.dt
              current_state = dataclass_replace(current_state, vel=vel, dist=dist)
      
              # Position und Beschleunigung aktualisieren
              current_state, position_result = self._update_position(current_state)
      
              if position_result == "landed":
                  landing_occurred = True
                  simulation_continues = False
      
              return current_state, simulation_continues, landing_occurred
      
          def _apply_landing_assistance(self, state: UfoState) -> UfoState:
              """
              Automatische Landungsassistenz für sichere Landungen.
      
              Aktiviert sich bei Landephase und korrigiert Geschwindigkeit, Neigung und Sinkrate.
              Nur aktiv wenn Benutzer nicht manuell steuert.
              """
              # Nur aktivieren wenn in Landehöhe und noch nicht gelandet
              if not (self.config.zero_value < state.z <= self.config.landing_detection_height_m and state.v > 0):
                  return state
      
              # Prüfe ob Benutzer aktiv steuert
              user_is_controlling = (
                      state.delta_v != self.config.zero_value or
                      state.delta_i != self.config.zero_value or
                      state.delta_d != self.config.zero_value
              )
      
              if user_is_controlling:
                  return state
      
              # === ASSISTENZ AKTIV ===
      
              updates = {}
      
              # Geschwindigkeitsreduktion auf sichere Landungsgeschwindigkeit
              safe_v_kmh = self.config.safe_landing_v_threshold_kmh
              if state.v > safe_v_kmh:
                  reduction = min(self.config.acceleration_kmh_per_step, state.v - safe_v_kmh)
                  updates['delta_v'] = -reduction
                  logger.debug(f"Landing assist: reducing velocity {state.v:.1f} -> {state.v - reduction:.1f} km/h")
      
              # Neigungskorrektur für sichere Landung
              current_i = state.i
      
              is_safe_angle = (
                      (-self.config.safe_landing_inclination_max_deg <= current_i <= -10.0) or
                      (-90.0 <= current_i <= -70.0)
              )
      
              if not is_safe_angle:
      
                  if current_i > -10.0:
                      # Zu flach -> steiler machen (Richtung -15°)
                      updates['delta_i'] = -self.config.inclination_step_deg
                      logger.debug(f"Landing assist: increasing descent angle {current_i:.1f}° -> steeper")
      
                  elif -70.0 < current_i < -self.config.safe_landing_inclination_max_deg:
                      # Zu steil aber nicht vertikal -> abflachen (Richtung -20°)
                      updates['delta_i'] = self.config.inclination_step_deg
                      logger.debug(f"Landing assist: reducing descent angle {current_i:.1f}° -> shallower")
      
              if updates:
                  return dataclass_replace(state, **updates)
              return state
      
          def _update_velocity(self, state: UfoState) -> UfoState:
              """
              Aktualisiert Geschwindigkeit basierend auf Sollwert-Änderung.
      
              Args:
                  state: Aktueller State
      
              Returns:
                  Aktualisierter State
              """
              dv = state.delta_v
              step = (dv > 0) - (dv < 0)
      
              if step != 0:
                  new_v = state.v + step * self.config.acceleration_kmh_per_step
                  clamped_v = max(0.0, min(new_v, self.config.vmax_kmh))
                  new_delta_v = state.delta_v - step * self.config.acceleration_kmh_per_step
                  return dataclass_replace(state, v=clamped_v, delta_v=new_delta_v)
      
              return state
      
          def _update_direction(self, state: UfoState) -> UfoState:
              """
              Aktualisiert Richtung mit Wrap-Around bei 360°.
      
              Args:
                  state: Aktueller State
      
              Returns:
                  Aktualisierter State
              """
              if state.delta_d != 0.0:
                  new_d = (state.d + state.delta_d) % self.config.direction_full_circle_deg
                  return dataclass_replace(state, d=new_d, delta_d=0.0)
              return state
      
          def _update_inclination(self, state: UfoState) -> UfoState:
              """
              Aktualisiert Neigung mit Clamping auf zulässigen Bereich.
      
              Args:
                  state: Aktueller State
      
              Returns:
                  Aktualisierter State
              """
              step = (state.delta_i > 0) - (state.delta_i < 0)
      
              if step != 0:
                  new_i = state.i + step * self.config.inclination_step_deg
                  max_d = float(self.config.inclination_max_deg)
                  min_d = float(self.config.inclination_min_deg)
                  clamped_i = max(min_d, min(new_i, max_d))
      
                  new_delta_i = state.delta_i - step * self.config.inclination_step_deg
                  return dataclass_replace(state, i=clamped_i, delta_i=new_delta_i)
      
              return state
      
          def _update_position(self, state: UfoState) -> Tuple[UfoState, Literal["continue", "landed"]]:
              """
              Aktualisiert Position, Geschwindigkeiten und Beschleunigungen.
      
              Verwendet NumPy für effiziente 3D-Vektormathematik.
      
              Args:
                  state: Aktueller State
      
              Returns:
                  Tupel (updated_state, result) wobei result "continue" oder "landed" ist
              """
              result: Literal["continue", "landed"] = "continue"
      
              if state.vel > self.config.velocity_epsilon_ms:
                  # Vorherige Geschwindigkeit speichern
                  if state.vx == 0.0 and state.vy == 0.0 and state.vz == 0.0 and state.ftime == 0.0:
                      prev_velocity = np.array([0.0, 0.0, 0.0], dtype=np.float64)
                  else:
                      prev_velocity = state.velocity_vector.copy()
      
                  # 3D-Vektormathematik mit sphärischen Koordinaten
                  theta = np.radians(90.0 - state.i)
                  phi = np.radians(state.d)
      
                  direction_unit = np.array([
                      np.sin(theta) * np.sin(phi),
                      np.sin(theta) * np.cos(phi),
                      np.cos(theta)
                  ], dtype=np.float64)
      
                  # Neue Geschwindigkeiten
                  new_velocity = state.vel * direction_unit
                  vx, vy, vz = new_velocity
      
                  # Position aktualisieren
                  position_delta = new_velocity * self.config.dt
                  x = state.x + position_delta[0]
                  y = state.y + position_delta[1]
                  z = state.z + position_delta[2]
      
                  # Beschleunigung berechnen
                  if self.config.dt > self.config.zero_value:
                      acceleration = (new_velocity - prev_velocity) / self.config.dt
                      accel_x, accel_y, accel_z = acceleration
                  else:
                      accel_x, accel_y, accel_z = state.accel_x, state.accel_y, state.accel_z
      
                  # State mit neuen Werten aktualisieren
                  state = dataclass_replace(
                      state,
                      vx=vx, vy=vy, vz=vz,
                      x=x, y=y, z=z,
                      accel_x=accel_x, accel_y=accel_y, accel_z=accel_z
                  )
      
                  # Landungs-Check
                  if state.z <= self.config.zero_value:
                      result = "landed"
                      state = self._handle_landing(state)
              else:
                  # Stillstand
                  updates = {
                      'vx': self.config.zero_value,
                      'vy': self.config.zero_value,
                      'vz': self.config.zero_value,
                      'accel_x': self.config.zero_value,
                      'accel_y': self.config.zero_value,
                      'accel_z': self.config.zero_value
                  }
      
                  # Touchdown bei geringer Höhe
                  if self.config.zero_value < state.z <= self.config.landing_touchdown_z_eps:
                      updates['z'] = self.config.zero_value
                      updates['vel'] = self.config.zero_value
                      updates['v'] = 0.0
                      result = "landed"
      
                  state = dataclass_replace(state, **updates)
      
              return state, result
      
          def _handle_landing(self, state: UfoState) -> UfoState:
              """
              Behandelt Landung: Prüft Kriterien und setzt Crash-Marker wenn nötig.
      
              Args:
                  state: Aktueller State
      
              Returns:
                  Aktualisierter State mit Landungsverarbeitung
              """
              # Sichere Landungskriterien prüfen
              safe_velocity = state.vel <= self.config.safe_landing_v_threshold_ms
              safe_vertical = abs(state.vz) <= self.config.safe_landing_max_vz_ms
              safe_inclination = (
                      abs(state.i) <= self.config.safe_landing_inclination_max_deg
                      or abs(state.i - self.config.inclination_max_deg) <= self.config.safe_landing_vertical_tolerance_deg
                      or abs(state.i - self.config.inclination_min_deg) <= self.config.safe_landing_vertical_tolerance_deg
              )
      
              is_safe_landing = safe_velocity and safe_vertical and safe_inclination
      
              if not is_safe_landing:
                  z_value = -self.config.one_value  # Crash-Marker
                  logger.warning(
                      f"CRASH: safe_v={safe_velocity} (vel={state.vel:.2f}m/s, max={self.config.safe_landing_v_threshold_ms:.2f}m/s), "
                      f"safe_vz={safe_vertical} (vz={state.vz:.2f}m/s, max={self.config.safe_landing_max_vz_ms:.2f}m/s), "
                      f"safe_i={safe_inclination} (i={state.i:.1f}°)"
                  )
              else:
                  z_value = self.config.zero_value
                  logger.info(f"Safe landing at position ({state.x:.1f}, {state.y:.1f})")
      
              # Alle Bewegungsgrößen nullen
              return dataclass_replace(
                  state,
                  z=z_value,
                  vel=self.config.zero_value,
                  v=0.0,
                  vx=self.config.zero_value,
                  vy=self.config.zero_value,
                  vz=self.config.zero_value
              )
  - rel_path: src/core/simulation/state/__init__.py
    hash: 0455555df93f00bcbf5e8da877d746047523a91d2e140b97451b6a7d823f36b6
    content: |+
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """
      Zustandsrepräsentation für UFO-Simulation.
      
      Kapselt die vollständige Zustandsrepräsentation als immutable dataclass
      und thread-sichere Zustandsverwaltung.
      
      Komponenten:
          - UfoState: Frozen dataclass für physikalischen Zustand (Position, Geschwindigkeit, etc.)
          - StateManager: Thread-sichere Zustandsverwaltung mit RLock
      """
      
      from .manager import StateManager
      from .state import UfoState
      
      __all__ = ["UfoState", "StateManager"]


  - rel_path: src/core/simulation/state/manager.py
    hash: c04fdcd0f5eb5e2579c75a317f06d6672f98e4a907220099ce3dcc33246a64b8
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """Thread-sicherer State-Manager für UFO-Zustandsverwaltung."""
      
      from __future__ import annotations
      
      import logging
      import threading
      from dataclasses import replace as dataclass_replace
      from typing import Callable, List, Optional
      
      from .state import UfoState
      from ..synchronization import conditional, synchronized
      
      logger = logging.getLogger(__name__)
      
      
      class StateManager:
          """
          Thread-sicherer Manager für UFO-Zustand mit Observer-Pattern.
      
          Verwaltet atomare Updates auf immutable UfoState und benachrichtigt
          registrierte Observer bei Zustandsänderungen. Event-basiertes Warten
          via Condition Variables.
          """
      
          def __init__(self, initial_state: Optional[UfoState] = None) -> None:
              """Initialisiert StateManager mit optionalem Anfangszustand."""
              self._state: UfoState = initial_state if initial_state is not None else UfoState()
              self._lock = threading.RLock()
              self._condition = threading.Condition(self._lock)
              self._observers: List[Callable[[UfoState], None]] = []
              logger.debug("StateManager initialized")
      
          @synchronized
          def get_snapshot(self) -> UfoState:
              """Gibt thread-sicheren Snapshot des aktuellen Zustands zurück."""
              return dataclass_replace(self._state)
      
          def update_state(self, update_func: Callable[[UfoState], UfoState]) -> None:
              """
              Führt atomare State-Aktualisierung aus und benachrichtigt Observer.
      
              update_func erhält aktuellen State und gibt neuen State zurück (immutable Pattern).
              """
              # Kritischer Abschnitt unter @conditional Lock
              snapshot, observers = self._update_state_atomic(update_func)
      
              # Observer außerhalb Lock benachrichtigen (Deadlock-Vermeidung)
              self._notify_observers(snapshot, observers)
      
          @conditional
          def _update_state_atomic(
              self,
              update_func: Callable[[UfoState], UfoState]
          ) -> tuple[UfoState, List[Callable[[UfoState], None]]]:
              """Atomarer State-Update unter Condition-Lock (private Methode)."""
              self._state = update_func(self._state)
              self._condition.notify_all()
              snapshot = dataclass_replace(self._state)
              observers_snapshot = list(self._observers)
              return snapshot, observers_snapshot
      
          @staticmethod
          def _notify_observers(snapshot: UfoState, observers: List[Callable[[UfoState], None]]) -> None:
              """
              Benachrichtigt alle registrierten Observer über State-Änderung.
      
              Observer-Exceptions werden geloggt, beeinflussen andere Observer nicht.
              """
              for observer in observers:
                  try:
                      observer(snapshot)
                  except Exception as e:
                      logger.error(f"Observer notification failed: {e}")
      
          @synchronized
          def register_observer(self, observer: Callable[[UfoState], None]) -> None:
              """Registriert Observer für State-Änderungen."""
              if observer not in self._observers:
                  self._observers.append(observer)
                  logger.debug(f"Observer registered, total: {len(self._observers)}")
      
          @synchronized
          def unregister_observer(self, observer: Callable[[UfoState], None]) -> None:
              """Entfernt Observer aus Benachrichtigungsliste."""
              if observer in self._observers:
                  self._observers.remove(observer)
                  logger.debug(f"Observer unregistered, remaining: {len(self._observers)}")
      
          def wait_for_condition(
              self, condition: Callable[[UfoState], bool], timeout: Optional[float] = None
          ) -> bool:
              """Wartet bis Bedingung erfüllt ist (event-basiert, kein Busy-Waiting).
      
              Nutzt Condition Variables für effizientes Warten. Der aufrufende Thread
              wird blockiert, bis entweder:
              1. Die Bedingung erfüllt ist (Return: True)
              2. Das Timeout abläuft (Return: False)
      
              Args:
                  condition: Bedingung die State prüft. Signatur: (state: UfoState) -> bool
                  timeout: Optionales Timeout in Sekunden. None = unbegrenztes Warten
      
              Returns:
                  True wenn Bedingung erfüllt, False bei Timeout
      
              Thread-Safety:
                  - Event-basiert: Kein Busy-Waiting, CPU-schonend
                  - Interrupt-sicher: Kann jederzeit abgebrochen werden
                  - Deadlock-frei: Nutzt Condition Variables korrekt
      
              Example::
      
                  # Warte bis Landung (mit Timeout)
                  landed = manager.wait_for_condition(
                      lambda s: s.z <= 0.1,
                      timeout=30.0
                  )
                  if landed:
                      print("Gelandet!")
      
                  # Warte unbegrenzt bis Ziel-Höhe
                  manager.wait_for_condition(lambda s: s.z >= 100.0)
              """
              # Delegation an zentrale ConditionWaiter-Utility
              from ..utils.condition_waiter import ConditionWaiter
      
              return ConditionWaiter.wait_for_condition(
                  condition_var=self._condition,
                  predicate=condition,
                  state_getter=lambda: self._state,
                  timeout=timeout
              )
      
      
      
          def reset(self) -> None:
              """
              Setzt State auf Ausgangszustand zurück.
      
              Erstellt einen neuen Default-UfoState und benachrichtigt alle Observer.
              Alle wartenden Threads werden aufgeweckt (via notify_all).
      
              Thread-Safety:
                  Diese Methode ist thread-sicher und atomar via @conditional.
      
              Example::
      
                  manager.reset()  # State zurück auf Startposition
              """
              # Kritischer Abschnitt unter @conditional Lock
              snapshot, observers = self._reset_atomic()
      
              # Observer außerhalb Lock benachrichtigen
              self._notify_observers(snapshot, observers)
      
          @conditional
          def _reset_atomic(self) -> tuple[UfoState, List[Callable[[UfoState], None]]]:
              """
              Atomarer State-Reset unter Condition-Lock (private Methode).
      
              Diese Methode ist mit @conditional dekoriert und führt den kritischen
              Abschnitt aus: State-Reset, Notification und Snapshot-Erstellung.
      
              Returns:
                  Tuple aus (snapshot, observers_list) für externe Benachrichtigung
              """
              self._state = UfoState()
              self._condition.notify_all()  # Kein nested lock dank @conditional
              snapshot = dataclass_replace(self._state)
              observers_snapshot = list(self._observers)
              logger.debug("State reset")
              return snapshot, observers_snapshot
      
          @property
          def state(self) -> UfoState:
              """
              Direkter Zugriff auf internen State (NICHT thread-sicher!).
      
              Nur für Legacy-Kompatibilität. Verwende get_snapshot() oder update_state().
      
              Warning:
                  Dieser direkte Zugriff ist NICHT thread-sicher und sollte nur in
                  Single-Threaded-Kontexten verwendet werden. Für produktiven Code
                  immer get_snapshot() verwenden!
      
              Returns:
                  Direkter Zugriff auf _state (ohne Kopie, ohne Lock)
              """
              return self._state
  - rel_path: src/core/simulation/state/state.py
    hash: ea57b93b1c1ecc4b586bc159ddf20e17259520bb1c880fc41b2fc34b6dd83114
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """Physikalische Zustandsrepräsentation des UFOs."""
      
      from dataclasses import dataclass
      
      import numpy as np
      
      
      @dataclass(slots=True, kw_only=True, frozen=True)
      class UfoState:
          """
          Immutable Dataclass für den vollständigen physikalischen Zustand.
      
          18 Felder: Position, Geschwindigkeit, Beschleunigung, Statistik, Steuerkommandos.
          Properties für NumPy-Vektoroperationen.
          """
      
          # Position [m]
          x: float = 0.0
          y: float = 0.0
          z: float = 0.0
      
          # Geschwindigkeit (v in km/h für Legacy-API, vel in m/s für Physik)
          v: float = 0.0  # Zielgeschwindigkeit in km/h
          vel: float = 0.0  # Aktuelle Geschwindigkeit in m/s
          d: float = 90.0  # Richtung in Grad (0=Nord, 90=Ost)
          i: float = 90.0  # Neigung in Grad (90=vertikal hoch, 0=horizontal, -90=vertikal runter)
      
          # Geschwindigkeitskomponenten [m/s]
          vx: float = 0.0  # Geschwindigkeit in x-Richtung (Ost/West)
          vy: float = 0.0  # Geschwindigkeit in y-Richtung (Nord/Süd)
          vz: float = 0.0  # Geschwindigkeit in z-Richtung (Höhe)
      
          # Beschleunigung [m/s²]
          accel_x: float = 0.0
          accel_y: float = 0.0
          accel_z: float = 0.0
      
          # Statistik
          dist: float = 0.0
          ftime: float = 0.0
      
          # Steuerkommandos
          delta_v: float = 0.0
          delta_d: float = 0.0
          delta_i: float = 0.0
      
          @property
          def position_vector(self) -> np.ndarray:
              """3D-Positionsvektor [x, y, z] in m."""
              return np.array([self.x, self.y, self.z], dtype=np.float64)
      
          @property
          def velocity_vector(self) -> np.ndarray:
              """3D-Geschwindigkeitsvektor [vx, vy, vz] in m/s."""
              return np.array([self.vx, self.vy, self.vz], dtype=np.float64)
      
          @property
          def acceleration_vector(self) -> np.ndarray:
              """3D-Beschleunigungsvektor [ax, ay, az] in m/s²."""
              return np.array([self.accel_x, self.accel_y, self.accel_z], dtype=np.float64)
  - rel_path: src/core/simulation/synchronization/__init__.py
    hash: 80fcae5296509beab2f304b0a45e403859eeb410d7b6cf1bb3fff790ec4fd59f
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """
      Thread-Synchronisation für die UFO-Simulation.
      
      Stellt generische Decorators für Thread-Sicherheit bereit.
      Projektübergreifend einsetzbar ohne Simulationsabhängigkeiten.
      
      Öffentliche API:
          - synchronized: Decorator für Instanzmethoden (self._lock)
          - synchronized_module: Decorator-Factory für Modul-Level-Funktionen
          - conditional: Decorator für Condition-Variable-Methoden
          - acquire_lock: Context Manager für explizite Lock-Acquisition
          - create_lock_wrapper: Factory für eigene Lock-Decorators
      
      Interne Struktur:
          - decorators/: High-Level Decorators für Endnutzer
          - primitives/: Low-Level Building Blocks (nicht direkt nutzen)
      """
      # Import von internen Untermodulen
      from .decorators.conditional import conditional
      from .decorators.instance import synchronized
      from .decorators.module import synchronized_module
      from .primitives.wrapper import acquire_lock, create_lock_wrapper
      
      __all__ = [
          "synchronized",
          "synchronized_module",
          "conditional",
          "acquire_lock",
          "create_lock_wrapper",
      ]
  - rel_path: src/core/simulation/synchronization/decorators/__init__.py
    hash: 95d58eb981174dfe07b743a3c8fbb56f4d74a6fc494d21e29237500cc422787a
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """
      High-Level Decorators für Thread-Synchronisation.
      
      Dieses Package stellt die öffentlichen Decorators für thread-sichere Methoden
      und Funktionen bereit. Die Decorators vereinfachen das Locking-Management
      durch automatische Lock-Acquisition und -Release.
      
      Komponenten:
          - synchronized: Decorator für Instanzmethoden (nutzt self._lock)
          - synchronized_module: Decorator-Factory für Modul-Level-Funktionen
          - conditional: Decorator für Methoden mit Condition-Variables
      
      Verwendung:
          Alle Decorators in diesem Package nutzen intern die primitives/ Building-Blocks,
          kapseln jedoch die Komplexität und bieten eine einfache, typsichere API.
      
          Instanzmethoden:
              Nutze @synchronized für Methoden, die self._lock erwarten.
              Das Lock wird automatisch vor der Methode erworben und nach
              der Ausführung (auch bei Exceptions) freigegeben.
      
          Modul-Funktionen:
              Nutze @synchronized_module(lock) für globale Funktionen.
              Erfordert ein explizites Lock-Objekt als Parameter.
      
          Condition-Variables:
              Nutze @conditional für Methoden, die self._condition nutzen.
              Verhindert nested locks bei notify_all()-Aufrufen.
      
      Thread-Safety:
          Alle Decorators sind thread-sicher und exception-sicher. Locks werden
          immer korrekt freigegeben, auch wenn die dekorierte Funktion eine
          Exception wirft.
      
      Beispiel:
          >>> import threading
          >>>
          >>> class ThreadSafeCounter:
          ...     def __init__(self):
          ...         self._lock = threading.RLock()
          ...         self.value = 0
          ...
          ...     @synchronized
          ...     def increment(self):
          ...         self.value += 1
          ...
          ...     @synchronized
          ...     def get_value(self):
          ...         return self.value
      """
      
      from .conditional import conditional
      from .instance import synchronized
      from .module import synchronized_module
      
      __all__ = [
          "synchronized",
          "synchronized_module",
          "conditional",
      ]
  - rel_path: src/core/simulation/synchronization/decorators/conditional.py
    hash: 47fb577058911d52f8ae8b02d874899e5eb7ed5e8638c28422f918c3be5055f9
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """
      Decorator für thread-sichere Methoden mit Condition-Variable-Unterstützung.
      
      Implementiert @conditional für Methoden, die self._condition nutzen.
      """
      
      from __future__ import annotations
      
      from typing import Any, Callable, TypeVar
      
      from ..primitives.wrapper import create_lock_wrapper
      
      F = TypeVar("F", bound=Callable[..., Any])
      
      
      def conditional(method: F) -> F:
          """
          Decorator für Methoden die mit threading.Condition arbeiten.
      
          Erwartet self._condition (threading.Condition) auf der Klasseninstanz.
          Nutzt das interne Lock der Condition - verhindert nested locks bei notify_all().
      
          Unterschied zu @synchronized:
              - @synchronized: Nutzt self._lock direkt
              - @conditional: Nutzt self._condition (deren internes Lock)
      
          Args:
              method: Zu dekorierende Methode
      
          Returns:
              Thread-sichere Version der Methode
      
          Raises:
              AttributeError: Falls self._condition nicht existiert
          """
          return create_lock_wrapper(lambda self, *args, **kwargs: self._condition)(method)
  - rel_path: src/core/simulation/synchronization/decorators/instance.py
    hash: c67b408e69b4277ca7cd8c7f554c8928b1ab5753b1d7f5b558a11bcc2b34dbb8
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """
      Decorator für thread-sichere Instanzmethoden.
      
      Implementiert @synchronized für Methoden, die self._lock nutzen.
      """
      
      from __future__ import annotations
      
      from typing import Any, Callable, TypeVar
      
      from ..primitives.wrapper import create_lock_wrapper
      
      F = TypeVar("F", bound=Callable[..., Any])
      
      
      def synchronized(method: F) -> F:
          """
          Decorator für Instanzmethoden mit automatischem Locking.
      
          Erwartet self._lock-Attribut (threading.Lock oder threading.RLock).
      
          Args:
              method: Zu dekorierende Instanzmethode
      
          Returns:
              Thread-sichere Version der Methode
      
          Raises:
              AttributeError: Falls self._lock nicht existiert
          """
          return create_lock_wrapper(lambda self, *args, **kwargs: self._lock)(method)
  - rel_path: src/core/simulation/synchronization/decorators/module.py
    hash: ae5cf82443baff01adfbf980c8d28869c19dba4ae330d63100b751c54ac3321c
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """
      Decorator-Factory für thread-sichere Modul-Level-Funktionen.
      
      Implementiert @synchronized_module(lock) für globale Funktionen.
      """
      
      from __future__ import annotations
      
      import threading
      from typing import Any, Callable, TypeVar
      
      from ..primitives.wrapper import create_lock_wrapper
      
      F = TypeVar("F", bound=Callable[..., Any])
      
      
      def synchronized_module(lock: threading.Lock | threading.RLock) -> Callable[[F], F]:
          """
          Decorator-Factory für Modul-Level-Funktionen mit explizitem Lock.
      
          Args:
              lock: Lock-Objekt für die Synchronisation (Lock oder RLock)
      
          Returns:
              Decorator-Funktion für thread-sichere Funktionen
      
          Raises:
              TypeError: Falls lock kein Lock-Objekt ist
          """
          return create_lock_wrapper(lambda *args, **kwargs: lock)
  - rel_path: src/core/simulation/synchronization/primitives/__init__.py
    hash: b7e7f73084f650f5e954844cbbeb772b58300da8e0caaa528950988cfda3e2e9
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """
      Low-Level Lock-Primitives für Thread-Synchronisation.
      
      Dieses Package enthält die grundlegenden Building-Blocks für Lock-basierte
      Synchronisation. Diese Komponenten werden intern von den decorators/ verwendet
      und sollten nicht direkt von außerhalb genutzt werden.
      
      Komponenten:
          - acquire_lock: Context-Manager für sichere Lock-Acquisition
          - create_lock_wrapper: Factory-Funktion für Lock-basierte Decorators
      
      Zweck:
          Die Primitives kapseln die low-level Lock-Verwaltung (acquire/release)
          und stellen sicher, dass Locks immer korrekt freigegeben werden, auch
          bei Exceptions. Sie dienen als Basis für die High-Level-Decorators.
      
      Verwendung:
          Nutze NICHT direkt diese Primitives, sondern die Decorators aus dem
          decorators/ Package. Die Primitives sind als interne Implementierungs-
          details gedacht und ihre API kann sich ändern.
      
          Für eigene Lock-Decorators:
              Falls du eigene Decorator-Varianten benötigst, kannst du
              create_lock_wrapper() nutzen. Siehe wrapper.py für Details.
      
      Thread-Safety:
          Alle Funktionen in diesem Package sind thread-sicher und exception-sicher.
          Der Context-Manager acquire_lock() garantiert, dass das Lock immer
          freigegeben wird, auch bei Exceptions.
      
      Architektur:
          Die Trennung von primitives/ und decorators/ folgt dem Prinzip der
          Separation of Concerns:
          - primitives/ = WIE funktioniert Locking (Implementierung)
          - decorators/ = WAS wird gelockt (API für Endnutzer)
      """
      
      from .wrapper import acquire_lock, create_lock_wrapper
      
      __all__ = [
          "acquire_lock",
          "create_lock_wrapper",
      ]
  - rel_path: src/core/simulation/synchronization/primitives/wrapper.py
    hash: a90c453967c06b0305ae1a97b56b3a57ce69268ce73f53b32e0ff8202415174b
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """
      Lock-Wrapper-Utilities für thread-sichere Decorators.
      
      Implementiert die Kern-Funktionalität für Lock-Acquisition und Decorator-Factory.
      """
      
      from __future__ import annotations
      
      import threading
      from contextlib import contextmanager
      from functools import wraps
      from typing import Any, Callable, Generator, TypeVar
      
      F = TypeVar("F", bound=Callable[..., Any])
      
      
      @contextmanager
      def acquire_lock(lock: threading.Lock | threading.RLock | threading.Condition) -> Generator[None, None, None]:
          """
          Context-Manager für thread-sichere Lock-Acquisition.
      
          Args:
              lock: Lock-Objekt (Lock, RLock oder Condition)
      
          Yields:
              None - Lock ist während yield aktiv
      
          Note:
              Lock wird garantiert freigegeben, auch bei Exceptions.
          """
          lock.acquire()
          try:
              yield
          finally:
              lock.release()
      
      
      def create_lock_wrapper(lock_getter: Callable[..., Any]) -> Callable[[F], F]:
          """
          Factory-Funktion für Lock-basierte Decorators.
      
          Args:
              lock_getter: Callable das das Lock zurückgibt.
                          Erhält die gleichen Argumente wie die dekorierte Funktion.
      
          Returns:
              Decorator-Funktion die das Locking implementiert
      
          Note:
              Diese Funktion ist das Fundament aller @synchronized-Varianten.
              Sie kapselt das acquire/release-Pattern in einem wiederverwendbaren Decorator.
          """
      
          def decorator(func: F) -> F:
              @wraps(func)
              def wrapper(*args: Any, **kwargs: Any) -> Any:
                  lock = lock_getter(*args, **kwargs)
                  with acquire_lock(lock):
                      return func(*args, **kwargs)
      
              return wrapper  # type: ignore[return-value]
      
          return decorator
  - rel_path: src/core/simulation/ufo_main.py
    hash: d5d19a599cd33599dbc877344d7ddbce43064862aff31683a6b97a4f45a4d1dd
    content: |-
      from task.autopilot import Autopilot  # ← Automatisch die richtige Klasse!
      from core.simulation.state import UfoState
      from .ufosim import Phase, UfoSim
      
      if __name__ == "__main__":
          sim = UfoSim()
      
          print("\n" + "=" * 70)
          print("STARTBEDINGUNGEN:")
          print(f"  Position: ({sim.state.x}, {sim.state.y}, {sim.state.z})m")
          print(f"  Geschwindigkeit: {sim.state.v} km/h")
          print(f"  Richtung: {sim.state.d}° (0=Nord, 90=Ost, 180=Süd, 270=West)")
          print(f"  Neigung: {sim.state.i}° (90=hoch, 0=horizontal, -90=runter)")
          print("=" * 70 + "\n")
      
          autopilot = Autopilot()
      
          destinations = [(100.0, 0.0)]
      
          sim.start(
              speedup=50,
              destinations=destinations,
              show_view=True,
              enable_logging=True,
              log_interval_s=0.5,
              autopilot_callback=autopilot
          )
      
          print("\n" + "=" * 70)
          print("SIMULATION BEENDET")
          print("=" * 70)
          final_phase: Phase = sim.get_phase()
          final_state: UfoState = sim.get_state_snapshot()
          print(f"Endposition: ({final_state.x:.2f}, {final_state.y:.2f}, {final_state.z:.2f})m")
          print(f"Phase: {final_phase}")
          print(f"Gesamtdistanz: {final_state.dist:.2f}m")
          print(f"Flugzeit: {final_state.ftime:.2f}s")
          print("=" * 70 + "\n")
  - rel_path: src/core/simulation/ufosim.py
    hash: a4122184a58e17a1a3a87ee8c2a36b4878f792beaecbdde8c28bcaa00c88ee51
    content: "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nUFO-Simulation Controller.\n\
    \nOrchestriert Simulation-Lifecycle, Threading und Komponenten-Integration.\n\"\"\"\n\n\
    from __future__ import annotations\n\nimport threading\nimport time\nfrom dataclasses\
    \ import dataclass, replace as dataclass_replace\nfrom pathlib import Path\nfrom typing\
    \ import Optional, List, Tuple, overload, Callable, Any, final\n\nimport numpy as np\n\
    # noinspection PyPackageRequirements\nfrom PyQt5 import QtWidgets, QtGui, QtCore\n\nfrom\
    \ .command import Command, CommandType\nfrom .infrastructure import DEFAULT_CONFIG, SimulationConfig,\
    \ get_logger\nfrom .observer import Phase, ManeuverAnalysis, compute_phase, StateObserver\n\
    from .physics import PhysicsEngine\nfrom .state import UfoState, StateManager\nfrom .synchronization\
    \ import conditional, synchronized\n\nlogger = get_logger(__name__)\n\n\n# =============================================================================\n\
    # COMMAND SYSTEM - Deklarative Steuerung ohne Warteschleifen\n# =============================================================================\n\
    # CommandType und Command sind nun in command/types.py definiert\n# und werden am Anfang\
    \ dieser Datei importiert.\n\n\nclass CommandQueue:\n    \"\"\"\n    Command Queue für\
    \ deklarative Autopilot-Steuerung.\n\n    Statt:\n        while sim.state.z < 10:\n  \
    \          time.sleep(0.05)\n\n    Schreibe:\n        queue.wait_until(lambda s: s.z >=\
    \ 10)\n\n    Die Simulation führt Commands automatisch aus, wenn Bedingungen erfüllt sind.\n\
    \    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialisiert eine leere Command\
    \ Queue.\"\"\"\n        self.commands: List[Command] = []\n        self.current_index:\
    \ int = 0\n        self._lock = threading.RLock()\n        self._completed = threading.Event()\n\
    \n    @property\n    def lock(self) -> threading.RLock:\n        \"\"\"Interner Lock für\
    \ threadsicheren Zugriff.\"\"\"\n        return self._lock\n\n    def set_state(self,\
    \ attribute: str, value: Any) -> 'CommandQueue':\n        \"\"\"\n        Setze State-Attribut.\n\
    \n        Example:\n            >>> CommandQueue().set_state('i', 90).set_state('delta_v',\
    \ 10)\n        \"\"\"\n        self.commands.append(Command(\n            type=CommandType.SET_STATE,\n\
    \            target=attribute,\n            value=value\n        ))\n        return self\n\
    \n    def wait_until(\n            self,\n            condition: Callable[[UfoState],\
    \ bool],\n            timeout: Optional[float] = None\n    ) -> 'CommandQueue':\n    \
    \    \"\"\"\n        Warte bis Bedingung erfüllt (OHNE Schleife!).\n\n        Example:\n\
    \            >>> queue = CommandQueue()\n            >>> queue..wait_until(lambda s: s.z\
    \ >= 10.0)\n        \"\"\"\n        self.commands.append(Command(\n            type=CommandType.WAIT_CONDITION,\n\
    \            condition=condition,\n            timeout=timeout\n        ))\n        return\
    \ self\n\n    def execute(self, func: Callable) -> 'CommandQueue':\n        \"\"\"\n \
    \       Führe Funktion aus.\n\n        Example:\n            >>> CommandQueue().execute(lambda:\
    \ print(\"Checkpoint!\"))\n        \"\"\"\n        self.commands.append(Command(\n   \
    \         type=CommandType.EXECUTE_FUNC,\n            func=func\n        ))\n        return\
    \ self\n\n    def log(self, message: str) -> 'CommandQueue':\n        \"\"\"\n       \
    \ Gebe Log-Nachricht aus.\n\n        Example:\n            >>> CommandQueue().log(\"Takeoff\
    \ started\")\n        \"\"\"\n        self.commands.append(Command(\n            type=CommandType.LOG_MESSAGE,\n\
    \            message=message\n        ))\n        return self\n\n    @synchronized\n \
    \   def is_completed(self) -> bool:\n        \"\"\"Prüft ob alle Commands ausgeführt wurden.\"\
    \"\"\n        return self.current_index >= len(self.commands)\n\n    def wait_for_completion(self,\
    \ timeout: Optional[float] = None) -> bool:\n        \"\"\"\n        Wartet bis alle Commands\
    \ ausgeführt wurden.\n\n        Returns:\n            True wenn completed, False bei Timeout\n\
    \        \"\"\"\n        return self._completed.wait(timeout=timeout)\n\n    def mark_completed(self)\
    \ -> None:\n        \"\"\"Markiert Queue als vollständig ausgeführt.\"\"\"\n        self._completed.set()\n\
    \n\n# =============================================================================\n\
    # COMMAND EXECUTOR - Event-basierte Command-Verarbeitung\n# =============================================================================\n\
    \nclass CommandExecutor:\n    \"\"\"\n    Executor für Command Queues - entkoppelt von\
    \ Simulationsloop.\n\n    Verarbeitet Commands event-basiert wenn sich der State ändert.\n\
    \    Läuft in separatem Thread für vollständige Isolation.\n    \"\"\"\n\n    def __init__(self,\
    \ state_manager: StateManager):\n        \"\"\"\n        Initialisiert CommandExecutor\
    \ mit StateManager.\n\n        Args:\n            state_manager: StateManager zur State-Überwachung\n\
    \        \"\"\"\n        self._state_manager = state_manager\n        self._active_queue:\
    \ Optional[CommandQueue] = None\n        self._lock = threading.RLock()\n        logger.debug(\"\
    CommandExecutor initialized\")\n\n    @synchronized\n    def set_active_queue(self, queue:\
    \ CommandQueue) -> None:\n        \"\"\"\n        Setzt aktive Command Queue.\n\n    \
    \    Args:\n            queue: Auszuführende CommandQueue\n        \"\"\"\n        self._active_queue\
    \ = queue\n        logger.info(f\"CommandQueue activated with {len(queue.commands)} commands\"\
    )\n\n    @synchronized\n    def clear_active_queue(self) -> None:\n        \"\"\"Entfernt\
    \ aktive Queue.\"\"\"\n        self._active_queue = None\n        logger.debug(\"CommandQueue\
    \ cleared\")\n\n    @synchronized\n    def process_commands(self, current_state: UfoState)\
    \ -> None:\n        \"\"\"\n        Verarbeitet Commands der aktiven Queue basierend auf\
    \ aktuellem State.\n\n        Args:\n            current_state: Aktueller State für Bedingungsprüfung\n\
    \        \"\"\"\n        if self._active_queue is None or self._active_queue.is_completed():\n\
    \            return\n\n        queue = self._active_queue\n\n        with queue.lock:\n\
    \            # Verarbeite aktuellen Command\n            if queue.current_index < len(queue.commands):\n\
    \                cmd = queue.commands[queue.current_index]\n\n                # SET_STATE:\
    \ Direkt ausführen\n                if cmd.type == CommandType.SET_STATE:\n          \
    \          self._execute_set_state(cmd)\n                    queue.current_index += 1\n\
    \n                # LOG_MESSAGE: Direkt ausführen\n                elif cmd.type == CommandType.LOG_MESSAGE:\n\
    \                    print(cmd.message)\n                    logger.debug(f\"Command executed:\
    \ LOG {cmd.message}\")\n                    queue.current_index += 1\n\n             \
    \   # EXECUTE_FUNC: Direkt ausführen\n                elif cmd.type == CommandType.EXECUTE_FUNC:\n\
    \                    if cmd.func: cmd.func()\n                    logger.debug(\"Command\
    \ executed: FUNC\")\n                    queue.current_index += 1\n\n                #\
    \ WAIT_CONDITION: Prüfe Bedingung\n                elif cmd.type == CommandType.WAIT_CONDITION:\n\
    \                    if cmd.condition is not None and cmd.condition(current_state):\n\
    \                        logger.debug(\"Command executed: WAIT condition fulfilled\")\n\
    \                        queue.current_index += 1\n\n            # Prüfe ob Queue fertig\n\
    \            if queue.current_index >= len(queue.commands):\n                queue.mark_completed()\n\
    \                logger.info(\"CommandQueue completed\")\n                self._active_queue\
    \ = None\n\n    def _execute_set_state(self, cmd: Command) -> None:\n        \"\"\"\n\
    \        Führt SET_STATE Command aus.\n\n        Args:\n            cmd: Command mit target\
    \ und value\n        \"\"\"\n\n        def update(state: UfoState) -> UfoState:\n    \
    \        return dataclass_replace(state, **{cmd.target: cmd.value})\n\n        self._state_manager.update_state(update)\n\
    \        logger.debug(f\"Command executed: SET {cmd.target}={cmd.value}\")\n\n\n# =============================================================================\n\
    # VIEWPORT - Dynamisches Zoom-System\n# =============================================================================\n\
    \n@dataclass\nclass UfoViewport:\n    \"\"\"\n    Viewport- und Skalierungslogik für die\
    \ UFO-Karte.\n\n    Berechnet dynamisch den Zoom-Faktor basierend auf Start- und Zielpunkten,\n\
    \    sodass alle relevanten Punkte im Fenster sichtbar bleiben.\n    \"\"\"\n\n    width:\
    \ int\n    height: int\n    config: SimulationConfig = DEFAULT_CONFIG\n    scaling: int\
    \ = None\n\n    def __post_init__(self) -> None:\n        \"\"\"Initialisiert scaling\
    \ falls nicht gesetzt.\"\"\"\n        if self.scaling is None:\n            self.scaling\
    \ = self.config.view_min_scaling\n\n    def configure_for_points(self, points: List[Tuple[float,\
    \ float]]) -> None:\n        \"\"\"\n        Bestimmt die optimale Skalierung aus einer\
    \ Menge von Punkten.\n\n        Args:\n            points: Liste von (x, y)-Koordinaten\
    \ in Metern.\n        \"\"\"\n        final_scaling = self.config.view_min_scaling\n\n\
    \        if points:\n            max_abs_x = max(abs(x) for x, _ in points) or self.config.min_coordinate_epsilon\n\
    \            max_abs_y = max(abs(y) for _, y in points) or self.config.min_coordinate_epsilon\n\
    \n            half_w = self.width * self.config.view_margin_factor / 2.0\n           \
    \ half_h = self.height * self.config.view_margin_factor / 2.0\n\n            scale_x =\
    \ half_w / max_abs_x\n            scale_y = half_h / max_abs_y\n\n            s = min(scale_x,\
    \ scale_y)\n            final_scaling = max(self.config.view_min_scaling, min(int(s),\
    \ self.config.view_max_scaling))\n\n        self.scaling = final_scaling\n\n    def to_screen(self,\
    \ x: float, y: float) -> Tuple[float, float]:\n        \"\"\"\n        Wandelt Weltkoordinaten\
    \ (x, y) in Bildschirmkoordinaten (px, py) um.\n\n        Args:\n            x: X-Koordinate\
    \ in Metern\n            y: Y-Koordinate in Metern\n\n        Returns:\n            Tupel\
    \ (px, py) in Pixelkoordinaten\n        \"\"\"\n        cx = self.width / 2.0\n      \
    \  cy = self.height / 2.0\n        px = cx + x * self.scaling\n        py = cy - y * self.scaling\n\
    \        return px, py\n\n\n# =============================================================================\n\
    # STATE MANAGER - Thread-sichere Zustandsverwaltung (Legacy)\n# =============================================================================\n\
    \nclass _UfoLegacyStateManager:\n    \"\"\"\n    Thread-sicherer Manager für UFO-Zustand\
    \ (Legacy-Implementierung).\n\n    DEPRECATED: Wird durch StateManager aus state.manager\
    \ ersetzt.\n    Nur für Abwärtskompatibilität mit altem Code beibehalten.\n\n    Kapselt\
    \ Zugriff auf UfoState und bietet Event-System für Änderungsbenachrichtigungen.\n    Implementiert\
    \ Observer-Pattern für Listener-Registrierung.\n    \n    Refactored für frozen UfoState:\
    \ update_state() akzeptiert Funktionen, die neuen State zurückgeben.\n    \"\"\"\n\n \
    \   def __init__(self, initial_state: Optional['UfoState'] = None):\n        \"\"\"\n\
    \        Initialisiert StateManager mit optionalem Anfangszustand.\n\n        Args:\n\
    \            initial_state: Optionaler initialer Zustand (Standard: neuer UfoState())\n\
    \        \"\"\"\n        self._state: UfoState = initial_state if initial_state is not\
    \ None else UfoState()\n        self._lock = threading.RLock()\n        self._condition\
    \ = threading.Condition(self._lock)\n        self._observers: List[Callable[[UfoState],\
    \ None]] = []\n        logger.debug(\"StateManager initialized\")\n\n    @synchronized\n\
    \    def get_snapshot(self) -> 'UfoState':\n        \"\"\"\n        Gibt thread-sicheren\
    \ Snapshot des aktuellen Zustands zurück.\n\n        Returns:\n            Kopie des aktuellen\
    \ UfoState\n        \"\"\"\n        return dataclass_replace(self._state)\n\n    def update_state(self,\
    \ update_func: Callable[['UfoState'], 'UfoState']) -> None:\n        \"\"\"\n        Führt\
    \ atomare State-Aktualisierung aus und benachrichtigt Observer.\n\n        Args:\n   \
    \         update_func: Funktion die neuen State zurückgibt (immutable Pattern)\n     \
    \   \"\"\"\n        # Kritischer Abschnitt unter @conditional\n        snapshot = self._update_state_atomic(update_func)\n\
    \n        # Benachrichtige Observer außerhalb Lock (Deadlock-Vermeidung)\n        self._notify_observers(snapshot)\n\
    \n    @conditional\n    def _update_state_atomic(self, update_func: Callable[['UfoState'],\
    \ 'UfoState']) -> 'UfoState':\n        \"\"\"Atomarer State-Update unter Condition-Lock\
    \ (verhindert nested lock).\"\"\"\n        self._state = update_func(self._state)\n  \
    \      self._condition.notify_all()  # Kein nested lock dank @conditional\n        return\
    \ dataclass_replace(self._state)\n\n    def _notify_observers(self, snapshot: 'UfoState')\
    \ -> None:\n        \"\"\"\n        Benachrichtigt alle registrierten Observer über State-Änderung.\n\
    \n        Args:\n            snapshot: Snapshot des neuen Zustands\n        \"\"\"\n \
    \       for observer in self._observers:\n            try:\n                observer(snapshot)\n\
    \            except Exception as e:  # noqa: BLE001 - Breiter Catch bewusst: Observer\
    \ können beliebige Exceptions werfen, dürfen aber andere Observer nicht blockieren\n \
    \               logger.exception(f\"Observer notification failed: {e}\")\n\n    @synchronized\n\
    \    def register_observer(self, observer: Callable[['UfoState'], None]) -> None:\n  \
    \      \"\"\"\n        Registriert Observer für State-Änderungen.\n\n        Args:\n \
    \           observer: Callable das bei jeder Änderung aufgerufen wird\n        \"\"\"\n\
    \        if observer not in self._observers:\n            self._observers.append(observer)\n\
    \            logger.debug(f\"Observer registered, total: {len(self._observers)}\")\n\n\
    \    @synchronized\n    def unregister_observer(self, observer: Callable[['UfoState'],\
    \ None]) -> None:\n        \"\"\"\n        Entfernt Observer aus Benachrichtigungsliste.\n\
    \n        Args:\n            observer: Zu entfernender Observer\n        \"\"\"\n    \
    \    if observer in self._observers:\n            self._observers.remove(observer)\n \
    \           logger.debug(f\"Observer unregistered, remaining: {len(self._observers)}\"\
    )\n\n    def wait_for_condition(\n            self,\n            condition: Callable[['UfoState'],\
    \ bool],\n            timeout: Optional[float] = None\n    ) -> bool:\n        \"\"\"\n\
    \        Wartet bis Bedingung erfüllt ist (event-basiert, kein Busy-Waiting).\n\n    \
    \    Args:\n            condition: Bedingung die State prüft\n            timeout: Optionales\
    \ Timeout in Sekunden\n\n        Returns:\n            True wenn Bedingung erfüllt, False\
    \ bei Timeout\n        \"\"\"\n        # Delegation an zentrale ConditionWaiter-Utility\n\
    \        from .utils.condition_waiter import ConditionWaiter\n\n        return ConditionWaiter.wait_for_condition(\n\
    \            condition_var=self._condition,\n            predicate=condition,\n      \
    \      state_getter=lambda: self._state,\n            timeout=timeout\n        )\n\n\n\
    \    def reset(self) -> None:\n        \"\"\"Setzt State auf Ausgangszustand zurück.\"\
    \"\"\n        self._reset_atomic()\n\n    @conditional\n    def _reset_atomic(self) ->\
    \ None:\n        \"\"\"Atomarer State-Reset unter Condition-Lock (verhindert nested lock).\"\
    \"\"\n        self._state = UfoState()\n        self._condition.notify_all()  # Kein nested\
    \ lock dank @conditional\n        logger.debug(\"State reset\")\n\n    @property\n   \
    \ def state(self) -> 'UfoState':\n        \"\"\"\n        Direkter Zugriff auf internen\
    \ State (NICHT thread-sicher!).\n\n        Nur für Legacy-Kompatibilität. Verwende get_snapshot()\
    \ oder update_state().\n        \"\"\"\n        return self._state\n\n\n# =============================================================================\n\
    # SIMULATION CONTROLLER - Orchestrierung ohne Implementierung\n# =============================================================================\n\
    \nclass UfoSim:\n    \"\"\"\n    Schlanker Controller für UFO-Simulation.\n\n    Orchestriert\
    \ Komponenten ohne eigene Implementierung:\n    - StateManager für Thread-Safety\n   \
    \ - PhysicsEngine für Berechnungen\n    - CommandExecutor für Autopilot\n    - StateObserver\
    \ für Manöver-Analyse\n\n    Verantwortlich nur für:\n    - Komponenten-Initialisierung\n\
    \    - Thread-Management\n    - Logging-Koordination\n    - Public API\n    \"\"\"\n\n\
    \    __version__ = \"5.2.0-tw-refactored\"\n    __author__ = \"tomtastisch (i-ki 1)\"\n\
    \    __release_date__ = \"2025-01-15\"\n\n    def __init__(self, config: SimulationConfig\
    \ = DEFAULT_CONFIG) -> None:\n        \"\"\"\n        Initialisiert Simulation durch Komponenten-Komposition.\n\
    \n        Args:\n            config: Simulations-Konfiguration (Standard: DEFAULT_CONFIG)\n\
    \        \"\"\"\n        self.config = config\n\n        # Komponenten\n        self._state_manager\
    \ = StateManager()\n        self._physics_engine = PhysicsEngine(config)\n        self._command_executor\
    \ = CommandExecutor(self._state_manager)\n        self.observer = StateObserver(config)\n\
    \n        # Registriere Observer als Listener für State-Änderungen\n        self._state_manager.register_observer(self.observer.observe)\n\
    \n        # Runtime-State\n        self.__speedup = int(config.one_value)\n        self.__running\
    \ = False\n        self.__logging_enabled = False\n        self.__log_interval_s = 1.0\n\
    \        self.__log_every_step = False\n        self.__last_log_time = 0.0\n        self.__destinations:\
    \ List[Tuple[float, float]] = []\n\n        # Threading\n        self._view: Optional['UfoPView']\
    \ = None\n        self._sim_thread: Optional[threading.Thread] = None\n        self._autopilot_thread:\
    \ Optional[threading.Thread] = None\n\n        logger.info(f\"UfoSim v{self.__version__}\
    \ initialized with config: dt={config.dt}s, vmax={config.vmax_kmh}km/h\")\n\n    def reset(self)\
    \ -> None:\n        \"\"\"Setzt die Simulation auf den Ausgangszustand zurück.\"\"\"\n\
    \        self.__running = False\n        self._state_manager.reset()\n        self.observer\
    \ = StateObserver(self.config)\n        self._state_manager.register_observer(self.observer.observe)\n\
    \        logger.info(\"Simulation reset\")\n\n    @property\n    def speedup(self) ->\
    \ int:\n        \"\"\"Aktueller Beschleunigungsfaktor.\"\"\"\n        return self.__speedup\n\
    \n    @property\n    def is_running(self) -> bool:\n        \"\"\"Gibt an, ob die Simulation\
    \ noch aktiv läuft.\"\"\"\n        return self.__running\n\n    @property\n    def state(self)\
    \ -> StateProxy:\n        \"\"\"\n        Legacy-kompatibler Proxy: erlaubt `sim.state.x\
    \ = ...` bei frozen UfoState.\n\n        Lesezugriffe geben Werte aus einem Snapshot zurück,\
    \ Schreibzugriffe werden\n        an den StateManager delegiert und erzeugen einen neuen\
    \ UfoState via\n        dataclass_replace.\n        \"\"\"\n        return StateProxy(self._state_manager)\n\
    \n    def get_phase(self) -> Phase:\n        \"\"\"\n        Gibt die aktuelle Flugphase\
    \ threadsicher zurück.\n\n        Returns:\n            Aktuelle Phase als Literal-String\n\
    \        \"\"\"\n        snap = self.get_state_snapshot()\n        return compute_phase(snap,\
    \ self.config)\n\n    def get_maneuver_analysis(self) -> ManeuverAnalysis:\n        \"\
    \"\"\n        Gibt eine vollständige Manöver-Analyse zurück.\n\n        Returns:\n   \
    \         ManeuverAnalysis mit Phase und Bewegungs-Flags\n        \"\"\"\n        return\
    \ self.observer.analyze()\n\n    def get_maneuver_description(self) -> str:\n        \"\
    \"\"\n        Gibt eine lesbare Beschreibung des aktuellen Manövers zurück.\n\n      \
    \  Returns:\n            String-Beschreibung des Manövers\n        \"\"\"\n        return\
    \ self.observer.get_maneuver_description()\n\n    def get_destinations(self) -> List[Tuple[float,\
    \ float]]:\n        \"\"\"\n        Gibt die Liste der Zielkoordinaten zurück.\n\n   \
    \     Returns:\n            Liste von (x, y) Tupeln in Metern\n        \"\"\"\n      \
    \  return self.__destinations\n\n    def wait_for_condition(\n            self,\n    \
    \        condition: Callable[[UfoState], bool],\n            timeout: Optional[float]\
    \ = None\n    ) -> bool:\n        \"\"\"\n        Wartet bis eine Bedingung erfüllt ist,\
    \ ohne busy-waiting.\n\n        Args:\n            condition: Callable das den State prüft\
    \ und bool zurückgibt\n            timeout: Optional - Maximale Wartezeit in Sekunden\
    \ (None = unbegrenzt)\n\n        Returns:\n            True wenn Bedingung erfüllt, False\
    \ bei Timeout\n        \"\"\"\n        return self._state_manager.wait_for_condition(condition,\
    \ timeout)\n\n    @final\n    def create_command_queue(self) -> CommandQueue:\n      \
    \  \"\"\"\n        Erstellt eine neue Command Queue für deklarative Steuerung.\n\n   \
    \     Returns:\n            CommandQueue zum Definieren von Aktionen\n\n        Example:\n\
    \            >>> sim = UfoSim()\n            >>> queue = sim.create_command_queue()\n\
    \            >>> queue.wait_until(lambda s: s.z >= 10.0)\n        \"\"\"\n        return\
    \ CommandQueue()\n\n    def execute_command_queue(self, queue: CommandQueue) -> None:\n\
    \        \"\"\"\n        Führt Command Queue aus (setzt sie als aktive Queue).\n\n   \
    \     Args:\n            queue: CommandQueue mit definierten Aktionen\n        \"\"\"\n\
    \        self._command_executor.set_active_queue(queue)\n\n    @overload\n    def start(self)\
    \ -> None:\n        \"\"\"Startet die Simulation mit Default-Parametern.\"\"\"\n     \
    \   ...\n\n    @overload\n    def start(\n            self,\n            speedup: int,\n\
    \            *,\n            destinations: Optional[List[Tuple[float, float]]] = None,\n\
    \            show_view: bool = False,\n            enable_logging: bool = True,\n    \
    \        log_interval_s: float = 1.0,\n            log_every_step: bool = False,\n   \
    \         autopilot_callback: Optional[callable] = None,\n    ) -> None:\n        \"\"\
    \"Startet die Simulation mit angegebenem Speedup-Faktor.\"\"\"\n        ...\n\n    def\
    \ start(\n            self,\n            speedup: int = None,\n            *,\n      \
    \      destinations: Optional[List[Tuple[float, float]]] = None,\n            show_view:\
    \ bool = False,\n            enable_logging: bool = True,\n            log_interval_s:\
    \ float = 1.0,\n            log_every_step: bool = True,\n            autopilot_callback:\
    \ Optional[callable] = None,\n    ) -> None:\n        \"\"\"\n        Startet die Simulation.\n\
    \n        Args:\n            speedup: Faktor zur Beschleunigung der Simulation (1–25).\
    \ None = Default aus Config.\n            destinations: Liste von Zielkoordinaten (x,\
    \ y) in Metern. Standard: [(0.0, 0.0)]\n            show_view: False → Headless, True\
    \ → Visualisierung mit PyQt.\n            enable_logging: Aktiviert kontinuierliche Telemetrie-Ausgabe\
    \ auf stdout.\n            log_interval_s: Intervall für Logging-Ausgaben in Sekunden\
    \ (Echtzeit). Wird ignoriert wenn log_every_step=True.\n            log_every_step: Wenn\
    \ True, wird jeder Simulationsschritt geloggt (sehr detailliert).\n            autopilot_callback:\
    \ Optional - Funktion die mit (sim) aufgerufen wird im separaten Thread.\n        \"\"\
    \"\n        final_destinations = destinations if destinations is not None else [(0.0,\
    \ 0.0)]\n        final_speedup = speedup if speedup is not None else self.config.speedup_default\n\
    \n        if not (self.config.speedup_min <= final_speedup <= self.config.speedup_max):\n\
    \            logger.warning(\n                f\"speedup {final_speedup} outside valid\
    \ range [{self.config.speedup_min}, {self.config.speedup_max}], using default\")\n   \
    \         final_speedup = self.config.speedup_default\n\n        self.__speedup = final_speedup\n\
    \        self.__running = True\n        self.__logging_enabled = enable_logging\n    \
    \    self.__log_interval_s = log_interval_s\n        self.__log_every_step = log_every_step\n\
    \        self.__last_log_time = 0.0\n        self.__destinations = final_destinations\n\
    \n        logger.info(\n            f\"Starting simulation: speedup={self.__speedup},\
    \ destinations={len(final_destinations)}, show_view={show_view}, log_every_step={log_every_step}\"\
    )\n\n        # Wenn keine View, ist Thread nicht-daemon damit er nicht abgebrochen wird\n\
    \        sim_thread = threading.Thread(target=self.__run_sim, daemon=show_view)\n    \
    \    sim_thread.start()\n        self._sim_thread = sim_thread\n\n        if autopilot_callback\
    \ is not None:\n            self._autopilot_thread = threading.Thread(\n             \
    \   target=autopilot_callback,\n                args=(self,),\n                daemon=True\n\
    \            )\n            self._autopilot_thread.start()\n            logger.info(\"\
    Autopilot thread started\")\n\n        if show_view:\n            app = QtWidgets.QApplication.instance()\n\
    \            owns_app = app is None\n\n            if owns_app:\n                app =\
    \ QtWidgets.QApplication([])\n\n            self._view = UfoPView(self, destinations=final_destinations)\n\
    \n            if owns_app:\n                app.exec_()\n        else:\n            #\
    \ Headless mode: Warte bis Simulation fertig ist\n            sim_thread.join()\n\n  \
    \  def __run_sim(self) -> None:\n        \"\"\"\n        Führt die Simulationsberechnungen\
    \ in einer Endlosschleife aus.\n\n        Delegiert alle Berechnungen an PhysicsEngine\
    \ und StateManager.\n        \"\"\"\n        while self.__running:\n            # Physik-Step\
    \ ausführen über StateManager\n            def physics_update(state: UfoState) -> UfoState:\n\
    \                updated_state, should_continue, _ = self._physics_engine.integrate_step(state)\n\
    \                if not should_continue:\n                    self.__running = False\n\
    \                return updated_state\n\n            self._state_manager.update_state(physics_update)\n\
    \n            # Command Queue verarbeiten\n            current_snapshot = self._state_manager.get_snapshot()\n\
    \            self._command_executor.process_commands(current_snapshot)\n\n           \
    \ # Logging: entweder jeden Schritt oder zeitbasiert\n            if self.__logging_enabled:\n\
    \                if self.__log_every_step:\n                    print(self.format_flight_data())\n\
    \                else:\n                    current_time = time.time()\n             \
    \       if current_time - self.__last_log_time >= self.__log_interval_s:\n           \
    \             print(self.format_flight_data())\n                        self.__last_log_time\
    \ = current_time\n\n            time.sleep(self.config.dt / max(1, self.__speedup))\n\n\
    \    def terminate(self) -> None:\n        \"\"\"Beendet die Simulation.\"\"\"\n     \
    \   self.__running = False\n\n    def get_state_snapshot(self) -> UfoState:\n        \"\
    \"\"Gibt einen threadsicheren Schnappschuss des aktuellen Zustands zurück.\"\"\"\n   \
    \     return self._state_manager.get_snapshot()\n\n    def format_flight_data(self) ->\
    \ str:\n        \"\"\"\n        Formatierte Telemetrie für Logging-Ausgaben.\n\n     \
    \   Enthält Position, Geschwindigkeit, Phase und Manöver-Analyse.\n        Verwendet NumPy\
    \ für effiziente Beschleunigungsberechnung.\n\n        Returns:\n            Formatierter\
    \ String mit allen relevanten Flugdaten\n        \"\"\"\n        snap = self.get_state_snapshot()\n\
    \        analysis = self.observer.analyze()\n\n        # Berechne Gesamtbeschleunigung\
    \ mit NumPy (L2-Norm)\n        total_accel = np.linalg.norm(snap.acceleration_vector)\n\
    \n        # Manöver-Flags als kompakte Darstellung\n        flags = []\n        if analysis.is_ascending:\n\
    \            flags.append(\"↑\")\n        elif analysis.is_descending:\n            flags.append(\"\
    ↓\")\n        if analysis.is_turning:\n            flags.append(\"↻\")\n        if analysis.is_stagnating:\n\
    \            flags.append(\"⊗\")\n        flags_str = \"\".join(flags) if flags else \"\
    -\"\n\n        return (\n            f\"{snap.ftime:6.1f}s: \"\n            f\"pos=({snap.x:6.1f},\
    \ {snap.y:6.1f}, {snap.z:5.1f})m | \"\n            f\"v={snap.v:3.0f}km/h, d={snap.d:3.0f}°,\
    \ i={snap.i:4.0f}° | \"\n            f\"phase={analysis.phase:>8s} [{flags_str}] | \"\n\
    \            f\"dist={snap.dist:6.1f}m, vz={snap.vz:5.2f}m/s, a={total_accel:5.2f}m/s²\"\
    \n        )\n\n\n# =============================================================================\n\
    # VIEW MODEL - Entkopplung zwischen Simulation und Visualisierung\n# =============================================================================\n\
    \n@dataclass\nclass SimulationViewModel:\n    \"\"\"\n    View-Model (DTO) für Visualisierung.\n\
    \n    Entkoppelt View von direktem Zugriff auf Simulation.\n    Enthält nur Daten die\
    \ für Rendering benötigt werden.\n    \"\"\"\n    # State\n    position: Tuple[float,\
    \ float, float]  # (x, y, z) in m\n    velocity_kmh: float\n    direction_deg: float\n\
    \    inclination_deg: float\n    distance_m: float\n    flight_time_s: float\n\n    #\
    \ Analyse\n    phase: Phase\n    is_running: bool\n\n    @classmethod\n    def from_simulation(cls,\
    \ sim: UfoSim) -> 'SimulationViewModel':\n        \"\"\"\n        Erstellt ViewModel aus\
    \ Simulation.\n\n        Args:\n            sim: UfoSim Instanz\n\n        Returns:\n\
    \            SimulationViewModel mit aktuellen Daten\n        \"\"\"\n        snap = sim.get_state_snapshot()\n\
    \        phase = compute_phase(snap, sim.config)\n\n        return cls(\n            position=(snap.x,\
    \ snap.y, snap.z),\n            velocity_kmh=snap.v,\n            direction_deg=snap.d,\n\
    \            inclination_deg=snap.i,\n            distance_m=snap.dist,\n            flight_time_s=snap.ftime,\n\
    \            phase=phase,\n            is_running=sim.is_running\n        )\n\n\n# =============================================================================\n\
    # HUD HELPER - Reduziert Boilerplate\n# =============================================================================\n\
    \ndef create_circle_item(\n        color: str,\n        z_value: int,\n) -> QtWidgets.QGraphicsEllipseItem:\n\
    \    \"\"\"\n    Erstellt ein kreisförmiges Graphics-Item.\n\n    Args:\n        color:\
    \ Farbe als String (z.B. \"white\", \"blue\")\n        z_value: Z-Order für Rendering-Reihenfolge\n\
    \n    Returns:\n        Konfiguriertes QGraphicsEllipseItem (Größe muss vom Caller gesetzt\
    \ werden)\n    \"\"\"\n    item = QtWidgets.QGraphicsEllipseItem(0.0, 0.0, 0.0, 0.0)\n\
    \    item.setBrush(QtGui.QBrush(QtGui.QColor(color)))\n    item.setPen(QtGui.QPen(QtGui.QColor(color)))\n\
    \    item.setZValue(z_value)\n    return item\n\n\ndef create_text_item(color: str, z_value:\
    \ int) -> QtWidgets.QGraphicsSimpleTextItem:\n    \"\"\"\n    Erstellt ein Text-Graphics-Item.\n\
    \n    Args:\n        color: Textfarbe als String\n        z_value: Z-Order für Rendering-Reihenfolge\n\
    \n    Returns:\n        Konfiguriertes QGraphicsSimpleTextItem\n    \"\"\"\n    item =\
    \ QtWidgets.QGraphicsSimpleTextItem(\"\")\n    item.setBrush(QtGui.QBrush(QtGui.QColor(color)))\n\
    \    item.setZValue(z_value)\n    return item\n\n\n# =============================================================================\n\
    # VIEW - Effiziente Visualisierung mit QGraphicsScene\n# =============================================================================\n\
    \nclass UfoPView(QtWidgets.QGraphicsView):\n    \"\"\"\n    PyQt5-basierte Ansicht für\
    \ die UFO-Simulation mit QGraphicsScene.\n\n    Features:\n        - Effiziente Darstellung\
    \ mit Pixmap-Items\n        - ViewModel für Datenabstraktion\n        - Feste Fenstergröße,\
    \ dynamische Kartenskalierung\n        - Crash-Bild bei Absturz\n        - Automatischer\
    \ Shutdown nach Landung/Crash\n    \"\"\"\n\n    def __init__(\n            self,\n  \
    \          simulation: UfoSim,\n            destinations: Optional[List[Tuple[float, float]]]\
    \ = None,\n    ) -> None:\n\n        super().__init__()\n\n        self.sim = simulation\n\
    \        self.config = simulation.config\n        self.destinations = destinations if\
    \ destinations is not None else []\n\n        self.viewport_model = UfoViewport(\n   \
    \         width=self.config.window_size,\n            height=self.config.window_size,\n\
    \            config=self.config,\n        )\n\n        self.scene = QtWidgets.QGraphicsScene(self)\n\
    \        self.setScene(self.scene)\n        self.setRenderHints(\n            QtGui.QPainter.Antialiasing\
    \ | QtGui.QPainter.SmoothPixmapTransform\n        )\n        self.setFixedSize(self.config.window_size,\
    \ self.config.window_size)\n        self.setSceneRect(0.0, 0.0, self.config.window_size,\
    \ self.config.window_size)\n        self.setWindowTitle(\"Drohnenflug Simulationsvisualisierung\
    \ - by Tom Werner\")\n\n        self.__package_dir = Path(__file__).parent\n\n       \
    \ icon_path = self.__package_dir / \"thi_icon_258.png\"\n        if icon_path.is_file():\n\
    \            self.setWindowIcon(QtGui.QIcon(str(icon_path)))\n\n        map_image = self._load_image(\"\
    resources/background_card.png\")\n        ufo_image = self._load_image(\"resources/ufo_icon.png\"\
    )\n        crash_image = self._load_image(\"resources/sim_crash.png\")\n\n        self.__map_pixmap\
    \ = QtGui.QPixmap.fromImage(map_image).scaled(\n            self.config.window_size,\n\
    \            self.config.window_size,\n            QtCore.Qt.AspectRatioMode.KeepAspectRatioByExpanding,\n\
    \            QtCore.Qt.TransformationMode.SmoothTransformation,\n        )\n        self.__ufo_pixmap\
    \ = QtGui.QPixmap.fromImage(ufo_image)\n        self.__crash_pixmap = QtGui.QPixmap.fromImage(crash_image).scaled(\n\
    \            self.config.window_size,\n            self.config.window_size,\n        \
    \    QtCore.Qt.AspectRatioMode.KeepAspectRatio,\n            QtCore.Qt.TransformationMode.SmoothTransformation,\n\
    \        )\n\n        points = [(0.0, 0.0)] + list(self.destinations)\n        self.viewport_model.configure_for_points(points)\n\
    \n        self._create_scene_items()\n\n        self._shutdown_scheduled = False\n   \
    \     self._closing = False\n        self._crash_displayed = False\n\n        self.show()\n\
    \n        self.update_timer = QtCore.QTimer(self)\n        self.update_timer.timeout.connect(self._update)\n\
    \        self.update_timer.start(self.config.update_interval_ms)\n\n        logger.info(f\"\
    View initialized: window_size={self.config.window_size}, scaling={self.viewport_model.scaling}\"\
    )\n\n    def _load_image(self, filename: str) -> QtGui.QImage:\n        \"\"\"Lädt ein\
    \ Bild aus dem aktuellen Verzeichnis.\"\"\"\n        image_path = self.__package_dir /\
    \ filename\n        image = QtGui.QImage(str(image_path))\n\n        if image.isNull():\n\
    \            raise FileNotFoundError(f\"Image not found: {filename}\")\n\n        return\
    \ image\n\n    def _create_scene_items(self) -> None:\n        \"\"\"Erstellt alle Scene-Items\
    \ EINMALIG.\"\"\"\n        self._background_item = QtWidgets.QGraphicsPixmapItem(self.__map_pixmap)\n\
    \        self._background_item.setZValue(-100)\n        self.scene.addItem(self._background_item)\n\
    \n        self._start_item = create_circle_item(\"white\", 0)\n        self.scene.addItem(self._start_item)\n\
    \n        self._dest_items: List[Tuple[QtWidgets.QGraphicsEllipseItem, QtWidgets.QGraphicsEllipseItem]]\
    \ = []\n        for _ in self.destinations:\n            outer = create_circle_item(\"\
    white\", 1)\n            self.scene.addItem(outer)\n\n            inner = create_circle_item(\"\
    black\", 2)\n            self.scene.addItem(inner)\n\n            self._dest_items.append((outer,\
    \ inner))\n\n        self._ufo_item = QtWidgets.QGraphicsPixmapItem(self.__ufo_pixmap)\n\
    \        self._ufo_item.setZValue(10)\n        self.scene.addItem(self._ufo_item)\n\n\
    \        self._ufo_dot_item = create_circle_item(\"blue\", 11)\n        self.scene.addItem(self._ufo_dot_item)\n\
    \n        info_labels = [\"status\", \"x\", \"y\", \"z\", \"v\", \"d\", \"i\", \"dist\"\
    , \"time\"]\n        self._info_items: List[QtWidgets.QGraphicsSimpleTextItem] = []\n\
    \        for _ in info_labels:\n            item = create_text_item(\"black\", 20)\n \
    \           self.scene.addItem(item)\n            self._info_items.append(item)\n\n  \
    \      self._scale_text_item = create_text_item(\"black\", 20)\n        self.scene.addItem(self._scale_text_item)\n\
    \n        self._scale_line_item = QtWidgets.QGraphicsLineItem()\n        self._scale_line_item.setPen(QtGui.QPen(QtGui.QColor(\"\
    black\")))\n        self._scale_line_item.setZValue(20)\n        self.scene.addItem(self._scale_line_item)\n\
    \n    def _update(self) -> None:\n        \"\"\"\n        Aktualisiert alle Items - verwendet\
    \ ViewModel statt direkten State-Zugriff.\n\n        Vorteile:\n        - Entkoppelt View\
    \ von Simulation-Internals\n        - Nur eine API-Abfrage pro Frame\n        - Klare\
    \ Datenstruktur\n        \"\"\"\n        if self._closing:\n            return\n\n   \
    \     # Hole ViewModel (einziger Zugriff auf Simulation!)\n        view_model = SimulationViewModel.from_simulation(self.sim)\n\
    \n        if view_model.phase == \"crashed\" and not self._crash_displayed:\n        \
    \    self._show_crash_screen()\n            return\n\n        # Render Start/Dest Marker\n\
    \        start_px, start_py = self.viewport_model.to_screen(0.0, 0.0)\n        r = self.config.hud_start_radius\n\
    \        self._start_item.setRect(start_px - r, start_py - r, 2 * r, 2 * r)\n\n      \
    \  outer_r = self.config.hud_dest_out_radius\n        inner_r = self.config.hud_dest_in_radius\n\
    \        for (dx, dy), (outer_item, inner_item) in zip(self.destinations, self._dest_items):\n\
    \            px, py = self.viewport_model.to_screen(dx, dy)\n            outer_item.setRect(px\
    \ - outer_r, py - outer_r, 2 * outer_r, 2 * outer_r)\n            inner_item.setRect(px\
    \ - inner_r, py - inner_r, 2 * inner_r, 2 * inner_r)\n\n        # Render UFO\n       \
    \ x, y, z = view_model.position\n        ux, uy = self.viewport_model.to_screen(x, y)\n\
    \        ufo_w = self.__ufo_pixmap.width()\n        ufo_h = self.__ufo_pixmap.height()\n\
    \        self._ufo_item.setPos(ux - ufo_w / 2.0, uy - ufo_h / 2.0)\n\n        dot_r =\
    \ self.config.hud_ufo_dot_radius\n        self._ufo_dot_item.setRect(ux - dot_r, uy -\
    \ dot_r, 2 * dot_r, 2 * dot_r)\n\n        # Render HUD Text\n        info_lines = [\n\
    \            f\"ufo:  {view_model.phase:>8s}\",\n            f\"x:    {x:6.1f} m   \"\
    ,\n            f\"y:    {y:6.1f} m   \",\n            f\"z:    {z:6.1f} m   \",\n    \
    \        f\"v:     {view_model.velocity_kmh:3.0f}   km/h\",\n            f\"d:     {view_model.direction_deg:3.0f}\
    \   deg \",\n            f\"i:     {view_model.inclination_deg:3.0f}   deg \",\n     \
    \       f\"dist: {view_model.distance_m:6.1f} m   \",\n            f\"time: {view_model.flight_time_s:6.1f}\
    \ s   \",\n        ]\n\n        for line, item in zip(info_lines, self._info_items):\n\
    \            item.setText(line)\n\n        margin = self.config.hud_text_margin\n    \
    \    y_base = self.config.window_size - margin\n\n        for idx_rev, item in enumerate(reversed(self._info_items)):\n\
    \            rect = item.boundingRect()\n            x_pos = self.config.window_size -\
    \ margin - rect.width()\n            y_pos = y_base - idx_rev * self.config.hud_text_line_height\
    \ - rect.height()\n            item.setPos(x_pos, y_pos)\n\n        # Render Scale\n \
    \       scale_text = f\"{int(self.config.hud_scale_length_m)} m\"\n        self._scale_text_item.setText(scale_text)\n\
    \        rect = self._scale_text_item.boundingRect()\n        text_x = margin\n      \
    \  text_y = self.config.window_size - margin - rect.height()\n        self._scale_text_item.setPos(text_x,\
    \ text_y)\n\n        line_y = self.config.window_size - margin - rect.height() - 2.0\n\
    \        line_x1 = margin\n        line_length_px = self.config.hud_scale_length_m * self.viewport_model.scaling\n\
    \        line_x2 = min(line_x1 + line_length_px, self.config.window_size - margin)\n \
    \       self._scale_line_item.setLine(line_x1, line_y, line_x2, line_y)\n\n        # Shutdown\
    \ nach Ende\n        if not view_model.is_running and not self._shutdown_scheduled and\
    \ not self._crash_displayed:\n            self._shutdown_scheduled = True\n          \
    \  self.update_timer.stop()\n            QtCore.QTimer.singleShot(self.config.shutdown_delay_ms,\
    \ self._shutdown_after_sim)\n\n    def _show_crash_screen(self) -> None:\n        \"\"\
    \"Zeigt das Crash-Bild an und plant automatisches Shutdown.\"\"\"\n        self._crash_displayed\
    \ = True\n        self.update_timer.stop()\n\n        self.scene.clear()\n\n        crash_item\
    \ = QtWidgets.QGraphicsPixmapItem(self.__crash_pixmap)\n        crash_item.setZValue(1000)\n\
    \n        x_offset = (self.config.window_size - self.__crash_pixmap.width()) / 2.0\n \
    \       y_offset = (self.config.window_size - self.__crash_pixmap.height()) / 2.0\n  \
    \      crash_item.setPos(x_offset, y_offset)\n\n        self.scene.addItem(crash_item)\n\
    \n        logger.warning(\"Crash screen displayed\")\n        QtCore.QTimer.singleShot(self.config.crash_display_duration_ms,\
    \ self._shutdown_after_sim)\n\n    def _shutdown_after_sim(self) -> None:\n        \"\"\
    \"Schließt die View nach Simulationsende.\"\"\"\n        self.close()\n\n    def closeEvent(self,\
    \ event: QtGui.QCloseEvent) -> None:\n        \"\"\"Behandelt das Schließen des Fensters.\"\
    \"\"\n        self._closing = True\n\n        if hasattr(self, \"update_timer\") and self.update_timer.isActive():\n\
    \            self.update_timer.stop()\n            try:\n                self.update_timer.timeout.disconnect(self._update)\n\
    \            except (RuntimeError, TypeError):\n                pass\n\n        self.sim.terminate()\n\
    \        event.accept()\n\n\nclass StateProxy:\n    \"\"\"Legacy-kompatibler Proxy: erlaubt\
    \ `sim.state.x = ...` bei frozen UfoState.\n\n    Lesezugriffe geben Werte aus einem Snapshot\
    \ zurück, Schreibzugriffe werden\n    an den StateManager delegiert und erzeugen einen\
    \ neuen UfoState via\n    dataclass_replace.\n    \"\"\"\n\n    def __init__(self, manager:\
    \ 'StateManager') -> None:\n        object.__setattr__(self, \"_manager\", manager)\n\n\
    \    def __getattr__(self, name: str):\n        snap = self._manager.get_snapshot()\n\
    \        if hasattr(snap, name):\n            return getattr(snap, name)\n        raise\
    \ AttributeError(name)\n\n    def __setattr__(self, name: str, value) -> None:\n     \
    \   def updater(state: UfoState) -> UfoState:\n            try:\n                return\
    \ dataclass_replace(state, **{name: value})\n            except (AttributeError, TypeError):\
    \  # noqa: BLE001 - Breiter Catch bewusst: AttributeError oder TypeError möglich\n   \
    \             return state\n\n        self._manager.update_state(updater)\n\n    def __repr__(self)\
    \ -> str:  # pragma: no cover - convenience\n        snap = self._manager.get_snapshot()\n\
    \        return f\"StateProxy({snap})\"\n\n\n__all__ = [\n    # Simulation (Hauptklasse)\n\
    \    \"UfoSim\",\n\n    # Config\n    \"SimulationConfig\",\n    \"DEFAULT_CONFIG\",\n\
    \n    # State & Phase\n    \"UfoState\",\n    \"Phase\",\n\n    # Manöver-Analyse (für\
    \ Autopilot)\n    \"ManeuverAnalysis\",\n]\n\n"
  - rel_path: src/core/simulation/utils/__init__.py
    hash: 8b6093c0a8c04528c7c0ddea87f9f29c2413228ffb4009b4cfe26d740d15ef07
    content: |+
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """
      Generische Utility-Funktionen.
      
      Stellt wiederverwendbare Hilfsfunktionen ohne Simulationsabhängigkeiten bereit.
      Reine Funktionen ohne Zustand oder Seiteneffekte.
      
      Komponenten:
          - maths: Trigonometrie, Winkel-Normalisierung, Wertebegrenzung
          - validation: Wertebereichs-Validierung
          - geometry: 3D-Koordinatentransformationen (kartesisch ↔ sphärisch)
          - condition_waiter: Event-basiertes Warten auf Bedingungen
      
      Hinweis:
          Thread-Synchronisation (synchronized, etc.) ist nach synchronization/ verschoben.
          Nutze: from core.simulation.synchronization import synchronized
      """
      
      from .condition_waiter import ConditionWaiter
      from .geometry import cartesian_to_spherical, spherical_to_cartesian
      from .maths import clamp, deg_to_rad, rad_to_deg, wrap_angle_deg, wrap_angle_rad
      from .validation import is_in_range, validate_range
      
      __all__ = [
          # maths
          "deg_to_rad",
          "rad_to_deg",
          "wrap_angle_deg",
          "wrap_angle_rad",
          "clamp",
          # validation
          "validate_range",
          "is_in_range",
          # geometry
          "cartesian_to_spherical",
          "spherical_to_cartesian",
          # condition waiting
          "ConditionWaiter",
      ]

  - rel_path: src/core/simulation/utils/condition_waiter.py
    hash: c807f8ef4deea3d43c7c82dd328e901cf46a6a44fde2e7ef18a598a2c8a788a0
    content: |+
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """Zentrale Utility für Condition-basiertes Warten ohne Busy-Waiting."""
      
      from __future__ import annotations
      
      import threading
      import time
      from typing import Callable, Optional, TypeVar
      
      T = TypeVar('T')
      
      
      class ConditionWaiter:
          """
          Utility für event-basiertes Warten auf Bedingungen.
      
          Stateless: Nur statische Methoden. Thread-sicher mit Condition Variables.
          """
      
          @staticmethod
          def wait_for_condition(
              condition_var: threading.Condition,
              predicate: Callable[[T], bool],
              state_getter: Callable[[], T],
              timeout: Optional[float] = None
          ) -> bool:
              """
              Wartet event-basiert bis Prädikat erfüllt ist (kein Busy-Waiting).
      
              Returns:
                  True wenn Prädikat erfüllt, False bei Timeout
              """
              with condition_var:
                  end_time = None if timeout is None else time.time() + timeout
      
                  while True:
                      # Prädikat prüfen (state_getter wird unter Lock aufgerufen)
                      current_state = state_getter()
                      if predicate(current_state):
                          return True
      
                      # Timeout-Handling
                      if end_time is not None:
                          remaining = end_time - time.time()
                          if remaining <= 0:
                              # Timeout abgelaufen
                              return False
                          wait_timeout = remaining
                      else:
                          # Unbegrenztes Warten
                          wait_timeout = None
      
                      # Warten auf Notification (gibt Lock temporär frei)
                      condition_var.wait(timeout=wait_timeout)

  - rel_path: src/core/simulation/utils/geometry.py
    hash: 4ba6962fc396f53935a74a616b71f940b69079c9677aa6fce70ac2cd0e7195ab
    content: |+
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """Geometrische Transformationsfunktionen für 3D-Koordinaten."""
      
      from __future__ import annotations
      
      import math
      
      EPSILON_NEAR_ORIGIN = 1e-10
      
      
      def cartesian_to_spherical(x: float, y: float, z: float) -> tuple[float, float, float]:
          """
          Konvertiert kartesische zu sphärischen Koordinaten (r, theta, phi).
      
          - r: Radius (Abstand vom Ursprung)
          - theta: Polarwinkel von z-Achse [0, π]
          - phi: Azimutwinkel von x-Achse [-π, π]
          """
          r = math.sqrt(x * x + y * y + z * z)
      
          if r < EPSILON_NEAR_ORIGIN:
              return 0.0, 0.0, 0.0
      
          theta = math.acos(z / r)
          phi = math.atan2(y, x)
      
          return r, theta, phi
      
      
      def spherical_to_cartesian(r: float, theta: float, phi: float) -> tuple[float, float, float]:
          """
          Konvertiert sphärische zu kartesischen Koordinaten (x, y, z).
      
          - r: Radius
          - theta: Polarwinkel in Radiant
          - phi: Azimutwinkel in Radiant
          """
          sin_theta = math.sin(theta)
          cos_theta = math.cos(theta)
          sin_phi = math.sin(phi)
          cos_phi = math.cos(phi)
      
          x = r * sin_theta * cos_phi
          y = r * sin_theta * sin_phi
          z = r * cos_theta
      
          return x, y, z


  - rel_path: src/core/simulation/utils/maths.py
    hash: 1a4ec38ceabd078158792203f3717b8b123da840068e262e4b2014996b0d311c
    content: |+
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """Numerische Hilfsfunktionen für mathematische Operationen."""
      
      from __future__ import annotations
      
      import math
      
      
      def deg_to_rad(degrees: float) -> float:
          """Konvertiert Winkel von Grad zu Radiant."""
          return math.radians(degrees)
      
      
      def rad_to_deg(radians: float) -> float:
          """Konvertiert Winkel von Radiant zu Grad."""
          return math.degrees(radians)
      
      
      def wrap_angle_deg(angle: float, lower: float = -180.0, upper: float = 180.0) -> float:
          """
          Normalisiert Winkel in Grad auf periodischen Bereich [lower, upper).
      
          Standard: [-180°, 180°).
          """
          if lower >= upper:
              raise ValueError(f"lower ({lower}) must be strictly less than upper ({upper})")
      
          period = upper - lower
          normalized = (angle - lower) % period + lower
      
          return normalized
      
      
      def wrap_angle_rad(angle: float) -> float:
          """Normalisiert Winkel in Radiant auf [-π, π)."""
          period = 2 * math.pi
          normalized = (angle + math.pi) % period - math.pi
          return normalized
      
      
      def clamp(value: float, min_value: float, max_value: float) -> float:
          """Begrenzt Wert auf Bereich [min_value, max_value]."""
          if min_value > max_value:
              raise ValueError(f"min_value ({min_value}) must not be greater than max_value ({max_value})")
      
          return max(min_value, min(value, max_value))


  - rel_path: src/core/simulation/utils/threads.py
    hash: e39bd0db17f90db9117ef63a1118d0855107d2c41d9f096c7ea9bdc0a72dbf94
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """
      Thread-Synchronisation-Utilities für die UFO-Simulation.
      
      DEPRECATED: Dieses Modul existiert nur noch für Rückwärtskompatibilität.
      Nutze stattdessen direkt: from core.simulation.synchronization import synchronized
      
      Wird in einer zukünftigen Version entfernt.
      """
      
      from __future__ import annotations
      
      import warnings
      
      # Re-export synchronized decorator from synchronization package
      from ..synchronization import synchronized
      
      # Warnung beim Import ausgeben
      warnings.warn(
          "utils.threads ist deprecated. "
          "Nutze stattdessen: from core.simulation.synchronization import synchronized",
          DeprecationWarning,
          stacklevel=2,
      )
      
      __all__ = ['synchronized']
  - rel_path: src/core/simulation/utils/validation.py
    hash: 5e99f32b02e301cdaa7fcd95be251b6d75a4f66b6eca3f2a7cbb0e5f890d9d08
    content: |+
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """Validierungsfunktionen für Wertebereichs-Prüfungen."""
      
      from __future__ import annotations
      
      
      def validate_range(value: float, min_val: float, max_val: float, name: str) -> None:
          """Validiert, ob ein Wert innerhalb eines definierten Wertebereichs liegt.
      
          Liegt der übergebene Wert außerhalb des Intervalls
          ``[min_val, max_val]``, wird ein ``ValueError`` mit einer
          sprechenden Fehlermeldung ausgelöst.
      
          Args:
              value: Zu prüfender numerischer Wert.
              min_val: Untere (inklusive) Grenze des gültigen Wertebereichs.
              max_val: Obere (inklusive) Grenze des gültigen Wertebereichs.
              name: Parametername oder Bezeichner, der in der Fehlermeldung
                  verwendet wird.
      
          Raises:
              ValueError: Wenn ``value`` kleiner als ``min_val`` oder größer
                  als ``max_val`` ist.
          """
          if value < min_val or value > max_val:
              raise ValueError(
                  f"{name} muss zwischen {min_val} und {max_val} liegen, ist aber {value}"
              )
      
      
      def is_in_range(value: float, min_val: float, max_val: float) -> bool:
          """Prüft, ob ein Wert innerhalb eines geschlossenen Wertebereichs liegt.
      
          Args:
              value: Zu prüfender numerischer Wert.
              min_val: Untere (inklusive) Grenze des gültigen Wertebereichs.
              max_val: Obere (inklusive) Grenze des gültigen Wertebereichs.
      
          Returns:
              True, wenn ``value`` innerhalb des Intervalls
              ``[min_val, max_val]`` liegt, sonst False.
          """
          return min_val <= value <= max_val


  - rel_path: src/task/__init__.py
    hash: 5145743da839b8c5a48a6a0bccdc7966c53803c7f7d70b1d81391f48359374ce
    content: |-
      """
      Aufgabenpaket für die UFO-Simulation-Schulung.
      
      Enthält einzelne Aufgabenmodule (z. B. Winkelaufgaben, Autopilot),
      die auf den Kernmodulen unter core.* aufbauen.
      """
      
      from . import angle, autopilot
      
      __all__ = ["angle", "autopilot"]
  - rel_path: src/task/angle/__init__.py
    hash: b2603ceea75fbfd0a1677542bcb61a334d62f8fba27cb23457d02d3de148e064
    content: |-
      """
      Winkel-/Geometrieaufgaben für die UFO-Simulation-Schulung.
      
      Die eigentliche Implementierung folgt in angle.py.
      """
      
      __all__: list[str] = []
  - rel_path: src/task/angle/angle.py
    hash: 89363265cf2e3d6666159c4bed937d8a356ac44a610be92e7406ed28e4339eba
    content: |
      """
      🎓 PRAKTIKUMSAUFGABE 1 – WINKELBERECHNUNG
      
      AUFGABENBESCHREIBUNG:
      → docs/description/tasks/aufgabe-1-winkelberechnung.md
      
      Deine Aufgabe:
      Berechne den Winkel φ (Phi) zwischen zwei Punkten (x1,y1) und (x2,y2)
      NUR mit Grundrechenarten und math.sqrt - OHNE trigonometrische Funktionen!
      
      Kern-Vorgaben:
      - Variablennamen: klein_mit_unterstrich (keine Umlaute/ß)
      - Eingabe: x1, y1, x2, y2 mit Validierung (x2 ≥ x1 und y2 ≥ y1)
      - Berechnung: Taylor-Reihe für arctan ODER arccos
      - Abbruch: |letzter Summand| < 0.000001
      - Schleifen: Maximal 2 (Input-Validierung + Taylor-Berechnung)
      - Keine Funktionsdefinitionen erlaubt!
      
      Lies die vollständige Aufgabenbeschreibung bevor du beginnst!
      """
      
      # ============================================================================
      # 🔧 FUNKTIONS-VORLAGE FÜR AUFGABE 2
      # ============================================================================
      # ⚠️ FÜR AUFGABE 1: Lass diesen Block auskommentiert!
      #
      # ✅ FÜR AUFGABE 2: Entferne die Kommentarzeichen (#) und implementiere
      #                   die Funktion mit deinem Code von unten!
      #
      # Diese Funktion wird in Aufgabe 2 (UFO-Autopilot) benötigt.
      # Du kopierst deinen Code aus den Schritten 2-5 in diese Funktion.
      # ============================================================================
      
      # def angle_q1(x1: float, y1: float, x2: float, y2: float) -> float:
      #     """
      #     Berechne Winkel zwischen zwei Punkten (nur 1. Quadrant: 0° bis 90°).
      #
      #     Parameter:
      #         x1, y1: Startpunkt
      #         x2, y2: Zielpunkt (mit x2 >= x1 und y2 >= y1)
      #
      #     Rückgabe:
      #         Winkel in Grad (0° bis 90°)
      #     """
      #     # ← HIER KOMMT DEIN CODE AUS SCHRITT 2-5 (ohne input/print)
      #
      #     return ergebnis_grad
      
      # ============================================================================
      # AUFGABENBEREICH FÜR AUFGABE 1 - IMPLEMENTIERE HIER DEIN SKRIPT
      # ============================================================================
      
      # 📌 SCHRITT 1: EINGABE UND VALIDIERUNG
      # ============================================================================
      # Ziel:
      #   Lese x1, y1, x2, y2 von der Konsole ein und validiere die Eingabe
      #
      # Anforderungen:
      #   - x2 muss ≥ x1 sein
      #   - y2 muss ≥ y1 sein
      #   - Bei ungültiger Eingabe: Wiederhole die Eingabe
      #
      # Erlaubte Schleife: Eine Input-Validierungs-Schleife
      #
      # Hinweise:
      #   - input() und float() sind deine Freunde
      #   - Eine while-Schleife kann sich wiederholen bis eine Bedingung erfüllt ist
      #   - Bei Fehler: Informiere den Benutzer was falsch war
      #
      # ⚠️ Schau in die Aufgabenbeschreibung wenn du nicht weiter kommst!
      # ============================================================================
      
      pass  # ← HIER DEIN CODE FÜR EINGABE UND VALIDIERUNG!
      
      # 📌 SCHRITT 2: BERECHNUNG DER SEITENLÄNGEN
      # ============================================================================
      # Ziel:
      #   Berechne die Katheten und Hypotenuse des rechtwinkligen Dreiecks
      #
      # Gegeben:
      #   - Punkt 1: (x1, y1)
      #   - Punkt 2: (x2, y2)
      #
      # Gesucht:
      #   - Ankathete (delta_x)
      #   - Gegenkathete (delta_y)
      #   - Hypotenuse (mit Satz des Pythagoras)
      #
      # Erlaubt: Grundrechenarten + math.sqrt()
      #
      # Hinweise:
      #   - Delta bedeutet "Differenz"
      #   - Pythagoras: c² = a² + b²
      #   - math.sqrt() berechnet die Wurzel
      # ============================================================================
      
      pass  # ← HIER DEIN CODE FÜR SEITENLÄNGEN-BERECHNUNG!
      
      # 📌 SCHRITT 3: WAHL DER METHODE (arctan ODER arccos)
      # ============================================================================
      # Du hast zwei Möglichkeiten den Winkel zu berechnen:
      #
      # METHODE A: arctan (Arkustangens)
      #   Formel: φ = arctan(delta_y / delta_x)
      #   Vorteil: Einfacher für Winkel nahe 0° oder 90°
      #   Taylor-Reihe: arctan(z) = z - z³/3 + z⁵/5 - z⁷/7 + ...
      #   Konvergiert für: -1 < z < 1
      #
      # METHODE B: arccos (Arkuskosinus)
      #   Formel: φ = arccos(delta_x / c)
      #   Vorteil: Direkter geometrisch
      #   Taylor-Reihe: arccos(z) = π/2 - arcsin(z)
      #                 arcsin(z) = z + (1/2)(z³/3) + (1·3)/(2·4)(z⁵/5) + ...
      #   Konvergiert für: -1 ≤ z ≤ 1
      #
      # 💡 EMPFEHLUNG: Wähle arctan - ist einfacher zu implementieren!
      #
      # Sonderfall beachten:
      #   - Wenn delta_x = 0: Winkel = 90° (senkrecht)
      #   - Wenn delta_y = 0: Winkel = 0° (waagerecht)
      # ============================================================================
      
      pass  # ← HIER DEIN CODE FÜR DIE GEWÄHLTE METHODE (ARCTAN ODER ARCCOS)
      
      # 📌 SCHRITT 4: TAYLOR-REIHE IMPLEMENTIEREN
      # ============================================================================
      # Ziel:
      #   Berechne arctan(z) oder arccos(z) mit Taylor-Reihe
      #
      # Anforderungen:
      #   - Summiere Terme bis |letzter Summand| < 0.000001
      #   - Nutze EINE Schleife für die Berechnung
      #   - Keine Funktionsdefinitionen!
      #
      # TAYLOR-REIHE FÜR arctan(z):
      # ---------------------------
      # arctan(z) = z - z³/3 + z⁵/5 - z⁷/7 + z⁹/9 - ...
      #
      # Allgemeine Form des n-ten Summanden:
      #   summand_n = (-1)ⁿ · z^(2n+1) / (2n+1)
      #
      # WICHTIGE FRAGEN ZUM NACHDENKEN:
      #   1. Was ist z? (Verhältnis welcher Seiten?)
      #   2. Wie berechnest du den ersten Summand?
      #   3. Wie kommst du vom Summand n zum Summand n+1?
      #      → Tipp: summand_(n+1) = summand_n · Faktor
      #      → Welcher Faktor?
      #   4. Wann stoppt die Schleife?
      #   5. Was machst du mit den Summanden?
      #
      # Hinweise:
      #   - abs() liefert den Betrag
      #   - Initialisiere Variablen VOR der Schleife
      #   - Das Ergebnis ist in RADIANT (Bogenmaß)!
      #   - Für Umrechnung: Grad = Radiant · 180 / π
      #
      # ⚠️ ACHTUNG Sonderfall:
      #   Was passiert wenn delta_x = 0? (Division durch 0!)
      #   Behandle diesen Fall separat!
      # ============================================================================
      
      pass  # ← HIER DEIN CODE FÜR TAYLOR-REIHE!
      
      # 📌 SCHRITT 5: UMRECHNUNG UND AUSGABE
      # ============================================================================
      # Ziel:
      #   Rechne Radiant in Grad um und gib das Ergebnis aus
      #
      # Formel:
      #   grad = radiant · 180 / π
      #
      # Hinweise:
      #   - π ≈ 3.141592653589793 (hardcode diesen Wert!)
      #   - Alternativ: Berechne π selbst mit einer Reihe (fortgeschritten)
      #   - Runde das Ergebnis auf 6 Nachkommastellen
      #   - Gib das Ergebnis mit print() aus
      #
      # ============================================================================
      
      pass  # ← HIER DEIN CODE FÜR UMRECHNUNG UND AUSGABE!
      
      # ============================================================================
      # 📊 TESTFÄLLE ZUM ÜBERPRÜFEN
      # ============================================================================
      #
      # Teste dein Programm mit diesen Eingaben:
      #
      # Test 1: Waagerecht (0°)
      #   x1=0, y1=0, x2=10, y2=0
      #   Erwartetes Ergebnis: 0°
      #
      # Test 2: Kleine Steigung (~18.43°)
      #   x1=0, y1=0, x2=3, y2=1
      #   Erwartetes Ergebnis: ≈ 18.434949°
      #
      # Test 3: 45°-Winkel
      #   x1=0, y1=0, x2=5, y2=5
      #   Erwartetes Ergebnis: 45°
      #
      # Test 4: Steile Steigung (~71.57°)
      #   x1=0, y1=0, x2=1, y2=3
      #   Erwartetes Ergebnis: ≈ 71.565051°
      #
      # Test 5: Senkrecht (90°)
      #   x1=0, y1=0, x2=0, y2=10
      #   Erwartetes Ergebnis: 90°
      #
      # ⚠️ Alle Tests müssen auf 6 Nachkommastellen genau sein!
      #
      # ============================================================================
      
      
      # ============================================================================
      # 💡 HILFREICHE HINWEISE
      # ============================================================================
      #
      # 1. DEBUGGING:
      #    - Gib Zwischenergebnisse aus: print(f"delta_x={delta_x}")
      #    - Prüfe jeden Summand: print(f"n={n}, summand={summand}")
      #    - Nutze diese Ausgaben zum Verstehen was dein Code macht!
      #
      # 2. HÄUFIGE FEHLER:
      #    - Division durch 0: Sonderfall delta_x=0 nicht behandelt
      #    - Falsche Reihenfolge im Bruch bei der Faktor-Berechnung
      #    - Vergessen das Vorzeichen zu wechseln (alternierend!)
      #    - Ergebnis nicht von Radiant in Grad umgerechnet
      #
      # 3. WENN DU NICHT WEITERKOMMST:
      #    - Lies die Aufgabenbeschreibung nochmal durch
      #    - Schau dir die mathematischen Formeln genau an
      #    - Frage deinen Nachbarn oder den Lehrer
      #    - Probiere verschiedene Testfälle aus
      #
      # ============================================================================
      
      # ⚠️ WICHTIG: Lösche diese Kommentare NICHT - sie helfen beim Lernen!
      
      # ============================================================================
      # 🔄 FÜR AUFGABE 2: VON SKRIPT ZU FUNKTION UMWANDELN
      # ============================================================================
      #
      # Wenn du mit Aufgabe 1 fertig bist und zur Aufgabe 2 übergehst:
      #
      # SCHRITT 1: Gehe nach oben zur "FUNKTIONS-VORLAGE FÜR AUFGABE 2"
      # SCHRITT 2: Entferne dort die Kommentarzeichen (#)
      # SCHRITT 3: Kopiere deinen Code aus Schritt 2-5 in die Funktion
      # SCHRITT 4: Entferne input()-Anweisungen (Parameter ersetzen diese)
      # SCHRITT 5: Ersetze print() mit return
      #
      # BEISPIEL DER UMWANDLUNG:
      # ------------------------
      # VORHER (Aufgabe 1 - Skript):
      #   x1 = float(input("x1: "))      ← Wird zu Parameter
      #   ...
      #   delta_x = x2 - x1              ← Bleibt gleich
      #   ...
      #   print(ergebnis_grad)           ← Wird zu return
      #
      # NACHHER (Aufgabe 2 - Funktion):
      #   def angle_q1(x1, y1, x2, y2):  ← Parameter statt input()
      #       delta_x = x2 - x1          ← Code bleibt gleich
      #       ...
      #       return ergebnis_grad       ← return statt print()
      #
      # ℹ️ WIESO? : Ein sogenanntes return-statement gibt das ergebnis der Funktion
      #             zurück an den Aufrufer (statt es direkt auszugeben).
      #             So kann die Funktion in anderen Programmen (wie dem UFO-Autopilot)
      #             verwendet werden.
      #
      # ⚠️ NOCHMAL: Für Aufgabe 1 brauchst du das NICHT!
      #             Implementiere jetzt erst dein funktionierendes Skript.
      #             Diese Umwandlung machst du erst in Aufgabe 2.
      #
      # ============================================================================
  - rel_path: src/task/autopilot/__init__.py
    hash: 8db67d5fe394d2315a2d82bb77faf0be3d0268cbf72ec435ad12eb98d90baddc
    content: |-
      """
      Autopilot-Aufgabe der UFO-Simulation-Schulung.
      
      Stellt die Autopilot-Vorlage bereit, die von den Lernenden implementiert wird.
      """
      
      from .autopilot import Autopilot
      
      __all__ = ["Autopilot"]
  - rel_path: src/task/autopilot/autopilot.py
    hash: 313fa26ac92199596ce58147d8de78e75d0deef75677d7de5f0c3099454233de
    content: |-
      """
      🎓 PRAKTIKUMSAUFGABE 2 – UFO-AUTOPILOT
      
      AUFGABENBESCHREIBUNG:
      → docs/description/tasks/aufgabe-2-ufo-autopilot.md
      
      Deine Aufgaben:
      1. Implementiere die drei Flugphasen: takeoff(), cruise(), landing()
      2. Setze USE_DEMO = False wenn deine Implementierung fertig ist
      3. Starte die Simulation und teste deinen Autopiloten
      
      Hinweis:
      Diese Datei ist Teil der größeren Aufgabe 2. Für die vollständige
      Aufgabenstellung (inkl. ufo_autopilot.py mit Hilfsfunktionen) lies
      bitte die Aufgabenbeschreibung!
      
      NICHT ändern:
      - Die Struktur dieser Klasse
      - Die Imports
      - Alles außer den 3 Funktionen
      """
      from __future__ import annotations
      
      from typing import TYPE_CHECKING
      
      from core.simulation.autopilot_base import AutopilotBase
      
      if TYPE_CHECKING:
          from core.simulation.ufosim import UfoSim
      
      
      # ============================================================================
      # 📥 IMPORT FÜR WINKELBERECHNUNG AUS AUFGABE 1
      # ============================================================================
      # ⚠️ WICHTIG: Entferne die Kommentarzeichen (#) erst NACHDEM du in
      #            angle.py die Funktion angle_q1() implementiert hast!
      #
      # VORAUSSETZUNG:
      #   1. Du hast Aufgabe 1 abgeschlossen (angle.py funktioniert)
      #   2. Du hast in angle.py die Funktion angle_q1() implementiert
      #      (siehe "FUNKTIONS-VORLAGE FÜR AUFGABE 2" in angle.py)
      #   3. Du hast die Kommentarzeichen dort entfernt
      #
      # DANN HIER:
      #   Entferne die # vor "from task.angle.angle import angle_q1"
      #
      # VERWENDUNG IN cruise():
      #   winkel = angle_q1(sim.state.x, sim.state.y, target_x, target_y)
      #
      # ============================================================================
      
      # from task.angle.angle import angle_q1
      
      # ============================================================================
      
      class Autopilot(AutopilotBase):
          """
          Dein Autopilot zum selbst schreiben.
      
          Setze das Flag unten auf False wenn du fertig bist:
          """
      
          USE_DEMO = True  # ← Setze auf False wenn deine Implementierung fertig ist!
      
          # ========================================================================
          # AUFGABENBEREICH - IMPLEMENTIERE DIESE 3 FUNKTIONEN
          # ========================================================================
      
          def takeoff(self, sim: "UfoSim", target_alt: float) -> None:
              """
              ✍️ AUFGABE 1: Implementiere die Startphase
      
              Ziel:
                  Bringe das UFO von der aktuellen Höhe zur Zielflughöhe (target_alt)
      
              Verfügbare Steuerung:
                  - sim.state.delta_v: Geschwindigkeitsänderung (positiv = schneller)
                  - sim.state.i: Neigung in Grad (90=vertikal, 45=steil, 0=horizontal)
                  - sim.wait_for_condition(bedingung, timeout): Wartet bis Bedingung erfüllt
                  - sim.state.z: Aktuelle Höhe
      
              Fragen zum Nachdenken:
                  1. Wie erhöhe ich die Geschwindigkeit?
                  2. Welche Neigung brauche ich zum Steigen?
                  3. Wann habe ich die Zielflughöhe erreicht?
                  4. Wie warte ich bis die Bedingung erfüllt ist?
      
              ⚠️ Lies die Aufgabenbeschreibung für Details!
              """
              pass  # ← HIER DEIN CODE!
      
          def cruise(self, sim: "UfoSim", target_x: float, target_y: float) -> None:
              """
              ✍️ AUFGABE 2: Implementiere den Reiseflug
      
              Ziel:
                  Fliege von der aktuellen Position zum Ziel (target_x, target_y)
      
              Verfügbare Steuerung:
                  - sim.state.d: Richtung in Grad (0=Nord, 90=Ost, 180=Süd, 270=West)
                  - sim.state.i: Neigung in Grad (0=horizontal)
                  - sim.state.delta_v: Geschwindigkeitsänderung
                  - sim.state.x, sim.state.y: Aktuelle Position
      
              💡 VERWENDUNG DEINER angle_q1() FUNKTION:
                  Wenn du oben den Import entkommentiert hast, kannst du
                  deine Winkelberechnung aus Aufgabe 1 hier nutzen!
      
                  Beispiel:
                      winkel = angle_q1(sim.state.x, sim.state.y, target_x, target_y)
                      sim.state.d = winkel
      
                  ⚠️ ABER: angle_q1() funktioniert nur für den 1. Quadranten!
                           Für negative Koordinaten brauchst du eine Anpassung.
      
              Fragen zum Nachdenken:
                  1. Wie berechne ich die Differenz zum Ziel (dx, dy)?
                  2. Wie berechne ich den Winkel zum Ziel?
                     → Mit angle_q1() wenn du sie implementiert hast
                     → Oder mit math.atan2(dx, dy) als Alternative
                  3. Welche Neigung brauche ich für horizontalen Flug?
                  4. Wann bin ich nah genug am Ziel?
      
              Hinweis zu Winkeln:
                  - math.atan2(dx, dy) gibt Winkel in Radiant zurück
                  - math.degrees() rechnet in Grad um
                  - Negative Winkel müssen auf 0-360° umgerechnet werden
      
              ⚠️ Lies die Aufgabenbeschreibung für Details zur vollständigen Aufgabe!
              """
              pass  # ← HIER DEIN CODE!
      
          def landing(self, sim: "UfoSim") -> None:
              """
              ✍️ AUFGABE 3: Implementiere die Landephase
      
              Ziel:
                  Bringe das UFO sicher zum Boden (z <= 0.1)
      
              Verfügbare Steuerung:
                  - sim.state.delta_v: Geschwindigkeitsänderung (negativ = bremsen)
                  - sim.state.i: Neigung (negativ = abwärts)
                  - sim.state.v: Aktuelle Geschwindigkeit (lesen)
                  - sim.state.z: Aktuelle Höhe (lesen)
      
              Fragen zum Nachdenken:
                  1. Wie bremse ich das UFO ab?
                  2. Welche Neigung brauche ich für sanften Sinkflug?
                  3. Wann habe ich den Boden erreicht?
                  4. Was passiert bei zu schneller Landung?
      
              ⚠️ WARNUNG:
                  Zu hohe Geschwindigkeit oder zu steile Neigung → CRASH!
                  Teste mit kleinen Werten und beobachte was passiert!
      
              ⚠️ Lies die Aufgabenbeschreibung für Details!
              """
              pass  # ← HIER DEIN CODE!
  - rel_path: tests/_helpers.py
    hash: 3b21fe96c4421fc9f521a1d5809fbabaaa5008201e6957479dd6c51ad60ecc1c
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """Kleine Test-Helfer, damit Tests zuverlässig ohne `conftest`-Imports laufen.
      
      Enthält:
      - run_threaded_workers: startet mehrere Threads und wartet auf Abschluss
      - assert_race_condition_free: prüft auf Race-Conditions
      - create_decorated_counter: Hilfs-Factory für decorator-Tests
      - run_manual_tests: einfacher Runner für `if __name__ == '__main__'`
      """
      from __future__ import annotations
      
      import threading
      import time
      from typing import Callable, List, Dict, Any, Optional
      
      
      def run_threaded_workers(worker_func: Callable[[], None], num_threads: int = 10, timeout_per_thread: float = 10.0) -> List[threading.Thread]:
          """Führt eine Worker-Funktion in mehreren Threads aus und wartet auf Abschluss.
      
          Raises TimeoutError, wenn Threads nicht rechtzeitig fertig werden.
          """
          threads: List[threading.Thread] = []
          for _ in range(num_threads):
              t = threading.Thread(target=worker_func, daemon=False)
              threads.append(t)
              t.start()
      
          for t in threads:
              t.join(timeout=timeout_per_thread)
              if t.is_alive():
                  raise TimeoutError(f"Thread did not complete within {timeout_per_thread}s")
      
          return threads
      
      
      def assert_race_condition_free(
          increment_func: Callable[[], None],
          get_value_func: Callable[[], int],
          num_threads: int = 100,
          increments_per_thread: int = 100,
          timeout: float = 30.0,
      ) -> bool:
          """Helper: Erwartet num_threads*increments_per_thread am Ende.
      
          Wirft AssertionError bei Abweichung.
          """
          expected = num_threads * increments_per_thread
      
          def worker():
              for _ in range(increments_per_thread):
                  increment_func()
      
          run_threaded_workers(worker, num_threads=num_threads, timeout_per_thread=timeout)
      
          actual = get_value_func()
          assert actual == expected, f"Race-Condition detected: Expected {expected}, got {actual}"
          return True
      
      
      def create_decorated_counter(decorator: Callable, lock: Optional[threading.RLock] = None) -> Dict[str, Any]:
          """Erstellt increment/get_value/add mit Dekorator angewendet.
      
          Nützlich für tests von synchronized/synchronized_module.
          """
          data: Dict[str, int] = {"value": 0}
      
          if lock is not None:
              @decorator(lock)
              def increment():
                  old = data["value"]
                  time.sleep(0.0001)
                  data["value"] = old + 1
      
              @decorator(lock)
              def get_value():
                  return data["value"]
      
              @decorator(lock)
              def add(amount: int):
                  old = data["value"]
                  time.sleep(0.0001)
                  data["value"] = old + amount
                  return data["value"]
          else:
              @decorator
              def increment():
                  old = data["value"]
                  time.sleep(0.0001)
                  data["value"] = old + 1
      
              @decorator
              def get_value():
                  return data["value"]
      
              @decorator
              def add(amount: int):
                  old = data["value"]
                  time.sleep(0.0001)
                  data["value"] = old + amount
                  return data["value"]
      
          return {"increment": increment, "get_value": get_value, "add": add, "data": data}
      
      
      def run_manual_tests(module_name: str, tests: list[Callable[[], None]]) -> None:
          failures = 0
          for t in tests:
              try:
                  t()
                  print(f"OK: {t.__name__}")
              except Exception as e:
                  failures += 1
                  print(f"FAIL: {t.__name__}: {e}")
          if failures:
              raise SystemExit(1)
  - rel_path: tests/conftest.py
    hash: a5131cc4ecbc49527dde197d765defc34dfe131861b494f2f3b1cffa8a369c95
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """
      Gemeinsame Test-Fixtures und Hilfsfunktionen für alle Tests.
      
      Enthält wiederverwendbare Komponenten für:
      - Threading-Tests (Counter, Worker-Patterns)
      - Lock-Tests (Race-Condition-Detection)
      - Synchronization-Tests (Decorator-Testing)
      """
      
      from __future__ import annotations
      
      import threading
      import time
      from typing import Dict, Any, Union
      from pathlib import Path
      import sys
      
      import pytest
      
      # Make project root importable so `import tests._helpers` works in all contexts.
      repo_root = Path(__file__).resolve().parents[1]
      if str(repo_root) not in sys.path:
          sys.path.insert(0, str(repo_root))
      
      from tests._helpers import (
          run_threaded_workers,
          assert_race_condition_free,
          create_decorated_counter,
          run_manual_tests,
      )
      
      # Re-exports: sichtbar machen für statische Analyzer und externe Importe
      __all__ = [
          "run_threaded_workers",
          "assert_race_condition_free",
          "create_decorated_counter",
          "run_manual_tests",
      ]
      
      
      # =============================================================================
      # Threading Test Helpers
      # =============================================================================
      
      class ThreadSafeCounter:
          """
          Thread-sicherer Counter für Tests.
      
          Kann mit oder ohne Lock verwendet werden, um Race-Conditions zu testen.
          """
      
          def __init__(self, use_lock: bool = False):
              """
              Initialisiert den Counter.
      
              Args:
                  use_lock: Wenn True, wird ein RLock für Thread-Safety verwendet.
              """
              self._value = 0
              self._lock = threading.RLock() if use_lock else None
      
          def increment(self, delay: float = 0.0001):
              """
              Inkrementiert den Counter (mit optionaler Verzögerung für Race-Condition-Tests).
      
              Args:
                  delay: Verzögerung in Sekunden zwischen Read und Write (default: 0.0001).
              """
              if self._lock:
                  with self._lock:
                      old_value = self._value
                      if delay > 0:
                          time.sleep(delay)
                      self._value = old_value + 1
              else:
                  old_value = self._value
                  if delay > 0:
                      time.sleep(delay)
                  self._value = old_value + 1
      
          def add(self, amount: int, delay: float = 0.0001):
              """
              Addiert einen Betrag zum Counter.
      
              Args:
                  amount: Zu addierender Betrag.
                  delay: Verzögerung in Sekunden zwischen Read und Write.
      
              Returns:
                  Der neue Wert nach der Addition.
              """
              if self._lock:
                  with self._lock:
                      old_value = self._value
                      if delay > 0:
                          time.sleep(delay)
                      self._value = old_value + amount
                      return self._value
              else:
                  old_value = self._value
                  if delay > 0:
                      time.sleep(delay)
                  self._value = old_value + amount
                  return self._value
      
          def get_value(self):
              """Gibt den aktuellen Wert zurück."""
              if self._lock:
                  with self._lock:
                      return self._value
              else:
                  return self._value
      
          @property
          def value(self):
              """Property-Zugriff auf den Wert."""
              return self.get_value()
      
      
      # =============================================================================
      # Lock Test Helpers
      # =============================================================================
      
      class LockTestHelper:
          """
          Hilfsfunktionen für Lock-Tests.
          """
      
          @staticmethod
          def create_deadlock_scenario(
              lock1: threading.Lock,
              lock2: threading.Lock,
              delay: float = 0.1
          ) -> tuple[threading.Thread, threading.Thread]:
              """
              Erstellt ein Deadlock-Szenario mit zwei Locks (aber führt es NICHT aus).
      
              WARNUNG: Diese Funktion ist nur für Tests gedacht, die Deadlock-Detection
              testen. Die zurückgegebenen Threads sind NICHT gestartet.
      
              Args:
                  lock1: Erster Lock.
                  lock2: Zweiter Lock.
                  delay: Verzögerung zwischen Lock-Akquisitionen.
      
              Returns:
                  Tuple von zwei Thread-Objekten (nicht gestartet).
              """
      
              def worker1():
                  with lock1:
                      time.sleep(delay)
                      with lock2:
                          pass
      
              def worker2():
                  with lock2:
                      time.sleep(delay)
                      with lock1:
                          pass
      
              t1 = threading.Thread(target=worker1, daemon=True)
              t2 = threading.Thread(target=worker2, daemon=True)
      
              return t1, t2
      
          @staticmethod
          def test_lock_prevents_race_condition(
              lock: Union[threading.Lock, threading.RLock],
              shared_data: Dict[str, Any],
              num_threads: int = 50,
              operations_per_thread: int = 20
          ) -> bool:
              """
              Testet, ob ein Lock Race-Conditions verhindert.
              """
      
              def increment_with_lock():
                  with lock:
                      old = shared_data["value"]
                      time.sleep(0.0001)
                      shared_data["value"] = old + 1
      
              def get_value():
                  with lock:
                      return shared_data["value"]
      
              return assert_race_condition_free(
                  increment_with_lock,
                  get_value,
                  num_threads=num_threads,
                  increments_per_thread=operations_per_thread
              )
      
      
      # =============================================================================
      # Decorator Test Helpers
      # =============================================================================
      
      # create_decorated_counter wird aus tests._helpers importiert (siehe oben)
      
      
      # =============================================================================
      # Pytest Fixtures
      # =============================================================================
      
      @pytest.fixture
      def thread_safe_counter():
          """Fixture für einen thread-sicheren Counter."""
          return ThreadSafeCounter(use_lock=True)
      
      
      @pytest.fixture
      def unsafe_counter():
          """Fixture für einen NICHT thread-sicheren Counter (für Race-Condition-Tests)."""
          return ThreadSafeCounter(use_lock=False)
      
      
      @pytest.fixture
      def rlock():
          """Fixture für einen RLock."""
          return threading.RLock()
      
      
      @pytest.fixture
      def lock():
          """Fixture für einen Lock."""
          return threading.Lock()
      
      
      @pytest.fixture
      def shared_counter_data():
          """Fixture für gemeinsam genutzte Counter-Daten."""
          return {"value": 0}
  - rel_path: tests/core/simulation/command/test_types_smoke.py
    hash: 12a63f59eb5ba553f904b68826684b94f82a3224d80eb6974cfe1b1f9baa2335
    content: "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nSmoke-Test für core.simulation.command.types\
    \ Modul.\n\nTestet grundlegende Import- und Instanziierungsfähigkeit von CommandType und\
    \ Command,\nsowie die korrekte Vermeidung von Importzyklen.\n\"\"\"\n\n\ndef always_true_condition(s):\n\
    \    \"\"\"Condition that always returns True.\"\"\"\n    return True\n\ndef test_command_types_import():\n\
    \    \"\"\"Test: CommandType und Command können importiert werden.\"\"\"\n    from core.simulation.command.types\
    \ import CommandType, Command\n    assert CommandType is not None\n    assert Command\
    \ is not None\n\n\ndef test_command_type_enum_values():\n    \"\"\"Test: CommandType Enum\
    \ hat alle erwarteten Werte.\"\"\"\n    from core.simulation.command.types import CommandType\n\
    \    \n    # Alle definierten Command-Typen sollten vorhanden sein\n    assert hasattr(CommandType,\
    \ 'SET_STATE')\n    assert hasattr(CommandType, 'WAIT_CONDITION')\n    assert hasattr(CommandType,\
    \ 'EXECUTE_FUNC')\n    assert hasattr(CommandType, 'LOG_MESSAGE')\n    \n    # Werte sollten\
    \ eindeutig sein\n    values = [CommandType.SET_STATE, CommandType.WAIT_CONDITION, \n\
    \              CommandType.EXECUTE_FUNC, CommandType.LOG_MESSAGE]\n    assert len(values)\
    \ == len(set(values))\n\n\ndef test_command_instantiation_set_state():\n    \"\"\"Test:\
    \ Command für SET_STATE kann instanziiert werden.\"\"\"\n    from core.simulation.command.types\
    \ import CommandType, Command\n    \n    cmd = Command(\n        type=CommandType.SET_STATE,\n\
    \        target='i',\n        value=90\n    )\n    \n    assert cmd.type == CommandType.SET_STATE\n\
    \    assert cmd.target == 'i'\n    assert cmd.value == 90\n    assert cmd.condition is\
    \ None\n    assert cmd.func is None\n    assert cmd.message is None\n    assert cmd.timeout\
    \ is None\n\n\ndef altitude_condition(s):\n    \"\"\"Condition: Höhe >= 10.0\"\"\"\n \
    \   return s.z >= 10.0\n\n\ndef test_command_instantiation_wait_condition():\n    \"\"\
    \"Test: Command für WAIT_CONDITION kann instanziiert werden.\"\"\"\n    from core.simulation.command.types\
    \ import CommandType, Command\n    \n    cmd = Command(\n        type=CommandType.WAIT_CONDITION,\n\
    \        condition=altitude_condition,\n        timeout=5.0\n    )\n    \n    assert cmd.type\
    \ == CommandType.WAIT_CONDITION\n    assert cmd.condition is not None\n    assert cmd.timeout\
    \ == 5.0\n    assert cmd.target is None\n    assert cmd.value is None\n\n\ndef test_command_instantiation_execute_func():\n\
    \    \"\"\"Test: Command für EXECUTE_FUNC kann instanziiert werden.\"\"\"\n    from core.simulation.command.types\
    \ import CommandType, Command\n    \n    def test_print_func() -> None:\n        \"\"\"\
    Hilfsfunktion für EXECUTE_FUNC-Test: Gibt 'test' aus.\"\"\"\n        print(\"test\")\n\
    \    \n    cmd = Command(\n        type=CommandType.EXECUTE_FUNC,\n        func=test_print_func\n\
    \    )\n    \n    assert cmd.type == CommandType.EXECUTE_FUNC\n    assert cmd.func is\
    \ not None\n    assert cmd.target is None\n    assert cmd.condition is None\n\n\ndef test_command_instantiation_log_message():\n\
    \    \"\"\"Test: Command für LOG_MESSAGE kann instanziiert werden.\"\"\"\n    from core.simulation.command.types\
    \ import CommandType, Command\n    \n    cmd = Command(\n        type=CommandType.LOG_MESSAGE,\n\
    \        message=\"Test message\"\n    )\n    \n    assert cmd.type == CommandType.LOG_MESSAGE\n\
    \    assert cmd.message == \"Test message\"\n    assert cmd.target is None\n    assert\
    \ cmd.func is None\n\n\ndef test_command_is_dataclass():\n    \"\"\"Test: Command ist\
    \ ein dataclass.\"\"\"\n    from core.simulation.command.types import Command\n    from\
    \ dataclasses import is_dataclass\n    \n    assert is_dataclass(Command)\n\n\ndef test_no_runtime_import_of_ufostate():\n\
    \    \"\"\"Test: UfoState wird nicht zur Laufzeit importiert (TYPE_CHECKING only).\"\"\
    \"\n    from core.simulation.command.types import Command, CommandType\n\n    # Command\
    \ sollte importierbar sein, ohne dass state.state geladen wird\n    # (außer es wurde\
    \ bereits woanders geladen)\n    # Dies ist ein Proxy-Test für korrekte TYPE_CHECKING\
    \ Nutzung\n\n    # Erstelle Command mit condition - sollte ohne UfoState-Import funktionieren\n\
    \    cmd = Command(\n        type=CommandType.WAIT_CONDITION,\n        condition=always_true_condition\
    \  # Funktion zur besseren Lesbarkeit, statt Lambda\n    )\n    \n    assert cmd is not\
    \ None\n\n\ndef test_command_package_import():\n    \"\"\"Test: Command und CommandType\
    \ können vom Package importiert werden.\"\"\"\n    from core.simulation.command import\
    \ Command, CommandType\n    \n    assert Command is not None\n    assert CommandType is\
    \ not None\n\n\ndef test_command_module_has_no_circular_imports():\n    \"\"\"Test: Command-Modul\
    \ hat keine zirkulären Imports zu state.\"\"\"\n    import sys\n    \n    # Speichere\
    \ aktuell geladene Module\n    loaded_before = set(sys.modules.keys())\n    \n    # Importiere\
    \ command.types frisch (ggf. neu)\n    if 'core.simulation.command.types' in sys.modules:\n\
    \        del sys.modules['core.simulation.command.types']\n    if 'core.simulation.command'\
    \ in sys.modules:\n        del sys.modules['core.simulation.command']\n    \n    # Import\
    \ sollte nicht state.state zur Laufzeit laden\n\n    # state.state sollte nur geladen\
    \ sein, wenn TYPE_CHECKING true wäre (ist es nicht)\n    # oder wenn es bereits vorher\
    \ geladen war\n    # Ein reines Import von command.types sollte state.state NICHT laden\n\
    \    loaded_after = set(sys.modules.keys())\n    newly_loaded = loaded_after - loaded_before\n\
    \    \n    # Wenn state schon vorher geladen war, ist dieser Test nicht aussagekräftig\n\
    \    # aber das ist ok - der Test verhindert neue zirkuläre Imports\n    if 'core.simulation.state.state'\
    \ not in loaded_before:\n        assert 'core.simulation.state.state' not in newly_loaded,\
    \ \\\n            \"command.types sollte state.state nicht zur Laufzeit importieren\"\n\
    \n\nif __name__ == \"__main__\":\n    tests = [\n        test_command_types_import,\n\
    \        test_command_type_enum_values,\n        test_command_instantiation_set_state,\n\
    \        test_command_instantiation_wait_condition,\n        test_command_instantiation_execute_func,\n\
    \        test_command_instantiation_log_message,\n        test_command_is_dataclass,\n\
    \        test_no_runtime_import_of_ufostate,\n        test_command_package_import,\n \
    \       test_command_module_has_no_circular_imports,\n    ]\n    \n    print(\"Running\
    \ command.types smoke tests...\")\n    for test in tests:\n        try:\n            test()\n\
    \            print(f\"✓ {test.__name__}\")\n        except AssertionError as e:\n    \
    \        print(f\"✗ {test.__name__}: {e}\")\n        except Exception as e:\n        \
    \    print(f\"✗ {test.__name__}: Unexpected error: {e}\")\n    \n    print(\"\\nAll smoke\
    \ tests completed.\")\n"
  - rel_path: tests/core/simulation/exceptions/test_exceptions.py
    hash: 4ffc1bed60f5c91fa55d195ba3890af249c7686062704f87f7cc6fd3be653a25
    content: "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nSmoke-Test für core.simulation.exceptions\
    \ Modul.\n\nTestet grundlegende Import- und Instanziierungsfähigkeit der Exception-Klassen.\n\
    \"\"\"\n\nimport sys\nfrom pathlib import Path\n\n# Sicherstellen, dass src/ im Python-Pfad\
    \ ist\nsrc_path = Path(__file__).parent.parent / \"src\"\nsys.path.insert(0, str(src_path))\n\
    \n\ndef test_exceptions_import():\n    \"\"\"Test: Exception-Klassen können importiert\
    \ werden.\"\"\"\n    from core.simulation.exceptions import SimulationError, ConfigError\n\
    \    assert SimulationError is not None\n    assert ConfigError is not None\n\n\ndef test_simulation_error_is_exception():\n\
    \    \"\"\"Test: SimulationError ist eine Exception-Klasse.\"\"\"\n    from core.simulation.exceptions\
    \ import SimulationError\n    \n    assert issubclass(SimulationError, Exception)\n\n\n\
    def test_config_error_is_simulation_error():\n    \"\"\"Test: ConfigError ist eine SimulationError-Unterklasse.\"\
    \"\"\n    from core.simulation.exceptions import SimulationError, ConfigError\n    \n\
    \    assert issubclass(ConfigError, SimulationError)\n    assert issubclass(ConfigError,\
    \ Exception)\n\n\ndef test_simulation_error_can_be_raised():\n    \"\"\"Test: SimulationError\
    \ kann ausgelöst und gefangen werden.\"\"\"\n    from core.simulation.exceptions import\
    \ SimulationError\n    \n    try:\n        raise SimulationError(\"Test-Fehler\")\n  \
    \  except SimulationError as e:\n        assert str(e) == \"Test-Fehler\"\n        assert\
    \ isinstance(e, Exception)\n\n\ndef test_config_error_can_be_raised():\n    \"\"\"Test:\
    \ ConfigError kann ausgelöst und gefangen werden.\"\"\"\n    from core.simulation.exceptions\
    \ import ConfigError\n    \n    try:\n        raise ConfigError(\"Ungültige Konfiguration\"\
    )\n    except ConfigError as e:\n        assert str(e) == \"Ungültige Konfiguration\"\n\
    \        assert isinstance(e, Exception)\n\n\ndef test_config_error_caught_as_simulation_error():\n\
    \    \"\"\"Test: ConfigError kann als SimulationError gefangen werden.\"\"\"\n    from\
    \ core.simulation.exceptions import SimulationError, ConfigError\n    \n    try:\n   \
    \     raise ConfigError(\"Test\")\n    except SimulationError as e:\n        # ConfigError\
    \ sollte als SimulationError gefangen werden können\n        assert isinstance(e, ConfigError)\n\
    \        assert isinstance(e, SimulationError)\n        assert str(e) == \"Test\"\n\n\n\
    def test_exception_with_no_message():\n    \"\"\"Test: Exceptions können ohne Nachricht\
    \ ausgelöst werden.\"\"\"\n    from core.simulation.exceptions import SimulationError,\
    \ ConfigError\n    \n    try:\n        raise SimulationError()\n    except SimulationError:\n\
    \        pass  # Erfolg\n    \n    try:\n        raise ConfigError()\n    except ConfigError:\n\
    \        pass  # Erfolg\n\n\nif __name__ == \"__main__\":\n    from conftest import run_manual_tests\
    \  # type: ignore[import]\n\n    tests = [\n        test_exceptions_import,\n        test_simulation_error_is_exception,\n\
    \        test_config_error_is_simulation_error,\n        test_simulation_error_can_be_raised,\n\
    \        test_config_error_can_be_raised,\n        test_config_error_caught_as_simulation_error,\n\
    \        test_exception_with_no_message,\n    ]\n\n    run_manual_tests(\"core.simulation.exceptions\"\
    , tests)  # type: ignore[name-defined]\n"
  - rel_path: tests/core/simulation/infrastructure/test_logging_setup.py
    hash: 0b0691e8d2ff39daf04aa03a58d1e2fd4900e17472eaa2f41a8172e20efa1e57
    content: "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nSmoke-Test für core.simulation.infrastructure.logging_setup\
    \ Modul.\n\nTestet grundlegende Import- und Funktionalität der Logging-Setup-Funktionen.\n\
    \"\"\"\n\nimport logging\nimport sys\nfrom pathlib import Path\n\n# Sicherstellen, dass\
    \ src/ im Python-Pfad ist\nsrc_path = Path(__file__).parent.parent / \"src\"\nsys.path.insert(0,\
    \ str(src_path))\n\n\ndef test_logging_setup_import():\n    \"\"\"Test: Logging-Setup-Funktionen\
    \ können importiert werden.\"\"\"\n    from core.simulation.infrastructure import configure_logging,\
    \ get_logger\n    assert configure_logging is not None\n    assert get_logger is not None\n\
    \n\ndef test_get_logger_returns_logger():\n    \"\"\"Test: get_logger gibt ein Logger-Objekt\
    \ zurück.\"\"\"\n    from core.simulation.infrastructure import get_logger\n\n    logger\
    \ = get_logger(\"test_module\")\n    assert isinstance(logger, logging.Logger)\n    assert\
    \ logger.name == \"test_module\"\n\n\ndef test_get_logger_with_module_name():\n    \"\"\
    \"Test: get_logger funktioniert mit __name__.\"\"\"\n    from core.simulation.infrastructure\
    \ import get_logger\n\n    logger = get_logger(__name__)\n    assert isinstance(logger,\
    \ logging.Logger)\n    # Der Name sollte den Modulnamen enthalten\n    assert logger.name\
    \ == __name__\n\n\ndef test_configure_logging_is_idempotent():\n    \"\"\"Test: configure_logging\
    \ kann mehrfach aufgerufen werden ohne Fehler.\"\"\"\n    from core.simulation.infrastructure\
    \ import configure_logging\n\n    # Sollte keine Exceptions werfen\n    configure_logging()\n\
    \    configure_logging()\n    configure_logging()\n\n\ndef test_configure_logging_with_custom_level():\n\
    \    \"\"\"Test: configure_logging akzeptiert benutzerdefiniertes Log-Level.\"\"\"\n \
    \   from core.simulation.infrastructure import configure_logging\n\n    # Sollte keine\
    \ Exceptions werfen\n    configure_logging(level=logging.DEBUG)\n    configure_logging(level=logging.WARNING)\n\
    \n\ndef test_configure_logging_with_custom_format():\n    \"\"\"Test: configure_logging\
    \ akzeptiert benutzerdefinierten Format-String.\"\"\"\n    from core.simulation.infrastructure\
    \ import configure_logging\n\n    # Sollte keine Exceptions werfen\n    configure_logging(format_string='%(name)s\
    \ - %(message)s')\n\n\ndef test_configure_logging_with_custom_datefmt():\n    \"\"\"Test:\
    \ configure_logging akzeptiert benutzerdefiniertes Datumsformat.\"\"\"\n    from core.simulation.infrastructure\
    \ import configure_logging\n\n    # Sollte keine Exceptions werfen\n    configure_logging(datefmt='%H:%M:%S')\n\
    \n\ndef test_logger_can_log_messages():\n    \"\"\"Test: Logger kann Nachrichten ausgeben\
    \ ohne Fehler.\"\"\"\n    from core.simulation.infrastructure import get_logger\n\n  \
    \  logger = get_logger(\"test_logging\")\n    \n    # Diese sollten keine Exceptions werfen\n\
    \    logger.debug(\"Debug-Nachricht\")\n    logger.info(\"Info-Nachricht\")\n    logger.warning(\"\
    Warning-Nachricht\")\n    logger.error(\"Error-Nachricht\")\n\n\ndef test_multiple_loggers_independent():\n\
    \    \"\"\"Test: Mehrere Logger sind unabhängig voneinander.\"\"\"\n    from core.simulation.infrastructure\
    \ import get_logger\n\n    logger1 = get_logger(\"module1\")\n    logger2 = get_logger(\"\
    module2\")\n    \n    assert logger1 is not logger2\n    assert logger1.name == \"module1\"\
    \n    assert logger2.name == \"module2\"\n\n\ndef test_same_logger_name_returns_same_instance():\n\
    \    \"\"\"Test: Gleicher Logger-Name gibt gleiche Instanz zurück.\"\"\"\n    from core.simulation.infrastructure\
    \ import get_logger\n\n    logger1 = get_logger(\"same_module\")\n    logger2 = get_logger(\"\
    same_module\")\n    \n    # logging.getLogger gibt für gleichen Namen gleiche Instanz\
    \ zurück\n    assert logger1 is logger2\n\n\nif __name__ == \"__main__\":\n    from conftest\
    \ import run_manual_tests  # type: ignore[import]\n\n    tests = [\n        test_logging_setup_import,\n\
    \        test_get_logger_returns_logger,\n        test_get_logger_with_module_name,\n\
    \        test_configure_logging_is_idempotent,\n        test_configure_logging_with_custom_level,\n\
    \        test_configure_logging_with_custom_format,\n        test_configure_logging_with_custom_datefmt,\n\
    \        test_logger_can_log_messages,\n        test_multiple_loggers_independent,\n \
    \       test_same_logger_name_returns_same_instance,\n    ]\n\n    run_manual_tests(\"\
    core.simulation.logging_setup\", tests)  # type: ignore[name-defined]\n"
  - rel_path: tests/core/simulation/observer/test_heading_delta.py
    hash: 252b80f4c765224970643331d4d0dd454f80af0af220c8f290342066bc21f533
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """
      Unit-Tests für Heading-Hilfsfunktionen (Wrap-around-Logik).
      
      Testet die normalize_heading_delta Funktion isoliert.
      """
      
      from core.simulation.observer import normalize_heading_delta
      
      
      class TestNormalizeHeadingDelta:
          """Tests für die Heading-Delta-Normalisierung (Wrap-around)."""
      
          def test_no_wrap_around_positive_small(self):
              """Kleine positive Differenz ohne Wrap-around."""
              delta = normalize_heading_delta(45.0)
              assert delta == 45.0
      
          def test_no_wrap_around_negative_small(self):
              """Kleine negative Differenz bleibt unverändert."""
              delta = normalize_heading_delta(-45.0)
              assert delta == -45.0
      
          def test_no_wrap_around_at_boundary_positive(self):
              """Differenz genau bei +180° (Grenzfall) -> normalisiert zu -180°."""
              delta = normalize_heading_delta(180.0)
              assert delta == -180.0
      
          def test_no_wrap_around_at_boundary_negative(self):
              """Differenz genau bei -180° (Grenzfall)."""
              delta = normalize_heading_delta(-180.0)
              assert delta == -180.0
      
          def test_wrap_around_positive_to_negative(self):
              """Wrap-around von positiv zu negativ (350° → 10° = +20°)."""
              # Delta roh: 10 - 350 = -340
              # Normalisiert: -340 + 360 = +20
              delta = normalize_heading_delta(-340.0)
              assert delta == 20.0
      
          def test_wrap_around_negative_to_positive(self):
              """Wrap-around von negativ zu positiv (10° → 350° = -20°)."""
              # Delta roh: 350 - 10 = +340
              # Normalisiert: +340 - 360 = -20
              delta = normalize_heading_delta(340.0)
              assert delta == -20.0
      
          def test_wrap_around_just_over_180(self):
              """Knapp über +180° triggert Wrap-around."""
              # 181° → -179°
              delta = normalize_heading_delta(181.0)
              assert delta == -179.0
      
          def test_wrap_around_just_under_minus_180(self):
              """Knapp unter -180° triggert Wrap-around."""
              # -181° → +179°
              delta = normalize_heading_delta(-181.0)
              assert delta == 179.0
      
          def test_full_circle_positive(self):
              """Voller Kreis positiv (360°) wird zu 0°."""
              delta = normalize_heading_delta(360.0)
              assert delta == 0.0
      
          def test_full_circle_negative(self):
              """Voller Kreis negativ (-360°) wird zu 0°."""
              delta = normalize_heading_delta(-360.0)
              assert delta == 0.0
      
          def test_multiple_wraps_positive(self):
              """Mehrfache Umläufe positiv (540° = 360° + 180°) -> normalisiert zu -180°."""
              # 540° - 360° = 180° -> -180° (Konsistenz)
              delta = normalize_heading_delta(540.0)
              assert delta == -180.0
      
          def test_multiple_wraps_negative(self):
              """Mehrfache Umläufe negativ (-540° = -360° - 180°)."""
              # -540° + 360° = -180°
              delta = normalize_heading_delta(-540.0)
              assert delta == -180.0
      
          def test_realistic_scenario_right_turn(self):
              """Realistisches Szenario: Rechtskurve von 5° auf 355°."""
              # Delta: 355 - 5 = 350° (roh)
              # Normalisiert: 350 - 360 = -10° (Rechtskurve)
              delta = normalize_heading_delta(350.0)
              assert delta == -10.0
      
          def test_realistic_scenario_left_turn(self):
              """Realistisches Szenario: Linkskurve von 355° auf 5°."""
              # Delta: 5 - 355 = -350° (roh)
              # Normalisiert: -350 + 360 = +10° (Linkskurve)
              delta = normalize_heading_delta(-350.0)
              assert delta == 10.0
      
          def test_zero_delta(self):
              """Keine Änderung (0°)."""
              delta = normalize_heading_delta(0.0)
              assert delta == 0.0
      
          def test_symmetry_positive_negative(self):
              """Symmetrie: +170° und -170° bleiben unverändert."""
              assert normalize_heading_delta(170.0) == 170.0
              assert normalize_heading_delta(-170.0) == -170.0
      
          def test_output_range_bounds(self):
              """Ausgabe ist immer im Bereich [-180, 180]."""
              test_values = [-540, -360, -340, -181, -180, -45, 0, 45, 180, 181, 340, 360, 540]
              for value in test_values:
                  result = normalize_heading_delta(value)
                  msg = f"normalize_heading_delta({value}) = {result} außerhalb [-180, 180]"
                  assert -180 <= result <= 180, msg
      
      
      class TestNormalizeHeadingDeltaEdgeCases:
          """Edge-Cases und Spezialfälle."""
      
          def test_very_large_positive(self):
              """Sehr große positive Werte."""
              # 720° = 2 * 360° → 0°
              delta = normalize_heading_delta(720.0)
              assert delta == 0.0
      
          def test_very_large_negative(self):
              """Sehr große negative Werte."""
              # -720° = -2 * 360° → 0°
              delta = normalize_heading_delta(-720.0)
              assert delta == 0.0
      
          def test_fractional_degrees(self):
              """Dezimalwerte funktionieren korrekt."""
              delta = normalize_heading_delta(45.5)
              assert delta == 45.5
      
              delta = normalize_heading_delta(-45.5)
              assert delta == -45.5
      
              # Wrap-around mit Dezimalstellen
              delta = normalize_heading_delta(190.5)
              assert delta == -169.5
      
          def test_consistency_with_abs(self):
              """Absolute Werte sind konsistent."""
              # ±350° sollten beide zu ±10° werden (symmetrisch)
              pos = normalize_heading_delta(350.0)
              neg = normalize_heading_delta(-350.0)
              assert abs(pos) == abs(neg) == 10.0
              assert pos == -10.0
              assert neg == 10.0
  - rel_path: tests/core/simulation/observer/test_observer.py
    hash: 9fc6250eafae5cdd8f7f31d04cd72394fb4363aee45a81ac87beaa0fcf315028
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """
      Unit-Tests für das observer-Modul.
      
      Testet Phase-Erkennung, Manöver-Analyse und State-Observer mit
      synthetischen Zustandsverläufen.
      """
      
      from core.simulation.infrastructure import DEFAULT_CONFIG, SimulationConfig
      from core.simulation.observer import (
          ManeuverAnalysis,
          compute_phase,
          StateObserver,
      )
      from core.simulation.state import UfoState
      
      
      # =============================================================================
      # Tests für compute_phase()
      # =============================================================================
      
      class TestComputePhase:
          """Tests für die regelbasierte Phasenbestimmung."""
      
          def test_idle_initial_state(self):
              """Initialer Zustand (am Boden, nie geflogen) ist idle."""
              state = UfoState(x=0.0, y=0.0, z=0.0, v=0.0, dist=0.0, ftime=0.0)
              assert compute_phase(state) == "idle"
      
          def test_idle_after_reset(self):
              """Nach Reset (z=0, v=0, keine Flugzeit) ist idle."""
              state = UfoState(x=100.0, y=100.0, z=0.0, v=0.0, dist=0.0, ftime=0.0)
              assert compute_phase(state) == "idle"
      
          def test_takeoff_just_lifted(self):
              """Gerade abgehoben (ftime=0, z>0, v>0) ist takeoff."""
              state = UfoState(z=0.5, v=5.0, ftime=0.0, dist=0.0)
              assert compute_phase(state) == "takeoff"
      
          def test_takeoff_very_low_altitude(self):
              """Sehr niedrige Höhe mit Geschwindigkeit ist noch takeoff."""
              state = UfoState(z=0.1, v=3.0, ftime=0.0, dist=0.0)
              assert compute_phase(state) == "takeoff"
      
          def test_flying_normal_altitude(self):
              """Normale Flughöhe mit Geschwindigkeit ist flying."""
              state = UfoState(z=10.0, v=10.0, vz=0.0, ftime=1.0, dist=5.0)
              assert compute_phase(state) == "flying"
      
          def test_flying_high_altitude(self):
              """Große Höhe mit Geschwindigkeit ist flying."""
              state = UfoState(z=100.0, v=15.0, vz=2.0, ftime=10.0, dist=50.0)
              assert compute_phase(state) == "flying"
      
          def test_landing_low_altitude_descending(self):
              """Niedriger Flug mit Sinkflug ist landing."""
              state = UfoState(z=1.5, v=5.0, vz=-0.5, ftime=5.0, dist=20.0)
              assert compute_phase(state) == "landing"
      
          def test_landing_at_detection_height(self):
              """An der Erkennungshöhe mit Sinkflug ist landing."""
              config = DEFAULT_CONFIG
              state = UfoState(
                  z=config.landing_detection_height_m,
                  v=3.0,
                  vz=-0.3,
                  ftime=10.0,
                  dist=30.0,
              )
              assert compute_phase(state, config) == "landing"
      
          def test_landed_after_flight(self):
              """Am Boden nach erfolgreichem Flug ist landed."""
              state = UfoState(z=0.0, v=0.0, ftime=10.0, dist=50.0)
              assert compute_phase(state) == "landed"
      
          def test_landed_with_flight_distance(self):
              """Am Boden mit zurückgelegter Strecke ist landed."""
              state = UfoState(z=0.0, v=0.0, ftime=0.0, dist=100.0)
              assert compute_phase(state) == "landed"
      
          def test_crashed_negative_z(self):
              """Negative Höhe ist crashed."""
              state = UfoState(z=-1.0, v=5.0, ftime=5.0, dist=20.0)
              assert compute_phase(state) == "crashed"
      
          def test_crashed_negative_z_marker(self):
              """Sehr negative Höhe (Crash-Marker) ist crashed."""
              state = UfoState(z=-10.0, v=0.0, ftime=10.0, dist=30.0)
              assert compute_phase(state) == "crashed"
      
      
      class TestComputePhasePriorities:
          """Tests für die Prioritätsreihenfolge der Phasen-Regeln."""
      
          def test_crashed_has_highest_priority(self):
              """Crashed hat höchste Priorität (überstimmt alle anderen)."""
              # Auch mit v>0 und z<0 ist es crashed, nicht flying
              state = UfoState(z=-0.1, v=10.0, vz=-2.0, ftime=5.0, dist=20.0)
              assert compute_phase(state) == "crashed"
      
          def test_landed_before_idle(self):
              """Landed hat Priorität vor idle (has_flown unterscheidet)."""
              # Am Boden mit Flugzeit -> landed
              state1 = UfoState(z=0.0, v=0.0, ftime=10.0, dist=50.0)
              assert compute_phase(state1) == "landed"
      
              # Am Boden ohne Flugzeit -> idle
              state2 = UfoState(z=0.0, v=0.0, ftime=0.0, dist=0.0)
              assert compute_phase(state2) == "idle"
      
          def test_takeoff_before_landing(self):
              """Takeoff hat Priorität vor landing (ftime=0 unterscheidet)."""
              # Niedriger Flug mit ftime=0 -> takeoff
              state1 = UfoState(z=1.0, v=5.0, vz=-0.5, ftime=0.0, dist=0.0)
              assert compute_phase(state1) == "takeoff"
      
              # Niedriger Flug mit ftime>0 und vz<0 -> landing
              state2 = UfoState(z=1.0, v=5.0, vz=-0.5, ftime=2.0, dist=10.0)
              assert compute_phase(state2) == "landing"
      
          def test_landing_before_flying(self):
              """Landing hat Priorität vor flying (niedrige Höhe + vz<0)."""
              # Niedrig mit Sinkflug -> landing
              state1 = UfoState(z=1.5, v=5.0, vz=-0.5, ftime=5.0, dist=20.0)
              assert compute_phase(state1) == "landing"
      
              # Niedrig ohne Sinkflug -> flying
              state2 = UfoState(z=1.5, v=5.0, vz=0.0, ftime=5.0, dist=20.0)
              assert compute_phase(state2) == "flying"
      
      
      class TestComputePhaseEdgeCases:
          """Tests für Grenzfälle und spezielle Konfigurationen."""
      
          def test_zero_velocity_in_air(self):
              """Geschwindigkeit 0 in der Luft ist hovering (schwebt)."""
              state = UfoState(z=10.0, v=0.0, vz=0.0, ftime=5.0, dist=20.0)
              # v=0, vz=0, z>0 -> hovering
              assert compute_phase(state) == "hovering"
      
          def test_custom_landing_detection_height(self):
              """Benutzerdefinierte Landungshöhe wird korrekt verwendet."""
              # landing_detection_height_m ist eine abgeleitete Property von SimulationConfig –
              # Anpassung über max_altitude_m in SimulationConfig möglich (hier DEFAULT_CONFIG).
              config = DEFAULT_CONFIG
      
              # Knapp unter Schwelle mit vz<0 -> landing
              state1 = UfoState(
                  z=config.landing_detection_height_m - 0.1,
                  v=5.0,
                  vz=-0.5,
                  ftime=5.0,
                  dist=20.0,
              )
              assert compute_phase(state1, config) == "landing"
      
              # Über Schwelle mit vz<0 -> flying
              state2 = UfoState(
                  z=config.landing_detection_height_m + 0.1,
                  v=5.0,
                  vz=-0.5,
                  ftime=5.0,
                  dist=20.0,
              )
              assert compute_phase(state2, config) == "flying"
      
          def test_zero_threshold_handling(self):
              """Exakte Schwellenwerte (z=0) werden korrekt behandelt."""
              config = DEFAULT_CONFIG
      
              # Exakt z=0 mit Flugzeit -> landed
              state1 = UfoState(z=config.zero_value, v=0.0, ftime=10.0, dist=50.0)
              assert compute_phase(state1, config) == "landed"
      
              # Minimal über z=0 mit v>0 -> flying oder takeoff
              state2 = UfoState(
                  z=config.zero_value + 0.01, v=5.0, ftime=0.0, dist=0.0
              )
              assert compute_phase(state2, config) == "takeoff"
      
          def test_positive_vz_in_landing_range(self):
              """Steigflug in niedriger Höhe ist flying, nicht landing."""
              state = UfoState(z=1.5, v=5.0, vz=0.5, ftime=5.0, dist=20.0)
              # vz>0 erfüllt nicht landing-Kriterium
              assert compute_phase(state) == "flying"
      
      
      # =============================================================================
      # Tests für ManeuverAnalysis
      # =============================================================================
      
      class TestManeuverAnalysis:
          """Tests für die ManeuverAnalysis Dataclass."""
      
          def test_default_values(self):
              """Standard-Werte sind korrekt gesetzt."""
              analysis = ManeuverAnalysis(phase="idle")
              assert analysis.phase == "idle"
              assert analysis.is_ascending is False
              assert analysis.is_descending is False
              assert analysis.is_turning is False
              assert analysis.is_stagnating is False
              assert analysis.avg_vz == 0.0
              assert analysis.avg_heading_change == 0.0
      
          def test_custom_values(self):
              """Benutzerdefinierte Werte werden korrekt gespeichert."""
              analysis = ManeuverAnalysis(
                  phase="flying",
                  is_ascending=True,
                  is_turning=True,
                  avg_vz=2.5,
                  avg_heading_change=10.0,
              )
              assert analysis.phase == "flying"
              assert analysis.is_ascending is True
              assert analysis.is_descending is False
              assert analysis.is_turning is True
              assert analysis.avg_vz == 2.5
              assert analysis.avg_heading_change == 10.0
      
      
      # =============================================================================
      # Tests für StateObserver
      # =============================================================================
      
      class TestStateObserverBasics:
          """Basis-Funktionalität des StateObserver."""
      
          def test_initialization(self):
              """Observer wird korrekt initialisiert."""
              observer = StateObserver()
              assert observer.config == DEFAULT_CONFIG
              assert len(observer.history) == 0
      
          def test_custom_config(self):
              """Observer kann mit benutzerdefinierter Config erstellt werden."""
              config = SimulationConfig(observer_history_size=20)
              observer = StateObserver(config)
              assert observer.config == config
              assert observer.history.maxlen == 20
      
          def test_observe_adds_to_history(self):
              """observe() fügt Zustände zur Historie hinzu."""
              observer = StateObserver()
              state = UfoState(x=10.0, z=5.0)
      
              observer.observe(state)
              assert len(observer.history) == 1
              assert observer.history[0].x == 10.0
              assert observer.history[0].z == 5.0
      
          def test_observe_creates_copy(self):
              """observe() erstellt defensive Kopie des States."""
              observer = StateObserver()
              state = UfoState(x=10.0, z=5.0)
      
              observer.observe(state)
              # Original-State ist nicht das gleiche Objekt
              assert observer.history[0] is not state
              # Aber hat die gleichen Werte
              assert observer.history[0].x == state.x
              assert observer.history[0].z == state.z
      
          def test_history_respects_maxlen(self):
              """Historie respektiert maxlen (Ringpuffer)."""
              config = SimulationConfig(observer_history_size=3)
              observer = StateObserver(config)
      
              for i in range(5):
                  observer.observe(UfoState(x=float(i)))
      
              # Nur die letzten 3 Einträge bleiben
              assert len(observer.history) == 3
              assert observer.history[0].x == 2.0
              assert observer.history[1].x == 3.0
              assert observer.history[2].x == 4.0
      
      
      class TestStateObserverAnalyze:
          """Tests für die analyze() Methode."""
      
          def test_analyze_empty_history_returns_idle(self):
              """Leere Historie gibt idle zurück."""
              observer = StateObserver()
              analysis = observer.analyze()
      
              assert analysis.phase == "idle"
              assert analysis.is_ascending is False
              assert analysis.is_descending is False
      
          def test_analyze_single_state(self):
              """Einzelner State wird korrekt analysiert."""
              observer = StateObserver()
              observer.observe(UfoState(z=10.0, v=10.0, ftime=5.0, dist=20.0))
      
              analysis = observer.analyze()
              assert analysis.phase == "flying"
      
          def test_analyze_detects_ascending(self):
              """Steigflug wird erkannt (avg_vz > threshold)."""
              config = SimulationConfig(climb_vz_threshold_ms=0.5)
              observer = StateObserver(config)
      
              # Mehrere Zustände mit steigendem vz
              for i in range(5):
                  observer.observe(UfoState(z=float(i), v=10.0, vz=1.0, ftime=float(i)))
      
              analysis = observer.analyze()
              assert analysis.is_ascending is True
              assert analysis.avg_vz > config.climb_vz_threshold_ms
      
          def test_analyze_detects_descending(self):
              """Sinkflug wird erkannt (avg_vz < threshold)."""
              config = SimulationConfig(descent_vz_threshold_ms=-0.5)
              observer = StateObserver(config)
      
              # Mehrere Zustände mit sinkendem vz
              for i in range(5):
                  observer.observe(
                      UfoState(z=10.0 - float(i), v=10.0, vz=-1.0, ftime=float(i))
                  )
      
              analysis = observer.analyze()
              assert analysis.is_descending is True
              assert analysis.avg_vz < config.descent_vz_threshold_ms
      
          def test_analyze_detects_turning(self):
              """Kurven werden erkannt (avg_heading_change > threshold)."""
              config = SimulationConfig(turn_heading_threshold_deg=5.0)
              observer = StateObserver(config)
      
              # Mehrere Zustände mit sich änderndem Heading
              headings = [0.0, 10.0, 20.0, 30.0, 40.0]
              for i, heading in enumerate(headings):
                  observer.observe(
                      UfoState(d=heading, v=10.0, z=10.0, ftime=float(i))
                  )
      
              analysis = observer.analyze()
              assert analysis.is_turning is True
              assert analysis.avg_heading_change > config.turn_heading_threshold_deg
      
          def test_analyze_heading_wrap_around_positive(self):
              """Wrap-around bei Heading (350° → 10°) wird korrekt behandelt."""
              observer = StateObserver()
      
              observer.observe(UfoState(d=350.0, v=10.0, z=10.0))
              observer.observe(UfoState(d=10.0, v=10.0, z=10.0))
      
              analysis = observer.analyze()
              # Delta sollte 20° sein, nicht 340°
              assert analysis.avg_heading_change < 30.0
              assert analysis.is_turning is False
      
          def test_analyze_heading_wrap_around_negative(self):
              """Wrap-around bei Heading (10° → 350°) wird korrekt behandelt."""
              observer = StateObserver()
      
              # Benötigt mindestens 3 States für Trend-Analyse
              observer.observe(UfoState(d=5.0, v=10.0, z=10.0))
              observer.observe(UfoState(d=10.0, v=10.0, z=10.0))
              observer.observe(UfoState(d=350.0, v=10.0, z=10.0))
      
              analysis = observer.analyze()
              # Delta sollte ~20° sein (10→350 = -20° bzw. +340°, wrap gibt 20°)
              # Durchschnitt: (5° + 20°) / 2 = 12.5°
              assert analysis.avg_heading_change < 30.0
              assert 10.0 < analysis.avg_heading_change < 15.0  # Näherungsweise 12.5°
      
          def test_analyze_detects_stagnation(self):
              """Stagnation wird erkannt (geringe Bewegung trotz v>0)."""
              config = SimulationConfig(dt=0.1)
              observer = StateObserver(config)
      
              # UFO sollte sich mit 10m/s bewegen, tut es aber nicht
              for i in range(10):
                  # Sehr kleine Positionsänderung trotz vel=10m/s
                  observer.observe(
                      UfoState(
                          x=float(i) * 0.01,  # Nur 0.01m pro Step statt 1m
                          y=0.0,
                          z=10.0,
                          v=10.0,
                          vel=10.0,
                          ftime=float(i) * 0.1,
                      )
                  )
      
              analysis = observer.analyze()
              assert analysis.is_stagnating
      
          def test_analyze_no_stagnation_when_moving_correctly(self):
              """Keine Stagnation bei korrekter Bewegung."""
              config = SimulationConfig(dt=0.1)
              observer = StateObserver(config)
      
              # UFO bewegt sich korrekt mit 10m/s
              for i in range(10):
                  observer.observe(
                      UfoState(
                          x=float(i) * 1.0,  # 1m pro Step bei 10m/s und dt=0.1s
                          y=0.0,
                          z=10.0,
                          v=10.0,
                          vel=10.0,
                          ftime=float(i) * 0.1,
                      )
                  )
      
              analysis = observer.analyze()
              assert not analysis.is_stagnating
      
      
      class TestStateObserverManeuverDescription:
          """Tests für get_maneuver_description()."""
      
          def test_description_includes_phase(self):
              """Beschreibung enthält immer die Phase."""
              observer = StateObserver()
              observer.observe(UfoState(z=10.0, v=10.0, ftime=5.0))
      
              desc = observer.get_maneuver_description()
              assert "Phase: flying" in desc
      
          def test_description_includes_climbing(self):
              """Beschreibung enthält 'climbing' bei Steigflug."""
              config = SimulationConfig(climb_vz_threshold_ms=0.5)
              observer = StateObserver(config)
      
              for i in range(5):
                  observer.observe(UfoState(z=float(i), v=10.0, vz=1.0, ftime=float(i)))
      
              desc = observer.get_maneuver_description()
              assert "climbing" in desc
      
          def test_description_includes_descending(self):
              """Beschreibung enthält 'descending' bei Sinkflug."""
              config = SimulationConfig(descent_vz_threshold_ms=-0.5)
              observer = StateObserver(config)
      
              for i in range(5):
                  observer.observe(
                      UfoState(z=10.0 - float(i), v=10.0, vz=-1.0, ftime=float(i))
                  )
      
              desc = observer.get_maneuver_description()
              assert "descending" in desc
      
          def test_description_includes_turning(self):
              """Beschreibung enthält 'turning' und Delta bei Kurven."""
              config = SimulationConfig(turn_heading_threshold_deg=5.0)
              observer = StateObserver(config)
      
              headings = [0.0, 10.0, 20.0, 30.0]
              for i, heading in enumerate(headings):
                  observer.observe(UfoState(d=heading, v=10.0, z=10.0, ftime=float(i)))
      
              desc = observer.get_maneuver_description()
              assert "turning" in desc
              assert "Δd=" in desc
      
          def test_description_includes_stagnating(self):
              """Beschreibung enthält 'stagnating' bei Stagnation."""
              config = SimulationConfig(dt=0.1)
              observer = StateObserver(config)
      
              for i in range(10):
                  observer.observe(
                      UfoState(
                          x=float(i) * 0.01, y=0.0, z=10.0, v=10.0, vel=10.0, ftime=float(i) * 0.1
                      )
                  )
      
              desc = observer.get_maneuver_description()
              assert "stagnating" in desc
      
          def test_description_includes_vz_when_nonzero(self):
              """Beschreibung enthält vz wenn != 0."""
              observer = StateObserver()
      
              for i in range(5):
                  observer.observe(UfoState(z=float(i), v=10.0, vz=2.5, ftime=float(i)))
      
              desc = observer.get_maneuver_description()
              assert "vz=" in desc
      
      
      class TestStateObserverIntegration:
          """Integrationstests mit realistischen Szenarien."""
      
          def test_complete_takeoff_sequence(self):
              """Komplette Startsequenz wird korrekt erkannt."""
              observer = StateObserver()
      
              # Start am Boden
              observer.observe(UfoState(z=0.0, v=0.0, ftime=0.0))
              assert observer.analyze().phase == "idle"
      
              # Abheben - mehrere States für Trend-Erkennung
              observer.observe(UfoState(z=0.3, v=5.0, vz=1.0, ftime=0.0))
              observer.observe(UfoState(z=0.6, v=5.0, vz=1.2, ftime=0.0))
              observer.observe(UfoState(z=0.9, v=5.0, vz=1.5, ftime=0.0))
              analysis = observer.analyze()
              assert analysis.phase == "takeoff"
              # Jetzt haben wir genug States für Trend-Erkennung (>= 3)
              assert analysis.is_ascending
      
              # Steigflug
              for i in range(10):
                  observer.observe(
                      UfoState(z=1.0 + float(i), v=10.0, vz=1.0, ftime=float(i) * 0.1)
                  )
              analysis = observer.analyze()
              assert analysis.phase == "flying"
              assert analysis.is_ascending
      
          def test_complete_landing_sequence(self):
              """Komplette Landungssequenz wird korrekt erkannt."""
              observer = StateObserver()
      
              # Reiseflug
              observer.observe(UfoState(z=20.0, v=10.0, vz=0.0, ftime=10.0, dist=100.0))
              assert observer.analyze().phase == "flying"
      
              # Landeanflug (Sinkflug)
              for i in range(5):
                  observer.observe(
                      UfoState(
                          z=5.0 - float(i) * 0.8,
                          v=5.0,
                          vz=-0.8,
                          ftime=10.0 + float(i) * 0.1,
                          dist=100.0 + float(i) * 0.5,
                      )
                  )
              analysis = observer.analyze()
              assert analysis.phase == "landing"
              assert analysis.is_descending is True
      
              # Gelandet
              observer.observe(UfoState(z=0.0, v=0.0, ftime=15.0, dist=105.0))
              assert observer.analyze().phase == "landed"
      
          def test_circular_flight_pattern(self):
              """Kreisflug wird als turning erkannt."""
              config = SimulationConfig(turn_heading_threshold_deg=5.0)
              observer = StateObserver(config)
      
              # Kreisflug mit konstantem Radius
              import math
      
              for i in range(20):
                  angle = float(i) * 18.0  # 18° pro Schritt = voller Kreis in 20 Schritten
                  x = 10.0 * math.cos(math.radians(angle))
                  y = 10.0 * math.sin(math.radians(angle))
                  observer.observe(
                      UfoState(
                          x=x, y=y, z=10.0, d=angle, v=10.0, ftime=float(i) * 0.1
                      )
                  )
      
              analysis = observer.analyze()
              assert analysis.phase == "flying"
              assert analysis.is_turning is True
              assert analysis.avg_heading_change > config.turn_heading_threshold_deg
  - rel_path: tests/core/simulation/observer/test_smoke.py
    hash: d1cb1914b3ba37ef88b823e99de9bd4a077492726640356cc707bda2581a9109
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """
      Smoke-Tests für das observer-Modul.
      
      Prüft grundlegende Importierbarkeit, Instantiierung und Dependency-Einhaltung.
      """
      
      
      def test_observer_module_import():
          """Observer-Modul kann standalone importiert werden."""
          from core.simulation.observer import (
              Phase,
              ManeuverAnalysis,
              compute_phase,
              StateObserver,
          )
      
          assert Phase is not None
          assert ManeuverAnalysis is not None
          assert compute_phase is not None
          assert StateObserver is not None
      
      
      def test_phase_type_is_literal():
          """Phase ist ein Literal-Type mit den erwarteten Werten."""
          from core.simulation.observer import Phase
          from typing import get_args
      
          # Phase sollte ein Literal sein
          args = get_args(Phase)
          expected_phases = {"idle", "takeoff", "hovering", "flying", "landing", "landed", "crashed"}
      
          assert set(args) == expected_phases
      
      
      def test_compute_phase_callable():
          """compute_phase ist aufrufbar."""
          from core.simulation.observer import compute_phase
          from core.simulation.state import UfoState
      
          assert callable(compute_phase)
      
          # Minimaler Aufruf sollte funktionieren
          state = UfoState()
          result = compute_phase(state)
          assert result in ["idle", "takeoff", "flying", "landing", "landed", "crashed"]
      
      
      def test_maneuver_analysis_instantiation():
          """ManeuverAnalysis kann instantiiert werden."""
          from core.simulation.observer import ManeuverAnalysis
      
          # Minimale Instantiierung
          analysis = ManeuverAnalysis(phase="idle")
          assert analysis is not None
          assert analysis.phase == "idle"
      
          # Vollständige Instantiierung
          analysis_full = ManeuverAnalysis(
              phase="flying",
              is_ascending=True,
              is_descending=False,
              is_turning=True,
              is_stagnating=False,
              avg_vz=1.5,
              avg_heading_change=10.0,
          )
          assert analysis_full.phase == "flying"
          assert analysis_full.is_ascending is True
      
      
      def test_state_observer_instantiation():
          """StateObserver kann ohne Dependencies instantiiert werden."""
          from core.simulation.observer import StateObserver
      
          # Default-Initialisierung
          observer = StateObserver()
          assert observer is not None
      
          # Mit Config
          from core.simulation.infrastructure import SimulationConfig
      
          config = SimulationConfig(observer_history_size=20)
          observer_with_config = StateObserver(config)
          assert observer_with_config is not None
          assert observer_with_config.config == config
      
      
      def test_state_observer_has_required_methods():
          """StateObserver hat alle geforderten Methoden."""
          from core.simulation.observer import StateObserver
      
          observer = StateObserver()
      
          # Geforderte Methoden aus Spec
          assert hasattr(observer, "observe")
          assert hasattr(observer, "analyze")
          assert hasattr(observer, "get_maneuver_description")
      
          # Alle Methoden sollten aufrufbar sein
          assert callable(observer.observe)
          assert callable(observer.analyze)
          assert callable(observer.get_maneuver_description)
      
      
      def test_state_observer_has_history():
          """StateObserver hat history-Attribut als deque."""
          from collections import deque
      
          from core.simulation.observer import StateObserver
      
          observer = StateObserver()
      
          assert hasattr(observer, "history")
          assert isinstance(observer.history, deque)
      
      
      def test_observer_module_has_no_forbidden_dependencies():
          """Observer-Modul hat keine verbotenen Dependencies."""
          from core.simulation.observer import observer as observer_module
      
          # Observer-Modul laden
          module_source = observer_module.__file__
      
          # Modul-Quelltext überprüfen
          with open(module_source, "r", encoding="utf-8") as f:
              content = f.read()
      
          # Generische Sicherheitsprüfung der Importstruktur (AST‑basiert)
          import ast
      
          tree = ast.parse(content)
      
          # Erlaubte Root-Pakete nach einhaltung der Ticketvorgaben
          forbidden_roots = {
              "core.simulation.physics",
              "core.simulation.controller",
              "core.simulation.command",
              "core.simulation.view",
              "core.simulation.state.manager",
          }
      
          for node in ast.walk(tree):
              if isinstance(node, ast.Import):
                  for alias in node.names:
                      for root in forbidden_roots:
                          if alias.name.startswith(root):
                              raise AssertionError(
                                  f"Observer sollte keine verbotene Dependency importieren: import {alias.name}")
      
              if isinstance(node, ast.ImportFrom) and node.module:
                  for root in forbidden_roots:
                      if node.module.startswith(root):
                          raise AssertionError(
                              f"Observer sollte keine verbotene Dependency importieren: from {node.module} import ...")
      
      
      def test_observer_module_exports():
          """Observer-Modul exportiert die erwarteten Symbole."""
          from core.simulation import observer as observer_module
      
          expected_exports = {
              "Phase",
              "ManeuverAnalysis",
              "compute_phase",
              "normalize_heading_delta",
              "StateObserver",
          }
      
          assert hasattr(observer_module, "__all__")
          assert set(observer_module.__all__) == expected_exports
      
      
      def test_observer_integration_with_state():
          """Observer kann mit UfoState arbeiten."""
          from core.simulation.observer import StateObserver, compute_phase
          from core.simulation.state import UfoState
      
          # State erstellen
          state = UfoState(z=10.0, v=10.0, ftime=5.0, dist=20.0)
      
          # compute_phase sollte funktionieren
          phase = compute_phase(state)
          assert phase == "flying"
      
          # Observer sollte State akzeptieren
          observer = StateObserver()
          observer.observe(state)
          assert len(observer.history) == 1
      
          # Analyse sollte funktionieren
          analysis = observer.analyze()
          assert analysis.phase == "flying"
      
      
      def test_observer_uses_config_thresholds():
          """Observer verwendet Config-Schwellenwerte korrekt."""
          from core.simulation.infrastructure import SimulationConfig
          from core.simulation.observer import StateObserver
      
          config = SimulationConfig(
              observer_history_size=100,
              climb_vz_threshold_ms=1.0,
              descent_vz_threshold_ms=-1.0,
              turn_heading_threshold_deg=10.0,
          )
      
          observer = StateObserver(config)
      
          # Config sollte gesetzt sein
          assert observer.config.observer_history_size == 100
          assert observer.config.climb_vz_threshold_ms == 1.0
          assert observer.config.descent_vz_threshold_ms == -1.0
          assert observer.config.turn_heading_threshold_deg == 10.0
      
          # History maxlen sollte von Config kommen
          assert observer.history.maxlen == 100
      
      def test_observer_does_not_modify_state():
          """Observer modifiziert empfangene States nicht."""
          from core.simulation.observer import StateObserver
          from core.simulation.state import UfoState
      
          observer = StateObserver()
      
          # Originaler State
          original = UfoState(x=10.0, y=20.0, z=5.0, v=10.0)
      
          # Observer beobachtet
          observer.observe(original)
      
          # Observer erstellt Kopie
          observed = observer.history[0]
      
          # Werte sind gleich
          assert observed.x == original.x
          assert observed.y == original.y
      
          # Aber es sind unterschiedliche Objekte (defensive Kopie)
          # (frozen dataclass kann nicht modifiziert werden, aber Prinzip bleibt)
          assert observed is not original
  - rel_path: tests/core/simulation/physics/test_physics_engine.py
    hash: acfcebbd1c52ae132915bbed250c3f50893901edeb6004299ea72d82e3a1d1a3
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """
      Unit-Tests für PhysicsEngine.
      
      Testet die physikalische Integrationslogik der UFO-Simulation isoliert.
      """
      
      import sys
      from pathlib import Path
      
      # Sicherstellen, dass src/ im Python-Pfad ist  # noqa: E402
      src_path = Path(__file__).parent.parent / "src"
      sys.path.insert(0, str(src_path))
      
      import pytest  # noqa: E402
      
      from core.simulation.physics import PhysicsEngine  # noqa: E402
      from core.simulation.state import UfoState  # noqa: E402
      from core.simulation.infrastructure import SimulationConfig, DEFAULT_CONFIG  # noqa: E402
      
      
      class TestPhysicsEngineImport:
          """Tests für Modul-Import und Initialisierung."""
      
          def test_physics_engine_can_be_imported(self):
              """Smoke-Test: PhysicsEngine kann importiert werden."""
              from core.simulation.physics import PhysicsEngine
              assert PhysicsEngine is not None
      
          def test_physics_engine_can_be_instantiated(self):
              """PhysicsEngine kann mit Default-Config instantiiert werden."""
              engine = PhysicsEngine()
              assert engine is not None
              assert engine.config == DEFAULT_CONFIG
      
          def test_physics_engine_can_be_instantiated_with_custom_config(self):
              """PhysicsEngine kann mit Custom-Config instantiiert werden."""
              config = SimulationConfig(dt=0.05, vmax_kmh=200.0)
              engine = PhysicsEngine(config)
              assert engine is not None
              assert engine.config.dt == 0.05
              assert engine.config.vmax_kmh == 200.0
      
      
      class TestPhysicsEngineVelocityUpdate:
          """Tests für Geschwindigkeits-Updates."""
      
          def test_update_velocity_increases_when_delta_v_positive(self):
              """Geschwindigkeit steigt bei positivem delta_v."""
              engine = PhysicsEngine()
              state = UfoState(v=10.0, delta_v=5.0)
      
              updated = engine._update_velocity(state)
      
              # Geschwindigkeit sollte um acceleration_kmh_per_step gestiegen sein
              assert updated.v > state.v
              assert updated.delta_v < state.delta_v
      
          def test_update_velocity_decreases_when_delta_v_negative(self):
              """Geschwindigkeit sinkt bei negativem delta_v."""
              engine = PhysicsEngine()
              state = UfoState(v=50.0, delta_v=-10.0)
      
              updated = engine._update_velocity(state)
      
              # Geschwindigkeit sollte gesunken sein
              assert updated.v < state.v
              assert updated.delta_v > state.delta_v
      
          def test_update_velocity_respects_max_velocity(self):
              """Geschwindigkeit wird auf vmax_kmh begrenzt."""
              config = SimulationConfig(vmax_kmh=100.0)
              engine = PhysicsEngine(config)
              state = UfoState(v=99.0, delta_v=50.0)
      
              updated = engine._update_velocity(state)
      
              # Geschwindigkeit darf vmax_kmh nicht überschreiten
              assert updated.v <= config.vmax_kmh
      
          def test_update_velocity_respects_min_velocity_zero(self):
              """Geschwindigkeit wird nicht negativ."""
              engine = PhysicsEngine()
              state = UfoState(v=1.0, delta_v=-50.0)
      
              updated = engine._update_velocity(state)
      
              # Geschwindigkeit darf nicht unter 0 fallen
              assert updated.v >= 0.0
      
          def test_update_velocity_no_change_when_delta_v_zero(self):
              """Keine Änderung bei delta_v=0."""
              engine = PhysicsEngine()
              state = UfoState(v=50.0, delta_v=0.0)
      
              updated = engine._update_velocity(state)
      
              assert updated.v == state.v
              assert updated.delta_v == state.delta_v
      
      
      class TestPhysicsEngineDirectionUpdate:
          """Tests für Richtungs-Updates."""
      
          def test_update_direction_wraps_at_360(self):
              """Richtung wird bei 360° auf 0° zurückgesetzt."""
              engine = PhysicsEngine()
              state = UfoState(d=350.0, delta_d=20.0)
      
              updated = engine._update_direction(state)
      
              # 350 + 20 = 370, soll auf 10 wrappen
              assert 0.0 <= updated.d < 360.0
              assert updated.delta_d == 0.0
      
          def test_update_direction_no_change_when_delta_d_zero(self):
              """Keine Änderung bei delta_d=0."""
              engine = PhysicsEngine()
              state = UfoState(d=90.0, delta_d=0.0)
      
              updated = engine._update_direction(state)
      
              assert updated.d == state.d
              assert updated.delta_d == state.delta_d
      
      
      class TestPhysicsEngineInclinationUpdate:
          """Tests für Neigungs-Updates."""
      
          def test_update_inclination_increases_when_delta_i_positive(self):
              """Neigung steigt bei positivem delta_i."""
              engine = PhysicsEngine()
              state = UfoState(i=0.0, delta_i=10.0)
      
              updated = engine._update_inclination(state)
      
              assert updated.i > state.i
              assert updated.delta_i < state.delta_i
      
          def test_update_inclination_decreases_when_delta_i_negative(self):
              """Neigung sinkt bei negativem delta_i."""
              engine = PhysicsEngine()
              state = UfoState(i=0.0, delta_i=-10.0)
      
              updated = engine._update_inclination(state)
      
              assert updated.i < state.i
              assert updated.delta_i > state.delta_i
      
          def test_update_inclination_respects_max_limit(self):
              """Neigung wird auf inclination_max_deg begrenzt."""
              config = SimulationConfig(inclination_max_deg=90)
              engine = PhysicsEngine(config)
              state = UfoState(i=89.0, delta_i=50.0)
      
              updated = engine._update_inclination(state)
      
              assert updated.i <= config.inclination_max_deg
      
          def test_update_inclination_respects_min_limit(self):
              """Neigung wird auf inclination_min_deg begrenzt."""
              config = SimulationConfig(inclination_min_deg=-90)
              engine = PhysicsEngine(config)
              state = UfoState(i=-89.0, delta_i=-50.0)
      
              updated = engine._update_inclination(state)
      
              assert updated.i >= config.inclination_min_deg
      
          def test_update_inclination_no_change_when_delta_i_zero(self):
              """Keine Änderung bei delta_i=0."""
              engine = PhysicsEngine()
              state = UfoState(i=45.0, delta_i=0.0)
      
              updated = engine._update_inclination(state)
      
              assert updated.i == state.i
              assert updated.delta_i == state.delta_i
      
      
      class TestPhysicsEnginePositionUpdate:
          """Tests für Positions-Updates."""
      
          def test_update_position_with_zero_velocity(self):
              """Position ändert sich nicht bei Geschwindigkeit=0."""
              engine = PhysicsEngine()
              state = UfoState(x=0.0, y=0.0, z=10.0, v=0.0, vel=0.0)
      
              updated, result = engine._update_position(state)
      
              assert updated.x == state.x
              assert updated.y == state.y
              # z könnte sich bei geringer Höhe ändern (touchdown)
              assert result in ["continue", "landed"]
      
          def test_update_position_changes_with_nonzero_velocity(self):
              """Position ändert sich bei Geschwindigkeit>0."""
              from dataclasses import replace
      
              config = SimulationConfig(dt=1.0)  # 1 Sekunde für einfachere Berechnung
              engine = PhysicsEngine(config)
              # Horizontaler Flug: i=0, d=0 (Nord), v=36 km/h = 10 m/s
              state = UfoState(x=0.0, y=0.0, z=100.0, v=36.0, i=0.0, d=0.0)
              state = replace(state, vel=10.0)  # vel in m/s setzen
      
              updated, result = engine._update_position(state)
      
              # Position sollte sich geändert haben
              assert updated.x != state.x or updated.y != state.y or updated.z != state.z
              assert result == "continue"  # Noch in der Luft
      
          def test_update_position_detects_landing(self):
              """Landung wird erkannt wenn z <= 0."""
              engine = PhysicsEngine()
              # Zustand knapp über Boden mit Abwärtsbewegung
              state = UfoState(
                  x=0.0, y=0.0, z=0.1,
                  v=10.0, vel=2.78, i=-45.0, d=0.0,  # Sinkflug
                  vz=-2.0  # Vertikale Geschwindigkeit nach unten
              )
      
              updated, result = engine._update_position(state)
      
              if result == "landed":
                  # Bei Landung sollte z <= 0 sein
                  assert updated.z <= 0.0
                  # Geschwindigkeiten sollten auf 0 gesetzt sein
                  assert updated.vel == 0.0
                  assert updated.v == 0.0
      
      
      class TestPhysicsEngineLandingHandling:
          """Tests für Landungs-Behandlung."""
      
          def test_handle_landing_safe_landing(self):
              """Sichere Landung wird korrekt erkannt."""
              engine = PhysicsEngine()
      
              # Sicherer Zustand: langsam, geringe Sinkrate, akzeptable Neigung
              # Verwende Werte unterhalb der Standard-Schwellenwerte
              state = UfoState(
                  x=10.0, y=20.0, z=0.0,
                  v=0.5, vel=0.14,  # Sehr langsam, unter safe_landing_v_threshold
                  vz=-0.1,  # Geringe Sinkrate
                  i=-15.0  # Sanfter Sinkflug
              )
      
              updated = engine._handle_landing(state)
      
              # Sichere Landung: z sollte exakt 0.0 sein (nicht negativ)
              assert updated.z == 0.0
              assert updated.vel == 0.0
              assert updated.v == 0.0
      
          def test_handle_landing_crash_high_velocity(self):
              """Crash bei zu hoher Geschwindigkeit."""
              engine = PhysicsEngine()
      
              # Unsicher: zu schnell (über safe_landing_v_threshold_kmh)
              state = UfoState(
                  x=10.0, y=20.0, z=0.0,
                  v=50.0, vel=13.89,  # ~50 km/h = 13.89 m/s (zu schnell!)
                  vz=-1.0,
                  i=-15.0
              )
      
              updated = engine._handle_landing(state)
      
              # Crash: z sollte negativ sein (Crash-Marker)
              assert updated.z < 0.0
              assert updated.vel == 0.0
              assert updated.v == 0.0
      
          def test_handle_landing_crash_high_vertical_velocity(self):
              """Crash bei zu hoher Sinkrate."""
              engine = PhysicsEngine()
      
              # Unsicher: zu steile Sinkrate (über safe_landing_max_vz_ms)
              state = UfoState(
                  x=10.0, y=20.0, z=0.0,
                  v=0.5, vel=0.14,  # Langsam
                  vz=-5.0,  # Zu schnelle Sinkrate!
                  i=-15.0
              )
      
              updated = engine._handle_landing(state)
      
              # Crash
              assert updated.z < 0.0
      
          def test_handle_landing_crash_unsafe_inclination(self):
              """Crash bei unsicherer Neigung."""
              engine = PhysicsEngine()
      
              # Unsicher: zu steile Neigung (nicht vertikal genug für vertikale Landung)
              state = UfoState(
                  x=10.0, y=20.0, z=0.0,
                  v=0.5, vel=0.14,  # Langsam
                  vz=-0.1,  # Geringe Sinkrate
                  i=-45.0  # Zu steil, nicht vertikal genug!
              )
      
              updated = engine._handle_landing(state)
      
              # Crash
              assert updated.z < 0.0
      
      
      class TestPhysicsEngineLandingAssistance:
          """Tests für automatische Landungsassistenz."""
      
          def test_landing_assistance_not_active_when_high_altitude(self):
              """Landungsassistenz ist nicht aktiv bei großer Höhe."""
              engine = PhysicsEngine()
              state = UfoState(z=100.0, v=50.0)
      
              updated = engine._apply_landing_assistance(state)
      
              # Keine Änderung
              assert updated == state
      
          def test_landing_assistance_not_active_when_user_controlling(self):
              """Landungsassistenz ist nicht aktiv bei Benutzersteuerung."""
              engine = PhysicsEngine()
              # In Landehöhe aber Benutzer steuert
              state = UfoState(z=1.5, v=50.0, delta_v=5.0)  # Benutzer steuert
      
              updated = engine._apply_landing_assistance(state)
      
              # Keine Assistenz wegen Benutzersteuerung
              assert updated == state
      
          def test_landing_assistance_reduces_velocity(self):
              """Landungsassistenz reduziert zu hohe Geschwindigkeit."""
              engine = PhysicsEngine()
              # In Landehöhe, keine Benutzersteuerung, zu schnell
              state = UfoState(z=1.5, v=50.0, delta_v=0.0, delta_i=0.0, delta_d=0.0)
      
              updated = engine._apply_landing_assistance(state)
      
              # Geschwindigkeitsreduktion sollte aktiviert sein
              assert updated.delta_v < 0.0  # Bremsen
      
          def test_landing_assistance_corrects_inclination_too_shallow(self):
              """Landungsassistenz korrigiert zu flache Neigung."""
              engine = PhysicsEngine()
              # Zu flach (i=0), sollte steiler werden
              state = UfoState(z=1.5, v=10.0, i=0.0, delta_v=0.0, delta_i=0.0, delta_d=0.0)
      
              updated = engine._apply_landing_assistance(state)
      
              # Neigung sollte steiler gemacht werden (delta_i negativ)
              # Aber nur wenn Assistenz aktiv ist - das hängt von weiteren Bedingungen ab
              # Prüfen dass entweder Assistenz aktiv ist oder State unverändert
              if updated != state:
                  # Wenn Assistenz aktiv, sollte delta_i gesetzt sein
                  assert hasattr(updated, 'delta_i')
      
      
      class TestPhysicsEngineIntegrateStep:
          """Tests für vollständigen Integrationsschritt."""
      
          def test_integrate_step_returns_correct_tuple(self):
              """integrate_step gibt korrektes Tupel zurück."""
              engine = PhysicsEngine()
              state = UfoState()
      
              result = engine.integrate_step(state)
      
              assert isinstance(result, tuple)
              assert len(result) == 3
              new_state, continues, landed = result
              assert isinstance(new_state, UfoState)
              assert isinstance(continues, bool)
              assert isinstance(landed, bool)
      
          def test_integrate_step_ascent_scenario(self):
              """Steigflug-Szenario: UFO steigt auf."""
              engine = PhysicsEngine()
              state = UfoState(
                  z=50.0,
                  v=50.0, vel=13.89,
                  i=45.0,  # Steigflug
                  d=0.0
              )
      
              new_state, continues, landed = engine.integrate_step(state)
      
              # Simulation sollte weiterlaufen
              assert continues is True
              assert landed is False
              # Flugzeit sollte erhöht worden sein
              assert new_state.ftime > state.ftime
      
          def test_integrate_step_descent_scenario(self):
              """Sinkflug-Szenario: UFO sinkt."""
              engine = PhysicsEngine()
              state = UfoState(
                  z=100.0,
                  v=30.0, vel=8.33,
                  i=-30.0,  # Sinkflug
                  d=0.0
              )
      
              new_state, continues, landed = engine.integrate_step(state)
      
              # Simulation sollte weiterlaufen
              assert continues is True
              assert landed is False
      
          def test_integrate_step_landing_scenario(self):
              """Landungs-Szenario: UFO landet."""
              config = SimulationConfig(dt=0.5)
              engine = PhysicsEngine(config)
              # Knapp über Boden, langsam, sichere Neigung
              state = UfoState(
                  z=0.05,
                  v=5.0, vel=1.39,
                  vz=-0.5,
                  i=-15.0,
                  d=0.0
              )
      
              # Initialisiere Variablen vor Schleife
              new_state = state
              continues = True
              landed = False
      
              # Mehrere Schritte ausführen bis Landung
              for _ in range(5):
                  new_state, continues, landed = engine.integrate_step(state)
                  if landed:
                      break
                  state = new_state
      
              # Landung sollte erfolgt sein - je nach exaktem Zustand kann dies
              # entweder durch landed-Flag oder durch Boden-Kontakt (z <= 0) angezeigt werden
              # Prüfe zuerst das landed-Flag
              if landed:
                  # Wenn landed-Flag gesetzt ist, sollte Simulation auch stoppen
                  assert continues is False
              else:
                  # Wenn nicht landed, muss UFO zumindest den Boden berührt haben
                  assert new_state.z <= 0.0
      
          def test_integrate_step_increments_flight_time_when_airborne(self):
              """Flugzeit wird erhöht wenn in der Luft."""
              config = SimulationConfig(dt=0.1)
              engine = PhysicsEngine(config)
              state = UfoState(z=100.0, ftime=5.0)
      
              new_state, _, _ = engine.integrate_step(state)
      
              # Flugzeit sollte um dt erhöht sein
              assert new_state.ftime == pytest.approx(5.1, abs=0.01)
      
          def test_integrate_step_does_not_increment_flight_time_on_ground(self):
              """Flugzeit wird nicht erhöht wenn am Boden."""
              config = SimulationConfig(dt=0.1)
              engine = PhysicsEngine(config)
              state = UfoState(z=0.0, ftime=10.0)  # Am Boden
      
              new_state, _, _ = engine.integrate_step(state)
      
              # Flugzeit sollte unverändert sein
              assert new_state.ftime == state.ftime
      
      
      class TestPhysicsEngineImmutability:
          """Tests für Immutability - State wird nie in-place modifiziert."""
      
          def test_integrate_step_does_not_modify_input_state(self):
              """integrate_step modifiziert Input-State nicht."""
              from dataclasses import asdict
      
              engine = PhysicsEngine()
              original_state = UfoState(z=50.0, v=30.0, i=45.0)
              original_dict = asdict(original_state)
      
              new_state, _, _ = engine.integrate_step(original_state)
      
              # Original-State sollte unverändert sein
              assert asdict(original_state) == original_dict
              # Neuer State sollte unterschiedlich sein
              assert new_state is not original_state
      
          def test_private_methods_do_not_modify_input_state(self):
              """Private Methoden modifizieren Input-State nicht."""
              from dataclasses import asdict
      
              engine = PhysicsEngine()
              original_state = UfoState(v=50.0, delta_v=10.0)
              original_dict = asdict(original_state)
      
              _ = engine._update_velocity(original_state)
      
              # Original-State sollte unverändert sein
              assert asdict(original_state) == original_dict
  - rel_path: tests/core/simulation/state/test_manager.py
    hash: 2f584ec2adffbdb7f20d9e85619711063a703314c5d42626bef93a8bd9bd4d87
    content: "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"Unit-Tests für StateManager\
    \ (state/manager.py).\"\"\"\n\nimport threading\nimport time\nfrom dataclasses import\
    \ replace\n\nimport pytest\n\nfrom core.simulation.state import StateManager, UfoState\n\
    \n\nclass TestStateManagerInitialization:\n    \"\"\"Tests für StateManager-Initialisierung.\"\
    \"\"\n\n    def test_default_initialization(self):\n        \"\"\"StateManager initialisiert\
    \ mit Default-UfoState.\"\"\"\n        manager = StateManager()\n        snapshot = manager.get_snapshot()\n\
    \        \n        assert snapshot.x == 0.0\n        assert snapshot.y == 0.0\n      \
    \  assert snapshot.z == 0.0\n        assert snapshot.v == 0.0\n\n    def test_custom_initial_state(self):\n\
    \        \"\"\"StateManager akzeptiert custom initial State.\"\"\"\n        initial_state\
    \ = UfoState(x=10.0, y=20.0, z=30.0, v=50.0)\n        manager = StateManager(initial_state=initial_state)\n\
    \        snapshot = manager.get_snapshot()\n        \n        assert snapshot.x == 10.0\n\
    \        assert snapshot.y == 20.0\n        assert snapshot.z == 30.0\n        assert\
    \ snapshot.v == 50.0\n\n\nclass TestStateManagerSnapshot:\n    \"\"\"Tests für get_snapshot()-Methode.\"\
    \"\"\n\n    def test_get_snapshot_returns_copy(self):\n        \"\"\"get_snapshot() liefert\
    \ defensive Kopie.\"\"\"\n        manager = StateManager()\n        snapshot1 = manager.get_snapshot()\n\
    \        snapshot2 = manager.get_snapshot()\n        \n        # Beide Snapshots sind\
    \ Kopien, nicht dasselbe Objekt\n        assert snapshot1 is not snapshot2\n        \n\
    \        # Aber sie haben dieselben Werte\n        assert snapshot1.x == snapshot2.x\n\
    \        assert snapshot1.z == snapshot2.z\n\n    def test_snapshot_is_immutable(self):\n\
    \        \"\"\"Snapshot ist immutable (frozen dataclass).\"\"\"\n        manager = StateManager()\n\
    \        snapshot = manager.get_snapshot()\n        \n        # Frozen dataclass wirft\
    \ AttributeError bei direkter Änderung\n        with pytest.raises(AttributeError):\n\
    \            # noinspection PyDataclass\n            snapshot.x = 100.0  # type: ignore[misc,assignment]\n\
    \n    def test_snapshot_does_not_affect_manager_state(self):\n        \"\"\"Snapshot-Modifikation\
    \ beeinflusst Manager-State nicht.\"\"\"\n        manager = StateManager()\n        snapshot1\
    \ = manager.get_snapshot()\n        \n        # Neuen State aus Snapshot erstellen (replace)\n\
    \        modified = replace(snapshot1, x=999.0)\n        \n        # Manager-State ist\
    \ unverändert\n        snapshot2 = manager.get_snapshot()\n        assert snapshot2.x\
    \ == 0.0\n        assert modified.x == 999.0\n\n\nclass TestStateManagerUpdate:\n    \"\
    \"\"Tests für update_state()-Methode.\"\"\"\n\n    def test_update_state_applies_function(self):\n\
    \        \"\"\"update_state() wendet Funktion auf State an.\"\"\"\n        manager = StateManager()\n\
    \        \n        def move_up(state: UfoState) -> UfoState:\n            return replace(state,\
    \ z=state.z + 10.0)\n        \n        manager.update_state(move_up)\n        snapshot\
    \ = manager.get_snapshot()\n        \n        assert snapshot.z == 10.0\n\n    def test_update_state_is_atomic(self):\n\
    \        \"\"\"update_state() ist atomar - State ändert sich komplett oder gar nicht.\"\
    \"\"\n        manager = StateManager()\n        \n        def complex_update(state: UfoState)\
    \ -> UfoState:\n            return replace(state, x=100.0, y=200.0, z=300.0)\n       \
    \ \n        manager.update_state(complex_update)\n        snapshot = manager.get_snapshot()\n\
    \        \n        assert snapshot.x == 100.0\n        assert snapshot.y == 200.0\n  \
    \      assert snapshot.z == 300.0\n\n    def test_multiple_updates(self):\n        \"\"\
    \"Mehrere Updates werden sequenziell angewendet.\"\"\"\n        manager = StateManager()\n\
    \        \n        manager.update_state(lambda s: replace(s, z=10.0))\n        manager.update_state(lambda\
    \ s: replace(s, z=s.z + 5.0))\n        manager.update_state(lambda s: replace(s, z=s.z\
    \ * 2.0))\n        \n        snapshot = manager.get_snapshot()\n        assert snapshot.z\
    \ == 30.0  # (10 + 5) * 2\n\n\nclass TestObserverPattern:\n    \"\"\"Tests für Observer-Registrierung\
    \ und -Benachrichtigung.\"\"\"\n\n    def test_register_observer(self):\n        \"\"\"\
    Observer kann registriert werden.\"\"\"\n        manager = StateManager()\n        notifications\
    \ = []\n        \n        def observer(state: UfoState) -> None:\n            notifications.append(state.z)\n\
    \        \n        manager.register_observer(observer)\n        manager.update_state(lambda\
    \ s: replace(s, z=42.0))\n        \n        assert len(notifications) == 1\n        assert\
    \ notifications[0] == 42.0\n\n    def test_multiple_observers(self):\n        \"\"\"Mehrere\
    \ Observer werden alle benachrichtigt.\"\"\"\n        manager = StateManager()\n     \
    \   notifications1 = []\n        notifications2 = []\n        \n        def observer1(state:\
    \ UfoState) -> None:\n            notifications1.append(state.z)\n        \n        def\
    \ observer2(state: UfoState) -> None:\n            notifications2.append(state.x)\n  \
    \      \n        manager.register_observer(observer1)\n        manager.register_observer(observer2)\n\
    \        \n        manager.update_state(lambda s: replace(s, x=10.0, z=20.0))\n      \
    \  \n        assert len(notifications1) == 1\n        assert notifications1[0] == 20.0\n\
    \        assert len(notifications2) == 1\n        assert notifications2[0] == 10.0\n\n\
    \    def test_observer_receives_snapshot(self):\n        \"\"\"Observer erhält Snapshot,\
    \ nicht Original-State.\"\"\"\n        manager = StateManager()\n        received_states\
    \ = []\n        \n        def observer(state: UfoState) -> None:\n            received_states.append(state)\n\
    \        \n        manager.register_observer(observer)\n        manager.update_state(lambda\
    \ s: replace(s, z=100.0))\n        \n        assert len(received_states) == 1\n      \
    \  # Snapshot kann nicht den Manager-State beeinflussen\n        assert received_states[0].z\
    \ == 100.0\n\n    def test_duplicate_observer_registration_ignored(self):\n        \"\"\
    \"Mehrfache Registrierung desselben Observers wird ignoriert.\"\"\"\n        manager =\
    \ StateManager()\n        notification_count = [0]\n        \n        def observer(_:\
    \ UfoState) -> None:\n            notification_count[0] += 1\n        \n        manager.register_observer(observer)\n\
    \        manager.register_observer(observer)  # Duplikat\n        manager.register_observer(observer)\
    \  # Duplikat\n        \n        manager.update_state(lambda s: replace(s, z=1.0))\n \
    \       \n        # Observer sollte nur einmal registriert sein\n        assert notification_count[0]\
    \ == 1\n\n    def test_unregister_observer(self):\n        \"\"\"Observer kann deregistriert\
    \ werden.\"\"\"\n        manager = StateManager()\n        notifications = []\n      \
    \  \n        def observer(state: UfoState) -> None:\n            notifications.append(state.z)\n\
    \        \n        manager.register_observer(observer)\n        manager.update_state(lambda\
    \ s: replace(s, z=10.0))\n        \n        manager.unregister_observer(observer)\n  \
    \      manager.update_state(lambda s: replace(s, z=20.0))\n        \n        # Nur erste\
    \ Benachrichtigung sollte angekommen sein\n        assert len(notifications) == 1\n  \
    \      assert notifications[0] == 10.0\n\n    def test_observer_exception_does_not_break_others(self):\n\
    \        \"\"\"Exception in einem Observer bricht andere Observer nicht ab.\"\"\"\n  \
    \      manager = StateManager()\n        notifications1 = []\n        notifications2 =\
    \ []\n        \n        def failing_observer(_: UfoState) -> None:\n            raise\
    \ RuntimeError(\"Simulated observer error\")\n        \n        def working_observer1(state:\
    \ UfoState) -> None:\n            notifications1.append(state.z)\n        \n        def\
    \ working_observer2(state: UfoState) -> None:\n            notifications2.append(state.z)\n\
    \        \n        manager.register_observer(working_observer1)\n        manager.register_observer(failing_observer)\n\
    \        manager.register_observer(working_observer2)\n        \n        manager.update_state(lambda\
    \ s: replace(s, z=42.0))\n        \n        # Beide funktionierenden Observer sollten\
    \ benachrichtigt worden sein\n        assert len(notifications1) == 1\n        assert\
    \ len(notifications2) == 1\n\n\nclass TestWaitForCondition:\n    \"\"\"Tests für wait_for_condition()-Methode.\"\
    \"\"\n\n    def test_wait_for_condition_fulfilled_immediately(self):\n        \"\"\"wait_for_condition()\
    \ kehrt sofort zurück wenn bereits erfüllt.\"\"\"\n        manager = StateManager()\n\
    \        manager.update_state(lambda s: replace(s, z=100.0))\n        \n        result\
    \ = manager.wait_for_condition(lambda s: s.z >= 50.0, timeout=1.0)\n        \n       \
    \ assert result is True\n\n    def test_wait_for_condition_fulfilled_after_update(self):\n\
    \        \"\"\"wait_for_condition() wartet auf Update.\"\"\"\n        manager = StateManager()\n\
    \        result_container = []\n        \n        def waiter():\n            result =\
    \ manager.wait_for_condition(lambda s: s.z >= 50.0, timeout=5.0)\n            result_container.append(result)\n\
    \        \n        # Thread starten der wartet\n        wait_thread = threading.Thread(target=waiter)\n\
    \        wait_thread.start()\n        \n        # Kurz warten, dann Bedingung erfüllen\n\
    \        time.sleep(0.1)\n        manager.update_state(lambda s: replace(s, z=100.0))\n\
    \        \n        # Thread sollte terminieren\n        wait_thread.join(timeout=2.0)\n\
    \        \n        assert len(result_container) == 1\n        assert result_container[0]\
    \ is True\n\n    def test_wait_for_condition_timeout(self):\n        \"\"\"wait_for_condition()\
    \ gibt False bei Timeout zurück.\"\"\"\n        manager = StateManager()\n        \n \
    \       start_time = time.time()\n        result = manager.wait_for_condition(lambda s:\
    \ s.z >= 1000.0, timeout=0.5)\n        elapsed = time.time() - start_time\n        \n\
    \        assert result is False\n        assert 0.4 <= elapsed <= 0.7  # Timeout sollte\
    \ eingehalten werden\n\n    def test_wait_for_condition_without_timeout(self):\n     \
    \   \"\"\"wait_for_condition() wartet unbegrenzt ohne Timeout.\"\"\"\n        manager\
    \ = StateManager()\n        result_container = []\n        \n        def waiter():\n \
    \           result = manager.wait_for_condition(lambda s: s.z >= 50.0)\n            result_container.append(result)\n\
    \        \n        # Thread starten der wartet\n        wait_thread = threading.Thread(target=waiter,\
    \ daemon=True)\n        wait_thread.start()\n        \n        # Kurz warten, dann Bedingung\
    \ erfüllen\n        time.sleep(0.1)\n        manager.update_state(lambda s: replace(s,\
    \ z=100.0))\n        \n        # Thread sollte terminieren\n        wait_thread.join(timeout=2.0)\n\
    \        \n        assert len(result_container) == 1\n        assert result_container[0]\
    \ is True\n\n\nclass TestReset:\n    \"\"\"Tests für reset()-Methode.\"\"\"\n\n    def\
    \ test_reset_clears_state(self):\n        \"\"\"reset() setzt State auf Default zurück.\"\
    \"\"\n        manager = StateManager()\n        \n        # State modifizieren\n     \
    \   manager.update_state(lambda s: replace(s, x=100.0, y=200.0, z=300.0))\n        \n\
    \        # Reset\n        manager.reset()\n        \n        # State sollte wieder Default\
    \ sein\n        snapshot = manager.get_snapshot()\n        assert snapshot.x == 0.0\n\
    \        assert snapshot.y == 0.0\n        assert snapshot.z == 0.0\n\n    def test_reset_notifies_waiters(self):\n\
    \        \"\"\"reset() weckt wartende Threads auf.\"\"\"\n        manager = StateManager()\n\
    \        manager.update_state(lambda s: replace(s, z=50.0))\n        \n        result_container\
    \ = []\n        \n        def waiter():\n            # Wartet auf z == 0 (nur durch reset\
    \ erreichbar)\n            result = manager.wait_for_condition(lambda s: s.z == 0.0, timeout=5.0)\n\
    \            result_container.append(result)\n        \n        wait_thread = threading.Thread(target=waiter)\n\
    \        wait_thread.start()\n        \n        time.sleep(0.1)\n        manager.reset()\n\
    \        \n        wait_thread.join(timeout=2.0)\n        \n        assert len(result_container)\
    \ == 1\n        assert result_container[0] is True\n\n    def test_reset_notifies_observers(self):\n\
    \        \"\"\"reset() benachrichtigt alle Observer.\"\"\"\n        manager = StateManager()\n\
    \        notifications = []\n        \n        def observer(state: UfoState) -> None:\n\
    \            notifications.append(state.z)\n        \n        manager.register_observer(observer)\n\
    \        \n        # Erste Änderung\n        manager.update_state(lambda s: replace(s,\
    \ z=100.0))\n        \n        # Reset sollte Observer benachrichtigen\n        manager.reset()\n\
    \        \n        # Observer sollte zweimal benachrichtigt worden sein (update + reset)\n\
    \        assert len(notifications) == 2\n        assert notifications[0] == 100.0\n  \
    \      assert notifications[1] == 0.0  # Nach reset ist z wieder 0\n\n\n\nclass TestThreadSafety:\n\
    \    \"\"\"Tests für Thread-Safety.\"\"\"\n\n    def test_concurrent_updates(self):\n\
    \        \"\"\"Mehrere Threads können gleichzeitig updaten.\"\"\"\n        manager = StateManager()\n\
    \        num_threads = 10\n        updates_per_thread = 100\n        \n        def updater():\n\
    \            for _ in range(updates_per_thread):\n                manager.update_state(lambda\
    \ s: replace(s, z=s.z + 1.0))\n        \n        threads = [threading.Thread(target=updater)\
    \ for _ in range(num_threads)]\n        \n        for t in threads:\n            t.start()\n\
    \        \n        for t in threads:\n            t.join(timeout=5.0)\n        \n    \
    \    # Alle Updates sollten atomar ausgeführt worden sein\n        snapshot = manager.get_snapshot()\n\
    \        expected = num_threads * updates_per_thread\n        assert snapshot.z == expected\n\
    \n    def test_concurrent_reads_and_writes(self):\n        \"\"\"Lesezugriffe während\
    \ Updates sind thread-sicher.\"\"\"\n        manager = StateManager()\n        read_count\
    \ = [0]\n        stop_flag = threading.Event()\n        \n        def reader():\n    \
    \        while not stop_flag.is_set():\n                snapshot = manager.get_snapshot()\n\
    \                # Snapshot sollte immer konsistent sein (z >= 0)\n                assert\
    \ snapshot.z >= 0.0\n                read_count[0] += 1\n                time.sleep(0.001)\n\
    \        \n        def writer():\n            for i in range(50):\n                manager.update_state(lambda\
    \ s: replace(s, z=float(i)))\n                time.sleep(0.01)\n        \n        reader_thread\
    \ = threading.Thread(target=reader)\n        writer_thread = threading.Thread(target=writer)\n\
    \        \n        reader_thread.start()\n        writer_thread.start()\n        \n  \
    \      writer_thread.join(timeout=5.0)\n        stop_flag.set()\n        reader_thread.join(timeout=2.0)\n\
    \        \n        # Reader sollte viele Snapshots gelesen haben\n        assert read_count[0]\
    \ > 10\n\n\nclass TestLegacyStateProperty:\n    \"\"\"Tests für Legacy-Property state.\"\
    \"\"\n\n    def test_state_property_returns_internal_state(self):\n        \"\"\"state-Property\
    \ gibt internen State zurück.\"\"\"\n        manager = StateManager()\n        manager.update_state(lambda\
    \ s: replace(s, z=42.0))\n        \n        # Legacy-Zugriff\n        state = manager.state\n\
    \        \n        assert state.z == 42.0\n\n    def test_state_property_is_not_thread_safe(self):\n\
    \        \"\"\"state-Property ist nicht thread-sicher (dokumentiert).\"\"\"\n        #\
    \ Dies ist ein dokumentiertes Verhalten - kein Test nötig\n        # Property existiert\
    \ nur für Legacy-Kompatibilität\n        manager = StateManager()\n        assert hasattr(manager,\
    \ 'state')\n\n\nclass TestStateManagerIntegration:\n    \"\"\"Integrationstests für StateManager.\"\
    \"\"\n\n    def test_full_workflow_with_observers_and_waiting(self):\n        \"\"\"Vollständiger\
    \ Workflow: Observer + wait_for_condition.\"\"\"\n        manager = StateManager()\n \
    \       notifications = []\n        \n        def observer(state: UfoState) -> None:\n\
    \            notifications.append(state.z)\n        \n        manager.register_observer(observer)\n\
    \        \n        # Simuliere Flug bis Ziel-Höhe\n        result_container = []\n   \
    \     \n        def waiter():\n            result = manager.wait_for_condition(lambda\
    \ s: s.z >= 100.0, timeout=5.0)\n            result_container.append(result)\n       \
    \ \n        wait_thread = threading.Thread(target=waiter)\n        wait_thread.start()\n\
    \        \n        # Simuliere graduelle Höhenänderung\n        for i in range(11):\n\
    \            manager.update_state(lambda s: replace(s, z=s.z + 10.0))\n            time.sleep(0.05)\n\
    \        \n        wait_thread.join(timeout=2.0)\n        \n        # Observer sollte\
    \ alle Updates erhalten haben\n        assert len(notifications) == 11\n        assert\
    \ notifications[-1] == 110.0\n        \n        # Waiter sollte erfolgreich gewesen sein\n\
    \        assert len(result_container) == 1\n        assert result_container[0] is True\n\
    \n\n@pytest.mark.threading\nclass TestDeadlockPrevention:\n    \"\"\"Tests zur Deadlock-Vermeidung.\"\
    \"\"\n\n    def test_no_deadlock_with_observer_calling_get_snapshot(self):\n        \"\
    \"\"Observer kann get_snapshot() aufrufen ohne Deadlock.\"\"\"\n        manager = StateManager()\n\
    \        snapshots_in_observer = []\n        \n        def observer(_: UfoState) -> None:\n\
    \            # Observer ruft get_snapshot() auf\n            # (wird außerhalb Lock benachrichtigt,\
    \ daher kein Deadlock)\n            snapshot = manager.get_snapshot()\n            snapshots_in_observer.append(snapshot.z)\n\
    \        \n        manager.register_observer(observer)\n        manager.update_state(lambda\
    \ s: replace(s, z=42.0))\n        \n        assert len(snapshots_in_observer) == 1\n \
    \       assert snapshots_in_observer[0] == 42.0\n"
  - rel_path: tests/core/simulation/state/test_state_import.py
    hash: d03f03b08f370e0844456a21de1c97fc4171590c14762d712ef16b740d90db07
    content: "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nSmoke-Test für core.simulation.state\
    \ Modul.\n\nTestet grundlegende Import- und Instanziierungsfähigkeit von UfoState.\n\"\
    \"\"\n\nimport sys\nfrom pathlib import Path\n\n# Sicherstellen, dass src/ im Python-Pfad\
    \ ist\nsrc_path = Path(__file__).parent.parent / \"src\"\nsys.path.insert(0, str(src_path))\n\
    \n\ndef test_state_import():\n    \"\"\"Test: UfoState kann importiert werden.\"\"\"\n\
    \    from core.simulation.state import UfoState\n    assert UfoState is not None\n\n\n\
    def test_state_instantiation_defaults():\n    \"\"\"Test: UfoState kann mit Defaults instanziiert\
    \ werden - robuste Invarianten.\"\"\"\n    from core.simulation.state import UfoState\n\
    \    \n    state = UfoState()\n    assert state is not None\n    \n    # Position initial\
    \ bei Null\n    assert state.x == 0.0\n    assert state.y == 0.0\n    assert state.z ==\
    \ 0.0\n    \n    # Geschwindigkeitskomponenten initial bei Null\n    assert state.vx ==\
    \ 0.0\n    assert state.vy == 0.0\n    assert state.vz == 0.0\n    \n    # Beschleunigungskomponenten\
    \ initial bei Null\n    assert state.accel_x == 0.0\n    assert state.accel_y == 0.0\n\
    \    assert state.accel_z == 0.0\n    \n    # Statistik initial bei Null\n    assert state.dist\
    \ == 0.0\n    assert state.ftime == 0.0\n    \n    # Winkel in gültigem Wertebereich (nicht\
    \ auf spezifische Werte festgelegt)\n    assert 0.0 <= state.d < 360.0\n    assert 0.0\
    \ <= state.i <= 180.0\n\n\ndef test_state_instantiation_custom():\n    \"\"\"Test: UfoState\
    \ kann mit benutzerdefinierten Werten instanziiert werden.\"\"\"\n    from core.simulation.state\
    \ import UfoState\n    \n    state = UfoState(\n        x=100.0,\n        y=200.0,\n \
    \       z=50.0,\n        v=72.0,\n        d=45.0,\n        i=60.0\n    )\n    \n    assert\
    \ state.x == 100.0\n    assert state.y == 200.0\n    assert state.z == 50.0\n    assert\
    \ state.v == 72.0\n    assert state.d == 45.0\n    assert state.i == 60.0\n\n\ndef test_state_vector_properties():\n\
    \    \"\"\"Test: UfoState-Properties liefern korrekte NumPy-Arrays.\"\"\"\n    from core.simulation.state\
    \ import UfoState\n    import numpy as np\n    \n    state = UfoState(x=10.0, y=20.0,\
    \ z=30.0, vx=1.0, vy=2.0, vz=3.0, accel_x=0.1, accel_y=0.2, accel_z=0.3)\n    \n    #\
    \ Position Vector\n    pos_vec = state.position_vector\n    assert isinstance(pos_vec,\
    \ np.ndarray)\n    assert len(pos_vec) == 3\n    assert pos_vec[0] == 10.0\n    assert\
    \ pos_vec[1] == 20.0\n    assert pos_vec[2] == 30.0\n    \n    # Velocity Vector\n   \
    \ vel_vec = state.velocity_vector\n    assert isinstance(vel_vec, np.ndarray)\n    assert\
    \ len(vel_vec) == 3\n    assert vel_vec[0] == 1.0\n    assert vel_vec[1] == 2.0\n    assert\
    \ vel_vec[2] == 3.0\n    \n    # Acceleration Vector\n    accel_vec = state.acceleration_vector\n\
    \    assert isinstance(accel_vec, np.ndarray)\n    assert len(accel_vec) == 3\n    assert\
    \ accel_vec[0] == 0.1\n    assert accel_vec[1] == 0.2\n    assert accel_vec[2] == 0.3\n\
    \n\ndef test_state_is_dataclass():\n    \"\"\"Test: UfoState ist ein dataclass.\"\"\"\n\
    \    from core.simulation.state import UfoState\n    from dataclasses import is_dataclass\n\
    \    \n    assert is_dataclass(UfoState)\n\n\ndef test_state_uses_slots():\n    \"\"\"\
    Test: UfoState nutzt slots für Performance.\"\"\"\n    from core.simulation.state import\
    \ UfoState\n    \n    state = UfoState()\n    \n    # Wenn slots=True, dann sollte es\
    \ kein __dict__ geben\n    assert not hasattr(state, \"__dict__\")\n\n\nif __name__ ==\
    \ \"__main__\":\n    from conftest import run_manual_tests  # type: ignore[import]\n\n\
    \    tests = [\n        test_state_import,\n        test_state_instantiation_defaults,\n\
    \        test_state_instantiation_custom,\n        test_state_vector_properties,\n   \
    \     test_state_is_dataclass,\n        test_state_uses_slots,\n    ]\n\n    run_manual_tests(\"\
    core.simulation.state\", tests)  # type: ignore[name-defined]\n"
  - rel_path: tests/core/simulation/state/test_state_manager_smoke.py
    hash: 97a5f761eaaeffccbeddf72ba01e09ba8820e178bc40f98768b07d3fb67d08d7
    content: "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"Smoke-Test für StateManager-Modul\
    \ - Standalone-Lauffähigkeit.\"\"\"\n\n\ndef test_state_manager_module_import():\n   \
    \ \"\"\"StateManager-Modul kann standalone importiert werden.\"\"\"\n    from core.simulation.state\
    \ import StateManager\n    \n    assert StateManager is not None\n\n\ndef test_state_manager_instantiation():\n\
    \    \"\"\"StateManager kann ohne weitere Dependencies instantiiert werden.\"\"\"\n  \
    \  from core.simulation.state import StateManager, UfoState\n    \n    # Default-Initialisierung\n\
    \    manager = StateManager()\n    assert manager is not None\n    \n    # Mit initial\
    \ state\n    initial = UfoState(x=10.0, z=20.0)\n    manager_with_state = StateManager(initial_state=initial)\n\
    \    assert manager_with_state is not None\n    \n    snapshot = manager_with_state.get_snapshot()\n\
    \    assert snapshot.x == 10.0\n    assert snapshot.z == 20.0\n\n\ndef test_state_manager_has_required_methods():\n\
    \    \"\"\"StateManager hat alle geforderten Methoden gemäß Spec.\"\"\"\n    from core.simulation.state\
    \ import StateManager\n    \n    manager = StateManager()\n    \n    # Geforderte Methoden\
    \ aus introductions.md Abschnitt 4.1\n    assert hasattr(manager, 'update_state')\n  \
    \  assert hasattr(manager, 'get_snapshot')\n    assert hasattr(manager, 'register_observer')\n\
    \    assert hasattr(manager, 'unregister_observer')\n    assert hasattr(manager, 'wait_for_condition')\n\
    \    assert hasattr(manager, 'reset')\n    \n    # Alle Methoden sollten aufrufbar sein\n\
    \    assert callable(manager.update_state)\n    assert callable(manager.get_snapshot)\n\
    \    assert callable(manager.register_observer)\n    assert callable(manager.unregister_observer)\n\
    \    assert callable(manager.wait_for_condition)\n    assert callable(manager.reset)\n\
    \n\ndef test_state_manager_has_no_forbidden_dependencies():\n    \"\"\"StateManager hat\
    \ keine verbotenen Dependencies.\"\"\"\n    from core.simulation.state import manager\
    \ as manager_module\n    \n    # StateManager-Modul laden\n    module_source = manager_module.__file__\n\
    \    \n    # Verbotene Imports gemäß Spec (Sicherstellung)\n    # Prüfe auf tatsächliche\
    \ import-Statements, nicht nur Erwähnungen in Docstrings\n    forbidden_imports = [\n\
    \        'from ..physics',\n        'from .physics',\n        'import physics',\n    \
    \    'from ..command',\n        'from .command',\n        'import command',\n        'from\
    \ ..controller',\n        'from .controller',\n        'import controller',\n        'from\
    \ ..view',\n        'from .view',\n        'import view',\n        'from .pview',\n  \
    \      'import pview',\n    ]\n    \n    # Modul-Quelltext überprüfen\n    with open(module_source,\
    \ 'r') as f:\n        content = f.read()\n    \n    for forbidden in forbidden_imports:\n\
    \        assert forbidden not in content, f\"StateManager sollte nicht '{forbidden}' verwenden\"\
    \n    \n    # Mindestens die Kern-Dependencies sollten vorhanden sein\n    assert 'from\
    \ .state import UfoState' in content\n    assert 'from ..synchronization import' in content\
    \  # Neuer Import-Pfad\n    assert 'import threading' in content\n\n\ndef test_synchronized_decorator_available():\n\
    \    \"\"\"@synchronized Decorator ist aus synchronization verfügbar.\"\"\"\n    from\
    \ core.simulation.synchronization import synchronized\n\n    assert synchronized is not\
    \ None\n    assert callable(synchronized)\n\n\ndef test_state_manager_uses_synchronized():\n\
    \    \"\"\"StateManager verwendet @synchronized Decorator.\"\"\"\n    from core.simulation.state\
    \ import manager as manager_module\n    \n    # Überprüfe dass synchronized verwendet\
    \ wird\n    with open(manager_module.__file__, 'r') as f:\n        content = f.read()\n\
    \n    assert 'from ..synchronization import' in content  # Neuer Import-Pfad\n    assert\
    \ '@synchronized' in content\n"
  - rel_path: tests/core/simulation/state/test_state_module_independence.py
    hash: 972c1d8c1242650ed1a62db6cd4cd39cac215320ff3bdb038fa13158f85fe47e
    content: |+
      # ...existing code...
      import subprocess
      import sys
      
      
      def test_state_module_is_independent() -> None:
          """
          Lädt `src/core/simulation/state/state.py` isoliert (ohne Paket-__init__ auszulösen)
          und prüft, dass dabei keine höheren Simulationsmodule importiert werden.
      
          Dieser Test läuft in einem separaten Python-Subprozess, damit bereits in diesem Prozess
          geladene Module (z. B. aus anderen Tests) das Ergebnis nicht beeinflussen.
          """
          script = r"""
      from pathlib import Path
      import importlib.util
      import sys
      
      p = Path('src/core/simulation/state/state.py').resolve()
      # Load module from file location to avoid executing package __init__
      spec = importlib.util.spec_from_file_location('ufo_state_isolation_test', str(p))
      mod = importlib.util.module_from_spec(spec)
      spec.loader.exec_module(mod)
      
      # Now check sys.modules for forbidden higher-level modules
      forbidden = [
          'core.simulation.ufosim',
          'core.simulation.view',
          'core.simulation.ufo_main',
          'core.simulation'
      ]
      found = [m for m in forbidden if m in sys.modules]
      if found:
          # Print the first found module name (signal to caller)
          print(found[0])
      """
      
          proc = subprocess.run([sys.executable, '-c', script], capture_output=True, text=True)
          out = proc.stdout.strip()
          if proc.returncode != 0:
              # provide diagnostics on failure
              raise AssertionError(f"Subprocess failed: returncode={proc.returncode}, stderr={proc.stderr}\nstdout={proc.stdout}")
      
          assert out == "", f"state module imported higher-level module: {out}"
      
      # ...existing code...

  - rel_path: tests/core/simulation/synchronization/test_conditional_lock.py
    hash: 2a6fa7e84732bcb7ea44f904e33a7dcb8a128d96fbd09d7b7b5f272824c59b58
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """Unit-Tests für conditional Decorator."""
      
      import sys
      import threading
      import time
      from pathlib import Path
      
      import pytest
      
      # Stelle sicher, dass das repo root-Verzeichnis im sys.path ist (damit `import src` funktioniert)
      repo_root = Path(__file__).resolve().parents[4]
      if str(repo_root) not in sys.path:
          sys.path.insert(0, str(repo_root))
      
      from src.core.simulation.synchronization import conditional
      from tests._helpers import run_threaded_workers
      
      
      class TestConditionalDecorator:
          """Tests für @conditional Decorator."""
      
          def test_basic_locking(self):
              """@conditional sollte Methode unter Lock ausführen."""
      
              class TestClass:
                  def __init__(self):
                      self._lock = threading.RLock()
                      self._condition = threading.Condition(self._lock)
                      self.value = 0
                      self.call_count = 0
      
                  @conditional
                  def increment(self):
                      """Inkrementiert value unter Lock."""
                      self.call_count += 1
                      self.value += 1
                      self._condition.notify_all()
      
              obj = TestClass()
              obj.increment()
      
              assert obj.value == 1
              assert obj.call_count == 1
      
          def test_notify_all_without_nested_lock(self):
              """@conditional sollte notify_all() ohne nested lock ermöglichen."""
      
              class Manager:
                  def __init__(self):
                      self._lock = threading.RLock()
                      self._condition = threading.Condition(self._lock)
                      self.state = 0
      
                  @conditional
                  def update(self, new_value):
                      """Update mit Notification - kein nested lock."""
                      self.state = new_value
                      self._condition.notify_all()  # Sollte funktionieren
                      return self.state
      
              manager = Manager()
              result = manager.update(42)
      
              assert result == 42
              assert manager.state == 42
      
          def test_thread_safety_concurrent_access(self):
              """@conditional sollte Thread-Safety garantieren."""
      
              class Counter:
                  def __init__(self):
                      self._lock = threading.RLock()
                      self._condition = threading.Condition(self._lock)
                      self.value = 0
      
                  @conditional
                  def increment(self):
                      # Simuliere non-atomare Operation
                      temp = self.value
                      time.sleep(0.001)  # Kurze Verzögerung
                      self.value = temp + 1
                      self._condition.notify_all()
      
              counter = Counter()
      
              # 10 Threads inkrementieren je 10x
              def worker():
                  for _ in range(10):
                      counter.increment()
      
              run_threaded_workers(worker, num_threads=10, timeout_per_thread=5.0)
      
              # Sollte 100 sein (10 Threads * 10 Inkremente)
              assert counter.value == 100
      
          def test_exception_releases_lock(self):
              """@conditional sollte Lock auch bei Exception freigeben."""
      
              class ErrorClass:
                  def __init__(self):
                      self._lock = threading.RLock()
                      self._condition = threading.Condition(self._lock)
                      self.locked = False
      
                  @conditional
                  def failing_method(self):
                      # Prüfe ob Lock acquired ist (ohne _is_owned zu verwenden)
                      self.locked = not self._lock.acquire(blocking=False) or (self._lock.release() is None and True)
                      raise ValueError("Test error")
      
                  def check_lock_free(self):
                      # Versuche Lock zu acquiren (sollte sofort möglich sein)
                      acquired = self._lock.acquire(blocking=False)
                      if acquired:
                          self._lock.release()
                      return acquired
      
              obj = ErrorClass()
      
              with pytest.raises(ValueError):
                  obj.failing_method()
      
              # Lock sollte freigegeben sein
              assert obj.check_lock_free() is True
      
          def test_return_value_preserved(self):
              """@conditional sollte Rückgabewerte korrekt durchreichen."""
      
              class Calculator:
                  def __init__(self):
                      self._lock = threading.RLock()
                      self._condition = threading.Condition(self._lock)
      
                  @conditional
                  def add(self, a, b):
                      return a + b
      
                  @conditional
                  def multiply(self, a, b):
                      result = a * b
                      self._condition.notify_all()
                      return result
      
              calc = Calculator()
      
              assert calc.add(2, 3) == 5
              assert calc.multiply(4, 5) == 20
      
          def test_with_args_and_kwargs(self):
              """@conditional sollte mit verschiedenen Argument-Typen funktionieren."""
      
              class Accumulator:
                  def __init__(self):
                      self._lock = threading.RLock()
                      self._condition = threading.Condition(self._lock)
                      self.values = []
      
                  @conditional
                  def add_values(self, *args, **kwargs):
                      self.values.extend(args)
                      self.values.extend(kwargs.values())
                      self._condition.notify_all()
                      return len(self.values)
      
              acc = Accumulator()
      
              count = acc.add_values(1, 2, 3, x=10, y=20)
      
              assert count == 5
              assert set(acc.values) == {1, 2, 3, 10, 20}
      
          def test_missing_condition_raises_error(self):
              """@conditional sollte AttributeError werfen wenn _condition fehlt."""
      
              class BadClass:
                  def __init__(self):
                      pass  # Kein self._condition!
      
                  @conditional
                  def method(self):
                      pass
      
              obj = BadClass()
      
              with pytest.raises(AttributeError):
                  obj.method()
      
          def test_compatible_with_rlocks(self):
              """@conditional sollte mit RLocks wiedereintrittsfähig sein."""
      
              class Reentrant:
                  def __init__(self):
                      self._lock = threading.RLock()  # RLock!
                      self._condition = threading.Condition(self._lock)
                      self.depth = 0
      
                  @conditional
                  def outer(self):
                      self.depth += 1
                      if self.depth < 3:
                          self.inner()  # Rekursiver Aufruf
                      return self.depth
      
                  @conditional
                  def inner(self):
                      self.depth += 1
                      if self.depth < 3:
                          self.outer()  # Rekursiver Aufruf
      
              obj = Reentrant()
              result = obj.outer()
      
              # Sollte funktionieren wegen RLock
              assert result == 3
      
      
      if __name__ == "__main__":
          pytest.main([__file__, "-v"])
  - rel_path: tests/core/simulation/synchronization/test_instance_lock.py
    hash: e164e04430b0aa11b77a61570379d1df83f62f2d910bdab3190ccc21e0047f16
    content: "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nTests für core.simulation.synchronization.instance_lock.\n\
    \nDiese Tests prüfen:\n1. Smoke-Test: Modul kann ohne Fehler importiert werden\n2. Funktionalität:\
    \ @synchronized Decorator funktioniert korrekt\n3. Thread-Safety: Keine Race-Conditions\
    \ bei parallelen Zugriffen\n4. Error-Handling: Korrekte Fehlermeldung bei fehlendem _lock-Attribut\n\
    \"\"\"\n\nimport threading\nimport time\nfrom typing import List\n\nimport pytest\n\n\
    from core.simulation.synchronization import synchronized\n\n\ndef test_instance_lock_module_import():\n\
    \    \"\"\"\n    Smoke-Test: Modul kann importiert werden.\n    \n    Prüft, dass keine\
    \ Import-, Lazy-Loading- oder Initialisierungsfehler auftreten.\n    \"\"\"\n    from\
    \ core.simulation.synchronization.decorators import instance as instance_lock\n    assert\
    \ instance_lock is not None\n    assert hasattr(instance_lock, 'synchronized')\n\n\ndef\
    \ test_synchronized_decorator_exists():\n    \"\"\"Prüft, dass der synchronized Decorator\
    \ existiert und aufrufbar ist.\"\"\"\n    assert callable(synchronized)\n\n\ndef test_synchronized_basic_functionality():\n\
    \    \"\"\"\n    Prüft Basisfunktionalität des @synchronized Decorators.\n    \n    Testet:\n\
    \    - Decorator kann auf Methode angewendet werden\n    - Dekorierte Methode funktioniert\
    \ korrekt\n    - Rückgabewerte bleiben erhalten\n    \"\"\"\n    \n    class Counter:\n\
    \        def __init__(self):\n            self._lock = threading.RLock()\n           \
    \ self._value = 0\n        \n        @synchronized\n        def increment(self):\n   \
    \         self._value += 1\n        \n        @synchronized\n        def get_value(self):\n\
    \            return self._value\n        \n        @synchronized\n        def add(self,\
    \ amount: int):\n            self._value += amount\n            return self._value\n \
    \   \n    counter = Counter()\n    assert counter.get_value() == 0\n    \n    counter.increment()\n\
    \    assert counter.get_value() == 1\n    \n    result = counter.add(5)\n    assert result\
    \ == 6\n    assert counter.get_value() == 6\n\n\ndef test_synchronized_with_threading_lock():\n\
    \    \"\"\"\n    Prüft, dass @synchronized auch mit threading.Lock (nicht nur RLock) funktioniert.\n\
    \    \"\"\"\n    \n    class SimpleLockCounter:\n        def __init__(self):\n       \
    \     self._lock = threading.Lock()  # Einfaches Lock statt RLock\n            self._value\
    \ = 0\n        \n        @synchronized\n        def increment(self):\n            self._value\
    \ += 1\n        \n        @synchronized\n        def get_value(self):\n            return\
    \ self._value\n    \n    counter = SimpleLockCounter()\n    counter.increment()\n    assert\
    \ counter.get_value() == 1\n\n\n@pytest.mark.threading\n@pytest.mark.timeout(30)\ndef\
    \ test_synchronized_thread_safety_no_race_conditions():\n    \"\"\"\n    Multithread-Test:\
    \ Prüft, dass keine Race-Conditions bei parallelen Zugriffen auftreten.\n    \n    Testet:\n\
    \    - 100 Threads führen jeweils 100 Inkremente durch\n    - Erwartetes Ergebnis: 10.000\
    \ (keine Race-Conditions)\n    - Ohne @synchronized würde das Ergebnis typischerweise\
    \ < 10.000 sein\n    \"\"\"\n    \n    class ThreadSafeCounter:\n        def __init__(self):\n\
    \            self._lock = threading.RLock()\n            self._value = 0\n        \n \
    \       @synchronized\n        def increment(self):\n            # Simuliere kritischen\
    \ Abschnitt mit Read-Modify-Write\n            old_value = self._value\n            time.sleep(0.0001)\
    \  # Kurze Verzögerung um Race-Conditions zu provozieren\n            self._value = old_value\
    \ + 1\n        \n        @synchronized\n        def get_value(self):\n            return\
    \ self._value\n    \n    counter = ThreadSafeCounter()\n    threads: List[threading.Thread]\
    \ = []\n    \n    num_threads = 100\n    increments_per_thread = 100\n    expected_result\
    \ = num_threads * increments_per_thread\n    \n    # Starte Threads\n    for _ in range(num_threads):\n\
    \        def worker():\n            for _ in range(increments_per_thread):\n         \
    \       counter.increment()\n        \n        thread = threading.Thread(target=worker)\n\
    \        threads.append(thread)\n        thread.start()\n    \n    # Warte auf Abschluss\n\
    \    for thread in threads:\n        thread.join()\n    \n    # Prüfe Ergebnis\n    assert\
    \ counter.get_value() == expected_result, \\\n        f\"Race-Condition detected: Expected\
    \ {expected_result}, got {counter.get_value()}\"\n\n\n@pytest.mark.threading\n@pytest.mark.timeout(10)\n\
    def test_synchronized_reentrant_with_rlock():\n    \"\"\"\n    Prüft Wiedereintrittsfähigkeit\
    \ bei RLock.\n    \n    Testet, dass derselbe Thread die Methode mehrfach betreten kann\n\
    \    (wichtig für verschachtelte Aufrufe).\n    \"\"\"\n    \n    class ReentrantCounter:\n\
    \        def __init__(self):\n            self._lock = threading.RLock()\n           \
    \ self._value = 0\n        \n        @synchronized\n        def increment(self):\n   \
    \         self._value += 1\n        \n        @synchronized\n        def increment_twice(self):\n\
    \            # Ruft eine andere synchronisierte Methode auf\n            self.increment()\n\
    \            self.increment()\n        \n        @synchronized\n        def get_value(self):\n\
    \            return self._value\n    \n    counter = ReentrantCounter()\n    counter.increment_twice()\
    \  # Sollte nicht deadlocken\n    assert counter.get_value() == 2\n\n\ndef test_synchronized_preserves_exceptions():\n\
    \    \"\"\"\n    Prüft, dass Exceptions aus dekorierten Methoden korrekt durchgereicht\
    \ werden\n    und das Lock trotzdem freigegeben wird.\n    \"\"\"\n    \n    class ExceptionThrower:\n\
    \        def __init__(self):\n            self._lock = threading.RLock()\n           \
    \ self._lock_acquired_count = 0\n        \n        @synchronized\n        def throw_error(self):\n\
    \            raise ValueError(\"Test exception\")\n        \n        @synchronized\n \
    \       def check_lock_free(self):\n            # Wenn Lock nicht freigegeben wurde, würde\
    \ dies blockieren\n            return True\n    \n    thrower = ExceptionThrower()\n \
    \   \n    # Exception sollte durchgereicht werden\n    with pytest.raises(ValueError,\
    \ match=\"Test exception\"):\n        thrower.throw_error()\n    \n    # Lock sollte trotzdem\
    \ freigegeben worden sein\n    assert thrower.check_lock_free() is True\n\n\ndef test_synchronized_without_lock_attribute():\n\
    \    \"\"\"\n    Prüft, dass fehlerhaftes Setup (Klasse ohne _lock) zu sauberem Fehler\
    \ führt.\n    \"\"\"\n    \n    class NoLockClass:\n        def __init__(self):\n    \
    \        self._value = 0\n        \n        @synchronized\n        def increment(self):\n\
    \            self._value += 1\n    \n    obj = NoLockClass()\n    \n    # Sollte AttributeError\
    \ werfen (kein _lock vorhanden)\n    with pytest.raises(AttributeError):\n        obj.increment()\n\
    \n\ndef test_synchronized_preserves_method_signature():\n    \"\"\"\n    Prüft, dass der\
    \ Decorator die Methodensignatur erhält.\n    \n    Dies ist wichtig für Introspection,\
    \ Dokumentation und IDE-Support.\n    \"\"\"\n    \n    class DocumentedClass:\n     \
    \   def __init__(self):\n            self._lock = threading.RLock()\n        \n      \
    \  @synchronized\n        def documented_method(self, x: int, y: str) -> str:\n      \
    \      \"\"\"Eine gut dokumentierte Methode.\"\"\"\n            return f\"{y}: {x}\"\n\
    \    \n    obj = DocumentedClass()\n    \n    # Prüfe, dass __name__ und __doc__ erhalten\
    \ bleiben (via @wraps)\n    assert obj.documented_method.__name__ == \"documented_method\"\
    \n    assert obj.documented_method.__doc__ == \"Eine gut dokumentierte Methode.\"\n  \
    \  \n    # Prüfe Funktionalität\n    result = obj.documented_method(42, \"Answer\")\n\
    \    assert result == \"Answer: 42\"\n\n\ndef test_synchronized_with_kwargs():\n    \"\
    \"\"\n    Prüft, dass @synchronized mit Keyword-Argumenten funktioniert.\n    \"\"\"\n\
    \    \n    class FlexibleClass:\n        def __init__(self):\n            self._lock =\
    \ threading.RLock()\n        \n        @synchronized\n        def flexible_method(self,\
    \ a: int, b: int = 10, c: int = 20) -> int:\n            return a + b + c\n    \n    obj\
    \ = FlexibleClass()\n    \n    assert obj.flexible_method(1) == 31\n    assert obj.flexible_method(1,\
    \ b=5) == 26\n    assert obj.flexible_method(1, c=100) == 111\n    assert obj.flexible_method(1,\
    \ b=2, c=3) == 6\n\n\n@pytest.mark.threading\n@pytest.mark.timeout(15)\ndef test_synchronized_multiple_instances():\n\
    \    \"\"\"\n    Prüft, dass verschiedene Instanzen unabhängige Locks haben.\n    \n \
    \   Dies stellt sicher, dass der Decorator instanzspezifisch arbeitet,\n    nicht klassenspezifisch.\n\
    \    \"\"\"\n    \n    class InstanceCounter:\n        def __init__(self):\n         \
    \   self._lock = threading.RLock()\n            self._value = 0\n        \n        @synchronized\n\
    \        def increment(self):\n            old = self._value\n            time.sleep(0.001)\n\
    \            self._value = old + 1\n        \n        @synchronized\n        def get_value(self):\n\
    \            return self._value\n    \n    counter1 = InstanceCounter()\n    counter2\
    \ = InstanceCounter()\n    \n    # Parallele Zugriffe auf unterschiedliche Instanzen\n\
    \    threads = []\n    \n    for _ in range(10):\n        t1 = threading.Thread(target=counter1.increment)\n\
    \        t2 = threading.Thread(target=counter2.increment)\n        threads.extend([t1,\
    \ t2])\n        t1.start()\n        t2.start()\n    \n    for thread in threads:\n   \
    \     thread.join()\n    \n    # Beide Counter sollten korrekt sein (unabhängig voneinander)\n\
    \    assert counter1.get_value() == 10\n    assert counter2.get_value() == 10\n"
  - rel_path: tests/core/simulation/synchronization/test_lock_wrapper.py
    hash: bbedf0333cf2d3ef469e2ad55c5c6d20eb04ca59b9f728feeec48943ed20e4df
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """Unit-Tests für zentrale Lock-Wrapper-Utilities."""
      
      import sys
      import threading
      import time
      from pathlib import Path
      from typing import Callable, List
      
      import pytest
      
      # add repo root to sys.path so `import src` works
      repo_root = Path(__file__).resolve().parents[4]
      if str(repo_root) not in sys.path:
          sys.path.insert(0, str(repo_root))
      
      from src.core.simulation.synchronization import (
          acquire_lock,
          create_lock_wrapper,
      )
      
      
      def run_threaded_workers(worker: Callable[[], None], *, num_threads: int = 10, timeout_per_thread: float = 5.0) -> None:
          """Hilfsfunktion für Tests: Führt `worker` in mehreren Threads aus und wartet auf Abschluss.
      
          Args:
              worker: Callable ohne Parameter, das in jedem Thread ausgeführt wird.
              num_threads: Anzahl gleichzeitiger Threads.
              timeout_per_thread: maximale Wartezeit pro Thread in Sekunden.
      
          Raises:
              RuntimeError: Falls ein oder mehrere Threads nach Ablauf des Timeouts noch laufen.
          """
          threads: List[threading.Thread] = []
          for _ in range(num_threads):
              t = threading.Thread(target=worker, daemon=True)
              threads.append(t)
              t.start()
      
          for t in threads:
              t.join(timeout=timeout_per_thread)
      
          alive = [t for t in threads if t.is_alive()]
          if alive:
              raise RuntimeError(f"{len(alive)} Thread(s) laufen nach Timeout noch.")
      
      
      class TestAcquireLock:
          """Tests für acquire_lock Context Manager."""
      
          def test_acquire_release_rlock(self):
              """acquire_lock sollte RLock korrekt acquiren und releasen."""
              lock = threading.RLock()
      
              with acquire_lock(lock):
                  # Lock sollte acquired sein
                  # Versuche zweites Acquire (sollte bei RLock funktionieren)
                  acquired = lock.acquire(blocking=False)
                  assert acquired is True
                  lock.release()
      
              # Nach Context Manager sollte Lock frei sein
              acquired = lock.acquire(blocking=False)
              assert acquired is True
              lock.release()
      
          def test_acquire_release_lock(self):
              """acquire_lock sollte Lock korrekt acquiren und releasen."""
              lock = threading.Lock()
      
              with acquire_lock(lock):
                  # Lock ist acquired, zweites Acquire sollte blockieren
                  acquired = lock.acquire(blocking=False)
                  assert acquired is False
      
              # Nach Context Manager sollte Lock frei sein
              acquired = lock.acquire(blocking=False)
              assert acquired is True
              lock.release()
      
          def test_acquire_release_condition(self):
              """acquire_lock sollte Condition korrekt acquiren und releasen."""
              condition = threading.Condition()
      
              with acquire_lock(condition):
                  # Condition ist acquired
                  pass  # Keine direkte Prüfung möglich
      
              # Nach Context Manager sollte frei sein
              acquired = condition.acquire(blocking=False)
              assert acquired is True
              condition.release()
      
          def test_exception_releases_lock(self):
              """acquire_lock sollte Lock auch bei Exception freigeben."""
              lock = threading.RLock()
      
              with pytest.raises(ValueError):
                  with acquire_lock(lock):
                      raise ValueError("Test exception")
      
              # Lock sollte trotz Exception freigegeben sein
              acquired = lock.acquire(blocking=False)
              assert acquired is True
              lock.release()
      
      
      class TestCreateLockWrapper:
          """Tests für create_lock_wrapper Factory."""
      
          def test_wrapper_with_instance_lock(self):
              """create_lock_wrapper sollte für Instanz-Locks funktionieren."""
      
              class Counter:
                  def __init__(self):
                      self._lock = threading.RLock()
                      self.value = 0
      
                  @create_lock_wrapper(lambda self, *args, **kwargs: self._lock)
                  def increment(self):
                      self.value += 1
      
              counter = Counter()
              counter.increment()
              assert counter.value == 1
      
          def test_wrapper_with_module_lock(self):
              """create_lock_wrapper sollte für Modul-Locks funktionieren."""
              _module_lock = threading.RLock()
              state = {"value": 0}
      
              @create_lock_wrapper(lambda *args, **kwargs: _module_lock)
              def increment():
                  state["value"] += 1
      
              increment()
              assert state["value"] == 1
      
          def test_wrapper_with_condition(self):
              """create_lock_wrapper sollte für Condition-Variables funktionieren."""
      
              class Manager:
                  def __init__(self):
                      self._lock = threading.RLock()
                      self._condition = threading.Condition(self._lock)
                      self.state = 0
      
                  @create_lock_wrapper(lambda self, *args, **kwargs: self._condition)
                  def update(self, value):
                      self.state = value
                      self._condition.notify_all()
      
              manager = Manager()
              manager.update(42)
              assert manager.state == 42
      
          def test_wrapper_thread_safety(self):
              """create_lock_wrapper sollte Thread-Safety garantieren."""
      
              class Counter:
                  def __init__(self):
                      self._lock = threading.RLock()
                      self.value = 0
      
                  @create_lock_wrapper(lambda self, *args, **kwargs: self._lock)
                  def increment(self):
                      # Simuliere non-atomare Operation
                      temp = self.value
                      time.sleep(0.001)
                      self.value = temp + 1
      
              counter = Counter()
      
              def worker():
                  for _ in range(10):
                      counter.increment()
      
              run_threaded_workers(worker, num_threads=10, timeout_per_thread=5.0)
      
              assert counter.value == 100
      
          def test_wrapper_preserves_return_value(self):
              """create_lock_wrapper sollte Rückgabewerte preservieren."""
      
              class Calculator:
                  def __init__(self):
                      self._lock = threading.RLock()
      
                  @create_lock_wrapper(lambda self, *args, **kwargs: self._lock)
                  def add(self, a, b):
                      return a + b
      
              calc = Calculator()
              result = calc.add(2, 3)
              assert result == 5
      
          def test_wrapper_preserves_args_kwargs(self):
              """create_lock_wrapper sollte Args und Kwargs korrekt durchreichen."""
      
              class Accumulator:
                  def __init__(self):
                      self._lock = threading.RLock()
                      self.values = []
      
                  @create_lock_wrapper(lambda self, *args, **kwargs: self._lock)
                  def add_values(self, *args, **kwargs):
                      self.values.extend(args)
                      self.values.extend(kwargs.values())
                      return len(self.values)
      
              acc = Accumulator()
              count = acc.add_values(1, 2, 3, x=10, y=20)
      
              assert count == 5
              assert set(acc.values) == {1, 2, 3, 10, 20}
      
          def test_wrapper_exception_safety(self):
              """create_lock_wrapper sollte Lock bei Exception freigeben."""
      
              class ErrorClass:
                  def __init__(self):
                      self._lock = threading.RLock()
      
                  @create_lock_wrapper(lambda self, *args, **kwargs: self._lock)
                  def failing_method(self):
                      raise ValueError("Test error")
      
                  def check_lock_free(self):
                      acquired = self._lock.acquire(blocking=False)
                      if acquired:
                          self._lock.release()
                      return acquired
      
              obj = ErrorClass()
      
              with pytest.raises(ValueError):
                  obj.failing_method()
      
              # Lock sollte freigegeben sein
              assert obj.check_lock_free() is True
      
          def test_wrapper_with_different_lock_types(self):
              """create_lock_wrapper sollte mit verschiedenen Lock-Typen funktionieren."""
      
              # Test mit Lock
              class WithLock:
                  def __init__(self):
                      self._lock = threading.Lock()
                      self.value = 0
      
                  @create_lock_wrapper(lambda self, *args, **kwargs: self._lock)
                  def increment(self):
                      self.value += 1
      
              obj1 = WithLock()
              obj1.increment()
              assert obj1.value == 1
      
              # Test mit RLock
              class WithRLock:
                  def __init__(self):
                      self._lock = threading.RLock()
                      self.value = 0
      
                  @create_lock_wrapper(lambda self, *args, **kwargs: self._lock)
                  def increment(self):
                      self.value += 1
      
              obj2 = WithRLock()
              obj2.increment()
              assert obj2.value == 1
      
              # Test mit Condition
              class WithCondition:
                  def __init__(self):
                      self._condition = threading.Condition()
                      self.value = 0
      
                  @create_lock_wrapper(lambda self, *args, **kwargs: self._condition)
                  def increment(self):
                      self.value += 1
      
              obj3 = WithCondition()
              obj3.increment()
              assert obj3.value == 1
      
      
      if __name__ == "__main__":
          pytest.main([__file__, "-v"])
  - rel_path: tests/core/simulation/synchronization/test_module_lock.py
    hash: c95e38175fc7d333d50b153ff588a11e1c1c4cd0aaeab76ccd7172074ecc5807
    content: "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nTests für core.simulation.synchronization.module_lock.\n\
    \nDiese Tests prüfen:\n1. Smoke-Test: Modul kann ohne Fehler importiert werden\n2. Funktionalität:\
    \ @synchronized_module Decorator funktioniert korrekt\n3. Thread-Safety: Keine Race-Conditions\
    \ bei parallelen Zugriffen\n4. Kompatibilität: Funktioniert mit Lock und RLock\n\"\"\"\
    \nimport threading\n\nimport pytest\n\nfrom core.simulation.synchronization import synchronized_module\n\
    from tests._helpers import assert_race_condition_free, create_decorated_counter\n\n\n\
    def test_module_lock_module_import():\n    \"\"\"\n    Smoke-Test: Modul kann importiert\
    \ werden.\n    \n    Prüft, dass keine Import-, Lazy-Loading- oder Initialisierungsfehler\
    \ auftreten.\n    \"\"\"\n    from core.simulation.synchronization.decorators import module\n\
    \    assert module is not None\n    assert hasattr(module, 'synchronized_module')\n\n\n\
    def test_synchronized_module_decorator_exists():\n    \"\"\"Prüft, dass der synchronized_module\
    \ Decorator existiert und aufrufbar ist.\"\"\"\n    assert callable(synchronized_module)\n\
    \n\ndef test_synchronized_module_basic_functionality(rlock):\n    \"\"\"\n    Prüft Basisfunktionalität\
    \ des @synchronized_module Decorators.\n    \n    Testet:\n    - Decorator kann auf Funktion\
    \ angewendet werden\n    - Dekorierte Funktion funktioniert korrekt\n    - Rückgabewerte\
    \ bleiben erhalten\n    - Parameter werden korrekt durchgereicht\n    \"\"\"\n    counter\
    \ = create_decorated_counter(synchronized_module, rlock)\n\n    assert counter[\"get_value\"\
    ]() == 0\n\n    counter[\"increment\"]()\n    assert counter[\"get_value\"]() == 1\n\n\
    \    result = counter[\"add\"](5)\n    assert result == 6\n    assert counter[\"get_value\"\
    ]() == 6\n\n\ndef test_synchronized_module_with_lock(lock):\n    \"\"\"\n    Prüft, dass\
    \ @synchronized_module mit threading.Lock funktioniert.\n    \"\"\"\n    counter = create_decorated_counter(synchronized_module,\
    \ lock)\n\n    counter[\"increment\"]()\n    assert counter[\"get_value\"]() == 1\n\n\n\
    @pytest.mark.threading\n@pytest.mark.timeout(30)\ndef test_synchronized_module_thread_safety_no_race_conditions(rlock):\n\
    \    \"\"\"\n    Multithread-Test: Prüft, dass keine Race-Conditions bei parallelen Zugriffen\
    \ auftreten.\n    \n    Testet:\n    - 100 Threads führen jeweils 100 Inkremente durch\n\
    \    - Erwartetes Ergebnis: 10.000 (keine Race-Conditions)\n    - Ohne @synchronized_module\
    \ würde das Ergebnis typischerweise < 10.000 sein\n    \"\"\"\n    counter = create_decorated_counter(synchronized_module,\
    \ rlock)\n\n    assert_race_condition_free(\n        counter[\"increment\"],\n       \
    \ counter[\"get_value\"],\n        num_threads=100,\n        increments_per_thread=100\n\
    \    )\n\n\n@pytest.mark.threading\n@pytest.mark.timeout(10)\ndef test_synchronized_module_reentrant_with_rlock(rlock):\n\
    \    \"\"\"\n    Prüft Wiedereintrittsfähigkeit bei RLock.\n    \n    Testet, dass derselbe\
    \ Thread die Funktion mehrfach betreten kann\n    (wichtig für verschachtelte Aufrufe).\n\
    \    \"\"\"\n    counter = create_decorated_counter(synchronized_module, rlock)\n\n  \
    \  @synchronized_module(rlock)\n    def increment_twice():\n        # Ruft eine andere\
    \ synchronisierte Funktion auf\n        counter[\"increment\"]()\n        counter[\"increment\"\
    ]()\n\n    increment_twice()  # Sollte nicht deadlocken\n    assert counter[\"get_value\"\
    ]() == 2\n\n\ndef test_synchronized_module_preserves_exceptions():\n    \"\"\"\n    Prüft,\
    \ dass Exceptions aus dekorierten Funktionen korrekt durchgereicht werden\n    und das\
    \ Lock trotzdem freigegeben wird.\n    \"\"\"\n    \n    lock = threading.RLock()\n  \
    \  \n    @synchronized_module(lock)\n    def throw_error():\n        raise ValueError(\"\
    Test exception\")\n    \n    @synchronized_module(lock)\n    def check_lock_free():\n\
    \        # Wenn Lock nicht freigegeben wurde, würde dies blockieren\n        return True\n\
    \    \n    # Exception sollte durchgereicht werden\n    with pytest.raises(ValueError,\
    \ match=\"Test exception\"):\n        throw_error()\n    \n    # Lock sollte trotzdem\
    \ freigegeben worden sein\n    assert check_lock_free() is True\n\n\ndef test_synchronized_module_preserves_function_signature():\n\
    \    \"\"\"\n    Prüft, dass der Decorator die Funktionssignatur erhält.\n    \n    Dies\
    \ ist wichtig für Introspection, Dokumentation und IDE-Support.\n    \"\"\"\n    \n  \
    \  lock = threading.RLock()\n    \n    @synchronized_module(lock)\n    def documented_function(x:\
    \ int, y: str) -> str:\n        \"\"\"Eine gut dokumentierte Funktion.\"\"\"\n       \
    \ return f\"{y}: {x}\"\n    \n    # Prüfe, dass __name__ und __doc__ erhalten bleiben\
    \ (via @wraps)\n    assert documented_function.__name__ == \"documented_function\"\n \
    \   assert documented_function.__doc__ == \"Eine gut dokumentierte Funktion.\"\n    \n\
    \    # Prüfe Funktionalität\n    result = documented_function(42, \"Answer\")\n    assert\
    \ result == \"Answer: 42\"\n\n\ndef test_synchronized_module_with_kwargs():\n    \"\"\"\
    \n    Prüft, dass @synchronized_module mit Keyword-Argumenten funktioniert.\n    \"\"\"\
    \n    \n    lock = threading.RLock()\n    \n    @synchronized_module(lock)\n    def flexible_function(a:\
    \ int, b: int = 10, c: int = 20) -> int:\n        return a + b + c\n    \n    assert flexible_function(1)\
    \ == 31\n    assert flexible_function(1, b=5) == 26\n    assert flexible_function(1, c=100)\
    \ == 111\n    assert flexible_function(1, b=2, c=3) == 6\n\n\n@pytest.mark.threading\n\
    @pytest.mark.timeout(15)\ndef test_synchronized_module_multiple_locks(rlock, lock):\n\
    \    \"\"\"\n    Prüft, dass verschiedene Locks unabhängig voneinander funktionieren.\n\
    \    \"\"\"\n    counter1 = create_decorated_counter(synchronized_module, rlock)\n   \
    \ counter2 = create_decorated_counter(synchronized_module, lock)\n\n    # Parallele Zugriffe\
    \ auf unterschiedliche Locks\n    threads = []\n    \n    for _ in range(10):\n      \
    \  t1 = threading.Thread(target=counter1[\"increment\"])\n        t2 = threading.Thread(target=counter2[\"\
    increment\"])\n        threads.extend([t1, t2])\n        t1.start()\n        t2.start()\n\
    \    \n    for thread in threads:\n        thread.join()\n    \n    # Beide Counter sollten\
    \ korrekt sein (unabhängig voneinander)\n    assert counter1[\"get_value\"]() == 10\n\
    \    assert counter2[\"get_value\"]() == 10\n\n\ndef test_synchronized_module_with_args_and_kwargs():\n\
    \    \"\"\"\n    Prüft komplexe Parameterkombinationen.\n    \"\"\"\n    \n    lock =\
    \ threading.RLock()\n    \n    @synchronized_module(lock)\n    def complex_function(*args,\
    \ **kwargs):\n        return {\"args\": args, \"kwargs\": kwargs}\n    \n    result =\
    \ complex_function(1, 2, 3, a=4, b=5)\n    assert result == {\"args\": (1, 2, 3), \"kwargs\"\
    : {\"a\": 4, \"b\": 5}}\n"
  - rel_path: tests/core/simulation/utils/test_condition_waiter.py
    hash: fdf16e3b90aac4583af514864f031071e6617c1605895f0d3c1742071b51f4e3
    content: |
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      """Unit-Tests für ConditionWaiter Utility-Klasse."""
      
      import threading
      import time
      import pytest
      from pathlib import Path
      import sys
      
      # Stelle sicher, dass repo root im sys.path ist
      repo_root = Path(__file__).resolve().parents[4]
      if str(repo_root) not in sys.path:
          sys.path.insert(0, str(repo_root))
      
      from src.core.simulation.utils.condition_waiter import ConditionWaiter
      
      
      class TestConditionWaiter:
          """Tests für die zentrale ConditionWaiter-Utility."""
      
          def test_immediate_true_condition(self):
              """Prädikat bereits erfüllt → sofortiger Return mit True."""
              condition = threading.Condition()
              state = {"value": 42}
      
              result = ConditionWaiter.wait_for_condition(
                  condition_var=condition,
                  predicate=lambda s: s["value"] == 42,
                  state_getter=lambda: state,
                  timeout=0.1
              )
      
              assert result is True
      
          def test_immediate_false_with_timeout(self):
              """Prädikat nicht erfüllt → Timeout → Return False."""
              condition = threading.Condition()
              state = {"value": 0}
      
              start = time.time()
              result = ConditionWaiter.wait_for_condition(
                  condition_var=condition,
                  predicate=lambda s: s["value"] == 999,
                  state_getter=lambda: state,
                  timeout=0.1
              )
              elapsed = time.time() - start
      
              assert result is False
              assert elapsed >= 0.1  # Mindestens Timeout-Dauer
              assert elapsed < 0.2  # Aber nicht viel länger
      
          def test_condition_fulfilled_after_notify(self):
              """State wird asynchron geändert → Notification → Prädikat erfüllt."""
              condition = threading.Condition()
              state = {"value": 0}
      
              def update_state():
                  """Ändert State nach 100ms und notified."""
                  time.sleep(0.1)
                  with condition:
                      state["value"] = 100
                      condition.notify_all()
      
              # Start async update
              thread = threading.Thread(target=update_state, daemon=True)
              thread.start()
      
              # Wait for condition
              result = ConditionWaiter.wait_for_condition(
                  condition_var=condition,
                  predicate=lambda s: s["value"] == 100,
                  state_getter=lambda: state,
                  timeout=1.0
              )
      
              assert result is True
              assert state["value"] == 100
      
          def test_timeout_before_condition_fulfilled(self):
              """Timeout läuft ab bevor Prädikat erfüllt wird."""
              condition = threading.Condition()
              state = {"value": 0}
      
              def slow_update():
                  """Ändert State nach 500ms (zu langsam)."""
                  time.sleep(0.5)
                  with condition:
                      state["value"] = 100
                      condition.notify_all()
      
              thread = threading.Thread(target=slow_update, daemon=True)
              thread.start()
      
              # Timeout nach 100ms (State wird erst nach 500ms geändert)
              result = ConditionWaiter.wait_for_condition(
                  condition_var=condition,
                  predicate=lambda s: s["value"] == 100,
                  state_getter=lambda: state,
                  timeout=0.1
              )
      
              assert result is False
              # State sollte noch nicht geändert sein
              assert state["value"] == 0
      
          def test_no_timeout_waits_indefinitely(self):
              """Ohne Timeout wird unbegrenzt gewartet (bis Condition erfüllt)."""
              condition = threading.Condition()
              state = {"ready": False}
      
              def update_after_delay():
                  time.sleep(0.2)
                  with condition:
                      state["ready"] = True
                      condition.notify_all()
      
              thread = threading.Thread(target=update_after_delay, daemon=True)
              thread.start()
      
              # Kein Timeout → wartet unbegrenzt
              result = ConditionWaiter.wait_for_condition(
                  condition_var=condition,
                  predicate=lambda s: s["ready"],
                  state_getter=lambda: state,
                  timeout=None  # Explizit None
              )
      
              assert result is True
              assert state["ready"] is True
      
          def test_multiple_notifications_spurious_wakeups(self):
              """Mehrere notify_all() Calls → while-loop schützt vor spurious wakeups."""
              condition = threading.Condition()
              state = {"counter": 0}
      
              def send_multiple_notifications():
                  """Sendet mehrere Notifications, aber ändert Wert nur einmal."""
                  for i in range(5):
                      time.sleep(0.02)
                      with condition:
                          if i == 3:  # Nur beim 4. Mal Wert ändern
                              state["counter"] = 10
                          condition.notify_all()
      
              thread = threading.Thread(target=send_multiple_notifications, daemon=True)
              thread.start()
      
              # Warte auf counter == 10
              result = ConditionWaiter.wait_for_condition(
                  condition_var=condition,
                  predicate=lambda s: s["counter"] == 10,
                  state_getter=lambda: state,
                  timeout=1.0
              )
      
              assert result is True
              assert state["counter"] == 10
      
          def test_complex_state_object(self):
              """Funktioniert mit komplexen State-Objekten (nicht nur Dict)."""
              from dataclasses import dataclass
      
              @dataclass
              class ComplexState:
                  x: float
                  y: float
                  z: float
      
              condition = threading.Condition()
              state = ComplexState(0.0, 0.0, 0.0)
      
              def update_z():
                  nonlocal state
                  time.sleep(0.1)
                  with condition:
                      state = ComplexState(state.x, state.y, 100.0)
                      condition.notify_all()
      
              thread = threading.Thread(target=update_z, daemon=True)
              thread.start()
      
              result = ConditionWaiter.wait_for_condition(
                  condition_var=condition,
                  predicate=lambda s: s.z >= 100.0,
                  state_getter=lambda: state,
                  timeout=1.0
              )
      
              assert result is True
              assert state.z == 100.0
      
          def test_thread_safety_concurrent_waits(self):
              """Mehrere Threads warten gleichzeitig auf dieselbe Condition."""
              condition = threading.Condition()
              state = {"value": 0}
              results = []
      
              def waiter(target_value):
                  result = ConditionWaiter.wait_for_condition(
                      condition_var=condition,
                      predicate=lambda s: s["value"] >= target_value,
                      state_getter=lambda: state,
                      timeout=2.0
                  )
                  results.append((target_value, result))
      
              # 3 Threads warten auf verschiedene Werte
              threads = [
                  threading.Thread(target=waiter, args=(10,), daemon=True),
                  threading.Thread(target=waiter, args=(20,), daemon=True),
                  threading.Thread(target=waiter, args=(30,), daemon=True),
              ]
      
              for t in threads:
                  t.start()
      
              # State inkrementieren und notifyen
              for value in [10, 20, 30]:
                  time.sleep(0.1)
                  with condition:
                      state["value"] = value
                      condition.notify_all()
      
              # Warte auf alle Threads
              for t in threads:
                  t.join(timeout=3.0)
      
              # Alle sollten erfolgreich gewesen sein
              assert len(results) == 3
              assert all(result for _, result in results)
      
      
      if __name__ == "__main__":
          pytest.main([__file__, "-v"])
  - rel_path: tests/core/simulation/utils/test_geometry.py
    hash: 65047827498421b3c8306afd19fda57c4dea70c3cc171e3c899b8c32c118d167
    content: |
      """
      Unit-Tests für das utils.geometry Modul.
      
      Testet geometrische Transformationsfunktionen für 3D-Koordinaten.
      """
      
      from __future__ import annotations
      
      import math
      
      from core.simulation.utils.geometry import cartesian_to_spherical, spherical_to_cartesian
      
      
      def assert_coordinates_equal(actual: tuple[float, float, float], expected: tuple[float, float, float], tolerance: float = 1e-10) -> None:
          """Hilfsfunktion: Prüft, ob zwei 3D-Koordinaten innerhalb der Toleranz gleich sind."""
          assert abs(actual[0] - expected[0]) < tolerance, f"x: {actual[0]} != {expected[0]}"
          assert abs(actual[1] - expected[1]) < tolerance, f"y: {actual[1]} != {expected[1]}"
          assert abs(actual[2] - expected[2]) < tolerance, f"z: {actual[2]} != {expected[2]}"
      
      
      class TestCartesianToSpherical:
          """Tests für cartesian_to_spherical Funktion."""
      
          def test_origin(self):
              """Ursprung sollte (0, 0, 0) ergeben."""
              r, theta, phi = cartesian_to_spherical(0.0, 0.0, 0.0)
              assert r == 0.0
              assert theta == 0.0
              assert phi == 0.0
      
          def test_positive_z_axis(self):
              """Punkt auf positiver z-Achse."""
              r, theta, phi = cartesian_to_spherical(0.0, 0.0, 1.0)
              assert abs(r - 1.0) < 1e-10
              assert abs(theta - 0.0) < 1e-10  # θ = 0 für +z
      
          def test_negative_z_axis(self):
              """Punkt auf negativer z-Achse."""
              r, theta, phi = cartesian_to_spherical(0.0, 0.0, -1.0)
              assert abs(r - 1.0) < 1e-10
              assert abs(theta - math.pi) < 1e-10  # θ = π für -z
      
          def test_positive_x_axis(self):
              """Punkt auf positiver x-Achse."""
              r, theta, phi = cartesian_to_spherical(1.0, 0.0, 0.0)
              assert abs(r - 1.0) < 1e-10
              assert abs(theta - math.pi / 2) < 1e-10  # θ = π/2 für xy-Ebene
              assert abs(phi - 0.0) < 1e-10  # φ = 0 für +x
      
          def test_positive_y_axis(self):
              """Punkt auf positiver y-Achse."""
              r, theta, phi = cartesian_to_spherical(0.0, 1.0, 0.0)
              assert abs(r - 1.0) < 1e-10
              assert abs(theta - math.pi / 2) < 1e-10
              assert abs(phi - math.pi / 2) < 1e-10  # φ = π/2 für +y
      
          def test_general_point(self):
              """Allgemeiner Punkt im Raum."""
              r, theta, phi = cartesian_to_spherical(1.0, 1.0, 1.0)
              expected_r = math.sqrt(3.0)
              assert abs(r - expected_r) < 1e-10
      
          def test_large_coordinates(self):
              """Große Koordinaten sollten korrekt konvertiert werden."""
              r, theta, phi = cartesian_to_spherical(100.0, 0.0, 0.0)
              assert abs(r - 100.0) < 1e-8
      
      
      class TestSphericalToCartesian:
          """Tests für spherical_to_cartesian Funktion."""
      
          def test_origin(self):
              """r=0 sollte Ursprung ergeben."""
              x, y, z = spherical_to_cartesian(0.0, 0.0, 0.0)
              assert abs(x) < 1e-10
              assert abs(y) < 1e-10
              assert abs(z) < 1e-10
      
          def test_positive_z_axis(self):
              """θ=0 sollte positive z-Achse ergeben."""
              x, y, z = spherical_to_cartesian(1.0, 0.0, 0.0)
              assert abs(x - 0.0) < 1e-10
              assert abs(y - 0.0) < 1e-10
              assert abs(z - 1.0) < 1e-10
      
          def test_negative_z_axis(self):
              """θ=π sollte negative z-Achse ergeben."""
              x, y, z = spherical_to_cartesian(1.0, math.pi, 0.0)
              assert abs(x - 0.0) < 1e-10
              assert abs(y - 0.0) < 1e-10
              assert abs(z - (-1.0)) < 1e-10
      
          def test_positive_x_axis(self):
              """θ=π/2, φ=0 sollte positive x-Achse ergeben."""
              x, y, z = spherical_to_cartesian(1.0, math.pi / 2, 0.0)
              assert abs(x - 1.0) < 1e-10
              assert abs(y - 0.0) < 1e-10
              assert abs(z - 0.0) < 1e-10
      
          def test_positive_y_axis(self):
              """θ=π/2, φ=π/2 sollte positive y-Achse ergeben."""
              x, y, z = spherical_to_cartesian(1.0, math.pi / 2, math.pi / 2)
              assert abs(x - 0.0) < 1e-10
              assert abs(y - 1.0) < 1e-10
              assert abs(z - 0.0) < 1e-10
      
          def test_large_radius(self):
              """Großer Radius sollte korrekt skaliert werden."""
              x, y, z = spherical_to_cartesian(100.0, math.pi / 2, 0.0)
              assert abs(x - 100.0) < 1e-8
      
      
      class TestRoundtripConversion:
          """Tests für Hin- und Rück-Konvertierung."""
      
          def test_roundtrip_cartesian_spherical_cartesian(self):
              """Kartesisch → Sphärisch → Kartesisch sollte Original ergeben."""
              original_x, original_y, original_z = 3.0, 4.0, 5.0
      
              # Hin
              r, theta, phi = cartesian_to_spherical(original_x, original_y, original_z)
      
              # Zurück
              x, y, z = spherical_to_cartesian(r, theta, phi)
      
              assert_coordinates_equal((x, y, z), (original_x, original_y, original_z))
      
          def test_roundtrip_spherical_cartesian_spherical(self):
              """Sphärisch → Kartesisch → Sphärisch sollte Original ergeben."""
              original_r = 5.0
              original_theta = math.pi / 4
              original_phi = math.pi / 3
      
              # Hin
              x, y, z = spherical_to_cartesian(original_r, original_theta, original_phi)
      
              # Zurück
              r, theta, phi = cartesian_to_spherical(x, y, z)
      
              assert_coordinates_equal((r, theta, phi), (original_r, original_theta, original_phi))
      
          def test_multiple_points_roundtrip(self):
              """Mehrere Punkte sollten Roundtrip korrekt durchlaufen."""
              test_points = [
                  (1.0, 0.0, 0.0),
                  (0.0, 1.0, 0.0),
                  (0.0, 0.0, 1.0),
                  (1.0, 1.0, 1.0),
                  (-1.0, -1.0, -1.0),
              ]
      
              for orig_x, orig_y, orig_z in test_points:
                  r, theta, phi = cartesian_to_spherical(orig_x, orig_y, orig_z)
                  x, y, z = spherical_to_cartesian(r, theta, phi)
      
                  assert_coordinates_equal((x, y, z), (orig_x, orig_y, orig_z))
  - rel_path: tests/core/simulation/utils/test_maths.py
    hash: 179e108eb66612c1934c4179c876b0b676329b5b060e2c505e2575d040de9579
    content: |
      """
      Unit-Tests für das utils.maths Modul.
      
      Testet alle numerischen Hilfsfunktionen mit normalen Werten, Randwerten
      und Edge-Cases gemäß den Anforderungen aus Ticket T6.
      """
      
      from __future__ import annotations
      
      import math
      import pytest
      
      from core.simulation.utils.maths import (
          clamp,
          deg_to_rad,
          rad_to_deg,
          wrap_angle_deg,
          wrap_angle_rad,
      )
      
      
      class TestDegToRad:
          """Tests für deg_to_rad Funktion."""
      
          def test_zero_degrees(self):
              """Null Grad sollte null Radiant ergeben."""
              assert deg_to_rad(0.0) == 0.0
      
          def test_90_degrees(self):
              """90 Grad sollte π/2 ergeben."""
              assert abs(deg_to_rad(90.0) - math.pi / 2) < 1e-10
      
          def test_180_degrees(self):
              """180 Grad sollte π ergeben."""
              assert abs(deg_to_rad(180.0) - math.pi) < 1e-10
      
          def test_360_degrees(self):
              """360 Grad sollte 2π ergeben."""
              assert abs(deg_to_rad(360.0) - 2 * math.pi) < 1e-10
      
          def test_negative_degrees(self):
              """Negative Grad sollten korrekt konvertiert werden."""
              assert abs(deg_to_rad(-90.0) + math.pi / 2) < 1e-10
              assert abs(deg_to_rad(-180.0) + math.pi) < 1e-10
      
          def test_large_angle(self):
              """Große Winkel sollten korrekt konvertiert werden."""
              assert abs(deg_to_rad(720.0) - 4 * math.pi) < 1e-10
      
      
      class TestRadToDeg:
          """Tests für rad_to_deg Funktion."""
      
          def test_zero_radians(self):
              """Null Radiant sollte null Grad ergeben."""
              assert rad_to_deg(0.0) == 0.0
      
          def test_pi_over_2_radians(self):
              """π/2 Radiant sollte 90 Grad ergeben."""
              assert abs(rad_to_deg(math.pi / 2) - 90.0) < 1e-10
      
          def test_pi_radians(self):
              """π Radiant sollte 180 Grad ergeben."""
              assert abs(rad_to_deg(math.pi) - 180.0) < 1e-10
      
          def test_two_pi_radians(self):
              """2π Radiant sollte 360 Grad ergeben."""
              assert abs(rad_to_deg(2 * math.pi) - 360.0) < 1e-10
      
          def test_negative_radians(self):
              """Negative Radiant sollten korrekt konvertiert werden."""
              assert abs(rad_to_deg(-math.pi / 2) + 90.0) < 1e-10
              assert abs(rad_to_deg(-math.pi) + 180.0) < 1e-10
      
          def test_roundtrip_conversion(self):
              """Hin- und Rückkonvertierung sollte Original-Wert ergeben."""
              original = 45.0
              converted = rad_to_deg(deg_to_rad(original))
              assert abs(converted - original) < 1e-10
      
      
      class TestWrapAngleDeg:
          """Tests für wrap_angle_deg Funktion."""
      
          def test_zero_angle(self):
              """Null Grad sollte unverändert bleiben."""
              assert wrap_angle_deg(0.0) == 0.0
      
          def test_angle_in_range(self):
              """Winkel im Bereich sollten unverändert bleiben."""
              assert wrap_angle_deg(45.0) == 45.0
              assert wrap_angle_deg(-45.0) == -45.0
              assert wrap_angle_deg(179.0) == 179.0
              assert wrap_angle_deg(-179.0) == -179.0
      
          def test_180_degrees(self):
              """180 Grad wraps zu -180 Grad (mathematisch äquivalent)."""
              # 180° und -180° sind mathematisch äquivalent
              # Der Bereich ist [-180, 180), also exklusiv bei 180
              assert wrap_angle_deg(180.0) == -180.0
      
          def test_wrap_around_positive(self):
              """Positive Winkel über 180° sollten auf negative Seite wrappen."""
              assert abs(wrap_angle_deg(181.0) - (-179.0)) < 1e-10
              assert abs(wrap_angle_deg(270.0) - (-90.0)) < 1e-10
              assert abs(wrap_angle_deg(359.0) - (-1.0)) < 1e-10
      
          def test_wrap_around_negative(self):
              """Negative Winkel unter -180° sollten auf positive Seite wrappen."""
              assert abs(wrap_angle_deg(-181.0) - 179.0) < 1e-10
              assert abs(wrap_angle_deg(-270.0) - 90.0) < 1e-10
              assert abs(wrap_angle_deg(-359.0) - 1.0) < 1e-10
      
          def test_full_rotation(self):
              """360° sollte zu 0° wrappen."""
              assert abs(wrap_angle_deg(360.0)) < 1e-10
              assert abs(wrap_angle_deg(-360.0)) < 1e-10
      
          def test_multiple_rotations(self):
              """Mehrfache Rotationen sollten korrekt behandelt werden."""
              assert abs(wrap_angle_deg(370.0) - 10.0) < 1e-10
              assert abs(wrap_angle_deg(720.0)) < 1e-10
              assert abs(wrap_angle_deg(-720.0)) < 1e-10
      
          def test_large_positive_angle(self):
              """Sehr große positive Winkel sollten korrekt wrappen."""
              assert abs(wrap_angle_deg(1810.0) - 10.0) < 1e-10
      
          def test_large_negative_angle(self):
              """Sehr große negative Winkel sollten korrekt wrappen."""
              assert abs(wrap_angle_deg(-1810.0) - (-10.0)) < 1e-10
      
          def test_custom_range_0_to_360(self):
              """Custom Range [0, 360) sollte funktionieren."""
              assert wrap_angle_deg(0.0, 0.0, 360.0) == 0.0
              assert wrap_angle_deg(180.0, 0.0, 360.0) == 180.0
              assert abs(wrap_angle_deg(370.0, 0.0, 360.0) - 10.0) < 1e-10
              assert abs(wrap_angle_deg(-10.0, 0.0, 360.0) - 350.0) < 1e-10
      
          def test_invalid_range_raises_error(self):
              """lower >= upper sollte ValueError auslösen."""
              with pytest.raises(ValueError, match="lower .* must be strictly less than upper"):
                  wrap_angle_deg(0.0, 180.0, 180.0)
      
              with pytest.raises(ValueError, match="lower .* must be strictly less than upper"):
                  wrap_angle_deg(0.0, 180.0, 0.0)
      
      
      class TestWrapAngleRad:
          """Tests für wrap_angle_rad Funktion."""
      
          def test_zero_radians(self):
              """Null Radiant sollte unverändert bleiben."""
              assert wrap_angle_rad(0.0) == 0.0
      
          def test_angle_in_range(self):
              """Winkel im Bereich [-π, π) sollten unverändert bleiben."""
              assert abs(wrap_angle_rad(math.pi / 4) - math.pi / 4) < 1e-10
              assert abs(wrap_angle_rad(-math.pi / 4) - (-math.pi / 4)) < 1e-10
      
          def test_pi_radians(self):
              """π Radiant wraps zu -π (mathematisch äquivalent)."""
              # π und -π sind mathematisch äquivalent
              # Der Bereich ist [-π, π), also exklusiv bei π
              assert abs(wrap_angle_rad(math.pi) - (-math.pi)) < 1e-10
      
          def test_wrap_around_positive(self):
              """Positive Winkel über π sollten wrappen."""
              result = wrap_angle_rad(3 * math.pi)
              expected = -math.pi  # 3π wraps to -π (äquivalent zu π)
              assert abs(result - expected) < 1e-10
      
          def test_wrap_around_negative(self):
              """Negative Winkel unter -π sollten wrappen."""
              result = wrap_angle_rad(-3 * math.pi)
              expected = -math.pi  # -3π wraps to -π (äquivalent zu π)
              assert abs(result - expected) < 1e-10
      
          def test_two_pi_radians(self):
              """2π sollte zu 0 wrappen."""
              assert abs(wrap_angle_rad(2 * math.pi)) < 1e-10
      
          def test_large_positive_angle(self):
              """Sehr große positive Winkel sollten korrekt wrappen."""
              result = wrap_angle_rad(10 * math.pi)
              assert abs(result) < 1e-10
      
          def test_large_negative_angle(self):
              """Sehr große negative Winkel sollten korrekt wrappen."""
              result = wrap_angle_rad(-10 * math.pi)
              assert abs(result) < 1e-10
      
      
      class TestClamp:
          """Tests für clamp Funktion."""
      
          def test_value_in_range(self):
              """Werte im Bereich sollten unverändert bleiben."""
              assert clamp(5.0, 0.0, 10.0) == 5.0
              assert clamp(0.0, 0.0, 10.0) == 0.0
              assert clamp(10.0, 0.0, 10.0) == 10.0
      
          def test_value_below_min(self):
              """Werte unter Minimum sollten auf Minimum begrenzt werden."""
              assert clamp(-5.0, 0.0, 10.0) == 0.0
              assert clamp(-100.0, -50.0, 50.0) == -50.0
      
          def test_value_above_max(self):
              """Werte über Maximum sollten auf Maximum begrenzt werden."""
              assert clamp(15.0, 0.0, 10.0) == 10.0
              assert clamp(100.0, -50.0, 50.0) == 50.0
      
          def test_negative_range(self):
              """Negativer Wertebereich sollte funktionieren."""
              assert clamp(-5.0, -10.0, -1.0) == -5.0
              assert clamp(-15.0, -10.0, -1.0) == -10.0
              assert clamp(0.0, -10.0, -1.0) == -1.0
      
          def test_zero_value(self):
              """Null sollte korrekt behandelt werden."""
              assert clamp(0.0, -10.0, 10.0) == 0.0
              assert clamp(0.0, 0.0, 10.0) == 0.0
              assert clamp(0.0, -10.0, 0.0) == 0.0
      
          def test_equal_min_max(self):
              """Wenn min == max, sollte dieser Wert zurückgegeben werden."""
              assert clamp(5.0, 3.0, 3.0) == 3.0
              assert clamp(0.0, 3.0, 3.0) == 3.0
              assert clamp(10.0, 3.0, 3.0) == 3.0
      
          def test_float_precision(self):
              """Floating-Point-Werte sollten präzise behandelt werden."""
              assert clamp(1.5, 1.0, 2.0) == 1.5
              assert clamp(0.99999, 1.0, 2.0) == 1.0
              assert clamp(2.00001, 1.0, 2.0) == 2.0
      
          def test_invalid_range_raises_error(self):
              """min_value > max_value sollte ValueError auslösen."""
              with pytest.raises(ValueError, match="min_value .* must not be greater than max_value"):
                  clamp(5.0, 10.0, 0.0)
      
      
      class TestModuleIndependence:
          """Tests für Modul-Unabhängigkeit gemäß Architektur-Anforderungen."""
      
          def test_no_simulation_imports(self):
              """
              Prüft, dass utils.maths keine Simulation-spezifischen Typen importiert.
      
              Dieser Test stellt sicher, dass die Architektur-Anforderung eingehalten wird,
              dass utils.maths unabhängig von Simulationslogik ist.
              """
              import core.simulation.utils.maths as maths_module
      
              # Hole alle importierten Module
              module_code = maths_module.__dict__
      
              # Prüfe, dass keine verbotenen Importe vorhanden sind
              forbidden_imports = ["UfoState", "UfoSim", "SimulationConfig", "StateManager"]
      
              for forbidden in forbidden_imports:
                  assert forbidden not in module_code, f"utils.maths darf {forbidden} nicht importieren"
      
      class TestIntegrationScenarios:
          """Integrations-Tests für realistische Anwendungsszenarien."""
      
          def test_navigation_scenario(self):
              """
              Simuliert typische Navigation-Berechnungen.
      
              Testet die Kombination mehrerer Funktionen wie sie in der
              Physik-Engine verwendet werden könnten.
              """
              # Heading von 370° normalisieren
              heading_deg = wrap_angle_deg(370.0, 0.0, 360.0)
              assert abs(heading_deg - 10.0) < 1e-10
      
              # Konvertierung zu Radiant
              heading_rad = deg_to_rad(heading_deg)
              assert abs(heading_rad - deg_to_rad(10.0)) < 1e-10
      
              # Neigungswinkel clampen
              inclination = clamp(95.0, -90.0, 90.0)
              assert inclination == 90.0
      
          def test_angle_difference_calculation(self):
              """
              Testet Berechnung von Winkeldifferenzen über die 360°-Grenze.
      
              Dies ist ein häufiger Use-Case in der Navigation.
              """
              # Von 350° nach 10° ist +20° (nicht +380° oder -340°)
              angle1 = 350.0
              angle2 = 10.0
      
              # Normalisiere beide Winkel
              norm1 = wrap_angle_deg(angle1, -180.0, 180.0)  # -> -10°
              norm2 = wrap_angle_deg(angle2, -180.0, 180.0)  # -> 10°
      
              diff = norm2 - norm1  # 10° - (-10°) = 20°
              assert abs(diff - 20.0) < 1e-10
      
          def test_velocity_clamping_scenario(self):
              """
              Testet Geschwindigkeits-Clamping wie in der Physik-Engine.
              """
              vmax = 100.0
      
              # Normale Geschwindigkeit
              v1 = clamp(50.0, 0.0, vmax)
              assert v1 == 50.0
      
              # Zu hohe Geschwindigkeit
              v2 = clamp(150.0, 0.0, vmax)
              assert v2 == 100.0
      
              # Negative Geschwindigkeit (nicht erlaubt)
              v3 = clamp(-10.0, 0.0, vmax)
              assert v3 == 0.0
  - rel_path: tests/core/simulation/utils/test_threading_tools_demo.py
    hash: 51642fc7b1225b1f0d2eb6b9036f370277dbf18fe68dfa514cd76916d62e260f
    content: "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nBeispiel-Tests für Threading/Debugging-Tools.\n\
    \nDemonstriert die Verwendung von:\n- pytest-timeout (Deadlock-Erkennung)\n- threadpoolctl\
    \ (Thread-Pool-Kontrolle)\n\"\"\"\n\nimport threading\nimport time\n\nimport pytest\n\
    import threadpoolctl\n\nfrom tests._helpers import run_threaded_workers, assert_race_condition_free,\
    \ create_decorated_counter\nfrom core.simulation.synchronization import synchronized\n\
    \n\n@pytest.mark.timeout(5)\ndef test_timeout_prevents_deadlock():\n    \"\"\"\n    Demonstriert\
    \ pytest-timeout: Test wird nach 5s abgebrochen.\n    \n    Dieser Test würde ohne timeout\
    \ unendlich laufen.\n    Mit @pytest.mark.timeout(5) wird er automatisch abgebrochen.\n\
    \    \"\"\"\n    lock1 = threading.Lock()\n    lock2 = threading.Lock()\n    \n    def\
    \ worker1():\n        with lock1:\n            time.sleep(0.1)\n\n    def worker2():\n\
    \        with lock2:\n            time.sleep(0.1)\n\n    t1 = threading.Thread(target=worker1)\n\
    \    t2 = threading.Thread(target=worker2)\n\n    t1.start()\n    t2.start()\n\n    t1.join(timeout=1)\n\
    \    t2.join(timeout=1)\n\n    # Test ist OK - kein Deadlock\n    assert True\n\n\n@pytest.mark.timeout(10)\n\
    def test_threadpoolctl_limits_threads():\n    \"\"\"\n    Demonstriert threadpoolctl:\
    \ Begrenzt Thread-Anzahl.\n    \n    Hilfreich um Lock-Contention in Tests zu reduzieren.\n\
    \    \"\"\"\n    info = threadpoolctl.threadpool_info()\n    print(f\"\\nThread-Pool-Info:\
    \ {len(info)} pools gefunden\")\n    \n    with threadpoolctl.threadpool_limits(limits=2):\n\
    \        info_limited = threadpoolctl.threadpool_info()\n        print(f\"Thread-Pool-Info\
    \ (limitiert): {info_limited}\")\n    \n    assert True\n\n\n@pytest.mark.timeout(15)\n\
    def test_synchronized_decorator_under_load():\n    \"\"\"\n    Stress-Test für @synchronized\
    \ Decorator mit pytest-timeout Sicherheit.\n    \"\"\"\n    class TestCounter:\n     \
    \   def __init__(self):\n            self._lock = threading.RLock()\n            self._value\
    \ = 0\n        \n        @synchronized\n        def increment(self):\n            old\
    \ = self._value\n            time.sleep(0.0001)\n            self._value = old + 1\n \
    \       \n        @synchronized\n        def get_value(self):\n            return self._value\n\
    \    \n    counter = TestCounter()\n\n    # 50 Threads × 20 Inkremente = 1000\n    assert_race_condition_free(\n\
    \        counter.increment,\n        counter.get_value,\n        num_threads=50,\n   \
    \     increments_per_thread=20\n    )\n\n\n@pytest.mark.timeout(10)\ndef test_module_lock_decorator_works(rlock):\n\
    \    \"\"\"\n    Test für @synchronized_module Decorator mit timeout-Schutz.\n    \"\"\
    \"\n    from core.simulation.synchronization import synchronized_module\n    \n    counter\
    \ = create_decorated_counter(synchronized_module, rlock)\n\n    # 20 Threads × 10 Inkremente\
    \ = 200\n    assert_race_condition_free(\n        counter[\"increment\"],\n        counter[\"\
    get_value\"],\n        num_threads=20,\n        increments_per_thread=10\n    )\n\n\n\
    # Marker für langsame Tests\n@pytest.mark.slow\n@pytest.mark.timeout(30)\ndef test_long_running_operation():\n\
    \    time.sleep(2)  # Simuliere lange Operation\n    assert True\n\n\n# Marker für Threading-Tests\n\
    @pytest.mark.threading\n@pytest.mark.timeout(20)\ndef test_complex_threading_scenario():\n\
    \    \"\"\"\n    Beispiel für komplexen Threading-Test.\n    \"\"\"\n    class Resource:\n\
    \        def __init__(self, name: str):\n            self._lock = threading.RLock()\n\
    \            self._name = name\n            self._access_count = 0\n        \n       \
    \ @synchronized\n        def access(self):\n            self._access_count += 1\n    \
    \        time.sleep(0.001)\n            return self._access_count\n    \n    resources\
    \ = [Resource(f\"R{i}\") for i in range(5)]\n\n    def worker(resource: Resource):\n \
    \       for _ in range(10):\n            resource.access()\n    \n    # Mehrere Threads\
    \ auf verschiedene Resources\n    for resource in resources:\n        run_threaded_workers(\n\
    \            lambda r=resource: worker(r),\n            num_threads=3,\n            timeout_per_thread=5.0\n\
    \        )\n\n    # Jede Resource sollte 3*10 = 30 Zugriffe haben\n    for resource in\
    \ resources:\n        assert resource._access_count == 30\n"
  - rel_path: tests/core/simulation/utils/test_validation.py
    hash: b464fbb6db0b227c84a82c2f7708c4d586cdc000b87b20a6d7c9a674f62f2dc7
    content: |
      """
      Unit-Tests für das utils.validation Modul.
      
      Testet Validierungsfunktionen für Wertebereichs-Prüfungen.
      """
      
      from __future__ import annotations
      
      import pytest
      
      from core.simulation.utils.validation import is_in_range, validate_range
      
      
      class TestValidateRange:
          """Tests für validate_range Funktion."""
      
          def test_value_in_range(self):
              """Wert im Bereich sollte keinen Fehler werfen."""
              validate_range(5.0, 0.0, 10.0, "test_value")  # Sollte nicht werfen
      
          def test_value_at_min_boundary(self):
              """Wert an unterer Grenze sollte erlaubt sein."""
              validate_range(0.0, 0.0, 10.0, "test_value")
      
          def test_value_at_max_boundary(self):
              """Wert an oberer Grenze sollte erlaubt sein."""
              validate_range(10.0, 0.0, 10.0, "test_value")
      
          def test_value_below_min(self):
              """Wert unter Minimum sollte ValueError werfen."""
              with pytest.raises(ValueError, match="test_value muss zwischen 0.0 und 10.0 liegen"):
                  validate_range(-1.0, 0.0, 10.0, "test_value")
      
          def test_value_above_max(self):
              """Wert über Maximum sollte ValueError werfen."""
              with pytest.raises(ValueError, match="test_value muss zwischen 0.0 und 10.0 liegen"):
                  validate_range(11.0, 0.0, 10.0, "test_value")
      
          def test_negative_range(self):
              """Negativer Wertebereich sollte funktionieren."""
              validate_range(-5.0, -10.0, -1.0, "negative_value")
      
          def test_error_message_includes_name(self):
              """Fehlermeldung sollte Parameter-Namen enthalten."""
              with pytest.raises(ValueError, match="velocity"):
                  validate_range(150.0, 0.0, 100.0, "velocity")
      
      
      class TestIsInRange:
          """Tests für is_in_range Funktion."""
      
          def test_value_in_range(self):
              """Wert im Bereich sollte True zurückgeben."""
              assert is_in_range(5.0, 0.0, 10.0) is True
      
          def test_value_at_min_boundary(self):
              """Wert an unterer Grenze sollte True sein."""
              assert is_in_range(0.0, 0.0, 10.0) is True
      
          def test_value_at_max_boundary(self):
              """Wert an oberer Grenze sollte True sein."""
              assert is_in_range(10.0, 0.0, 10.0) is True
      
          def test_value_below_min(self):
              """Wert unter Minimum sollte False sein."""
              assert is_in_range(-1.0, 0.0, 10.0) is False
      
          def test_value_above_max(self):
              """Wert über Maximum sollte False sein."""
              assert is_in_range(11.0, 0.0, 10.0) is False
      
          def test_negative_range(self):
              """Negativer Wertebereich sollte funktionieren."""
              assert is_in_range(-5.0, -10.0, -1.0) is True
              assert is_in_range(-15.0, -10.0, -1.0) is False
      
          def test_zero_value(self):
              """Null sollte korrekt behandelt werden."""
              assert is_in_range(0.0, -10.0, 10.0) is True
              assert is_in_range(0.0, 1.0, 10.0) is False
      
      
      class TestModuleIntegration:
          """Integrations-Tests für validation Modul."""
      
          def test_both_functions_consistent(self):
              """validate_range und is_in_range sollten konsistent sein."""
              # Wert im Bereich
              assert is_in_range(5.0, 0.0, 10.0) is True
              validate_range(5.0, 0.0, 10.0, "test")  # Kein Fehler
      
              # Wert außerhalb
              assert is_in_range(15.0, 0.0, 10.0) is False
              with pytest.raises(ValueError):
                  validate_range(15.0, 0.0, 10.0, "test")
  - rel_path: tools/__init__.py
    hash: 1c8d46762ba64ffd8846ffd797375163dfb66ddb97a5345f72eab6becd266541
    content: |
      # tools/__init__.py
      from __future__ import annotations
      
      """
      Werkzeugpaket für das Projekt »ufo-simulation-schulung«.
      
      Dieses Paket bündelt interne Hilfstools.
      Der Setup-Einstieg liegt in ``tools.bootstrap.execute``.
      """
      
      __all__: list[str] = []
  - rel_path: tools/bootstrap.py
    hash: cbd62c4c39793c740713833054044d4c831508bdefdedba3b53ee34f7f2e22e5
    content: |
      # tools/bootstrap.py
      from __future__ import annotations
      
      import sys
      from dataclasses import dataclass, fields
      from typing import Iterable
      
      from tools.setup.domain import BootstrapConfig, build_profile
      from tools.setup.logging import ErrorLog
      from tools.setup.steps.base import StepContext
      from tools.setup.ui import SetupConsole
      from tools.setup.ui.resources import CATALOG
      from tools.setup.domain import PyProjectProfile
      from tools.setup.steps import BaseStep, STEPS  # nur für Typ-Hints
      
      
      # ------------------------------------------------------------
      # 1) SETUP HEADER AUFBAUEN
      # ------------------------------------------------------------
      
      @dataclass(slots=True)
      class Segment:
          license: str
          title: str
          intro: str
          body: str
      
          def __iter__(self) -> Iterable[str]:
              return (getattr(self, f.name) for f in fields(self))
      
          @classmethod
          def from_catalog(cls, cat=CATALOG) -> "Segment":
              return cls(
                  **{
                      f.name: cat.text("setup_header", field=f.name, default="")
                      for f in fields(cls)
                  }
              )
      
      
      # ------------------------------------------------------------
      # 2) Low-Level-Utility-Funktionen
      # ------------------------------------------------------------
      
      def _build_log(config: BootstrapConfig) -> ErrorLog:
          """Bereitet das ErrorLog vor (leert bestehende Datei)."""
          path = config.log_path
          path.write_text("", encoding="utf-8")
          return ErrorLog(path)
      
      
      def _select_steps(profile: PyProjectProfile) -> tuple[type[BaseStep[object]], ...]:
          """
          Wählt die auszuführenden Steps ausschließlich auf Basis ihrer ``stid``
          und der Konfiguration aus [tool.setup].
          """
          from tools.setup.steps import STEPS  # tatsächliche Klassen
      
          # Mapping stid → Step-Klasse mit Schutz gegen Duplikate
          by_stid: dict[str, type[BaseStep[object]]] = {}
          for cls in STEPS:
              stid = cls.stid
              if stid in by_stid and by_stid[stid] is not cls:
                  other = by_stid[stid].__name__
                  raise ValueError(
                      f"Doppelte stid {stid!r} bei {cls.__name__} und {other}."
                  )
              by_stid[stid] = cls
      
          # 1) Basis-Menge bestimmen
          if profile.step_include:
              # Explizite Whitelist mit Reihenfolge aus pyproject.toml
              ordered_ids: list[str] = [
                  stid for stid in profile.step_include if stid in by_stid
              ]
          else:
              # Fallback: alle Steps nach priority sortiert (höchste zuerst)
              ordered_ids = [
                  cls.stid
                  for cls in sorted(by_stid.values(), key=lambda c: c.priority, reverse=True)
              ]
      
          # 2) Excludes anwenden
          exclude_ids = set(profile.step_exclude)
          final_ids: list[str] = [stid for stid in ordered_ids if stid not in exclude_ids]
      
          # 3) Step-Klassen in finaler Reihenfolge
          classes: list[type[BaseStep[object]]] = [by_stid[stid] for stid in final_ids]
          return tuple(classes)
      
      
      # ------------------------------------------------------------
      # 3) Step-Orchestrierung
      # ------------------------------------------------------------
      
      def leaf(ctx: StepContext) -> bool:
          """
          Führt alle konfigurierten Setup-Schritte aus und bricht nach dem
          ersten fehlgeschlagenen Step ab.
          """
          process = (cls() for cls in _select_steps(ctx.profile))
          return all((ok := step.run(ctx)) for step in process)
      
      
      # ------------------------------------------------------------
      # 4) High-Level-Orchestrator
      # ------------------------------------------------------------
      
      def execute(argv: list[str] | None = None) -> int:
          """
          Führt den kompletten Setup-Prozess aus:
      
          - Config, Profile, Log, Konsole erzeugen
          - Header anzeigen
          - Steps via leaf(ctx) ausführen
          - ggf. Next-Steps anzeigen
      
          CLI-Argumente (argv) werden bewusst ignoriert; das Verhalten
          wird ausschließlich über die pyproject.toml gesteuert.
          """
          config = BootstrapConfig()
          profile = build_profile(config.repo_root)
          log = _build_log(config)
      
          console = SetupConsole()
          ctx = StepContext(
              config=config,
              profile=profile,
              log=log,
              console=console,
          )
      
          seg = Segment.from_catalog(CATALOG)
          if seg.license:
              console.info(seg.license)
          if seg.title:
              console.header(seg.title)
          for part in (seg.intro, seg.body):
              if part:
                  console.info(part)
      
          ok = leaf(ctx)
      
          if ok:
              title = CATALOG.text("next", field="title", default="")
              body = CATALOG.text("next", field="body", default="").format(
                  activate_cmd=config.activation_command,
              )
              if title:
                  console.info(title)
              if body:
                  console.info(body)
      
          return 0 if ok else 1
      
      
      def console_script() -> None:
          """Entry-Point für pyproject.toml / setup_new.py."""
          raise SystemExit(execute(sys.argv[1:]))
  - rel_path: tools/setup/__init__.py
    hash: 09d3d6be5d1ced3a61e37a7ab409317dc24fc9f5dc7464d688df294b60f7a32a
    content: |
      # tools/setup/__init__.py
      from __future__ import annotations
      
      """
      Setup-Paket für das Projekt »ufo-simulation-schulung«.
      
      Kapselt:
      - Konfiguration und Projektprofil (``domain``),
      - Setup-Schritte (``steps``),
      - Konsolen- und UI-Hilfen (``ui``),
      - Hilfsfunktionen (``utils``).
      """
      
      __all__: list[str] = []
  - rel_path: tools/setup/domain/__init__.py
    hash: 4258eee4cd4d89f87b58b3ff5e47575ac112f9b48828622db3d6c4bfdf8aa712
    content: |
      from __future__ import annotations
      
      """
      Domänenspezifische Typen und Profile für das Setup.
      
      Dieses Unterpaket stellt die zentralen Modelle bereit:
      - :class:`BootstrapConfig` für Pfade und Laufzeitparameter,
      - :class:`PyProjectProfile` für abgeleitete Projektinformationen,
      - :func:`load_pyproject_profile` zum Laden des Profils aus der ``pyproject.toml``.
      """
      
      from .config import BootstrapConfig
      from .profile import PyProjectProfile, build_profile
      
      __all__: list[str] = [
          "BootstrapConfig",
          "PyProjectProfile",
          "build_profile",
      ]
  - rel_path: tools/setup/domain/config.py
    hash: a92f7fd7d6265f45e8698f7e883f3ecb45d2e2c6a988270d1cdf994263f1e667
    content: |
      # tools/setup/domain/config.py
      from __future__ import annotations
      
      from dataclasses import dataclass, field
      from enum import Enum
      from pathlib import Path
      from sys import platform as _platform
      
      
      class Platform(Enum):
          """Logische Plattformklasse für Venv-Layout (WINDOWS / POSIX)."""
      
          WINDOWS = "windows"
          POSIX = "posix"
      
      
      def default_repo_root() -> Path:
          """Liefert die Projektwurzel relativ zu diesem Modul."""
          return Path(__file__).resolve().parents[3]
      
      
      @dataclass(slots=True)
      class BootstrapConfig:
          """
          Zentrale technische Konfiguration für das Setup.
      
          Beinhaltet:
          - Projektwurzel (repo_root)
          - abgeleitete Pfade/Kommandos (venv_dir, venv_python, log_path, activation_command)
      
          Projekt- / Step-spezifisches Verhalten (Step-Auswahl, Optionen etc.)
          wird ausschließlich über die pyproject.toml im PyProjectProfile konfiguriert.
          """
      
          repo_root: Path = field(default_factory=default_repo_root)
      
          @property
          def platform(self) -> Platform:
              """Ermittelt die logische Plattform (WINDOWS oder POSIX)."""
              normalized = _platform.lower()
              if normalized.startswith(("win", "msys", "cygwin")):
                  return Platform.WINDOWS
              return Platform.POSIX
      
          @property
          def venv_dir(self) -> Path:
              """.venv-Verzeichnis unterhalb der Projektwurzel."""
              return self.repo_root / ".venv"
      
          @property
          def venv_python(self) -> str:
              """Pfad zur Python-Binary im Virtualenv."""
              rel = (
                  "Scripts/python.exe"
                  if self.platform is Platform.WINDOWS
                  else "bin/python"
              )
              return str(self.venv_dir / rel)
      
          @property
          def log_path(self) -> Path:
              """Pfad zur Setup-Logdatei."""
              return self.repo_root / "setup.log"
      
          @property
          def activation_command(self) -> str:
              """Shell-Befehl zur Aktivierung der virtuellen Umgebung."""
              if self.platform is Platform.WINDOWS:
                  return r".\.venv\Scripts\Activate.ps1"
              return "source .venv/bin/activate"
  - rel_path: tools/setup/domain/profile.py
    hash: 3ce6e3736cb7f23b7118a360f78518a8f607e56fc224a8b8d1e29fa7e0f6c1c5
    content: |
      # tools/setup/domain/profile.py
      from __future__ import annotations
      
      """
      Projektprofil auf Basis von pyproject.toml.
      """
      
      from dataclasses import dataclass, field
      from enum import StrEnum
      from pathlib import Path
      from typing import Any, Final, Mapping, Literal
      import tomllib
      
      PYPROJECT_FILENAME: Final[str] = "pyproject.toml"
      
      
      class RequirementOperator(StrEnum):
          """Unterstützte Vergleichsoperatoren für Dependency-Spezifikationen."""
      
          NOT_EQUAL = "!="
          EQUAL = "=="
          GTE = ">="
          LTE = "<="
          GT = ">"
          LT = "<"
          COMPAT = "~="
          EXACT = "==="
      
          @classmethod
          def detect(cls, text: str) -> tuple[str, str] | None:
              """Zerlegt eine Requirement-Spezifikation in (name, version_spec).
      
              Beispiele:
              - "importlinter>=2.0" -> ("importlinter", ">=2.0")
              - ">=3.10"            -> ("", ">=3.10")  (z. B. für requires-python)
      
              Liefert None, wenn kein Vergleichsoperator aus RequirementOperator gefunden wird.
              """
              spec = text.strip()
              if not spec:
                  return None
      
              # Längere Operatoren zuerst prüfen (z. B. ">=" vor ">")
              operators = sorted(
                  cls.__members__.values(),  # type: dict[str, RequirementOperator].values
                  key=lambda o: len(o.value),  # hier ist o klar ein RequirementOperator
                  reverse=True,
              )
      
              candidates: list[tuple[int, str]] = [
                  (pos, op_str)
                  for op in operators
                  if (op_str := op.value)  # op_str: str
                  if (pos := spec.find(op_str)) != -1
              ]
      
              if not candidates:
                  return None
      
              best_pos, best_op = min(candidates, key=lambda t: t[0])
      
              name = spec[:best_pos].strip()
              version_spec = spec[best_pos:].strip()
              return name, version_spec
      
      
      @dataclass(slots=True)
      class PyProjectProfile:
          """Setup-relevante Inhalte aus pyproject.toml."""
      
          requires_min_python: tuple[int, int] | None
          runtime_requirements: Mapping[str, str] = field(default_factory=dict)
          dev_requirements: Mapping[str, str] = field(default_factory=dict)
      
          # Step-Steuerung aus [tool.setup]
          step_include: tuple[str, ...] = field(default_factory=tuple)
          step_exclude: tuple[str, ...] = field(default_factory=tuple)
          step_options: Mapping[str, Mapping[str, Any]] = field(default_factory=dict)
          verbosity: int = 1
          auto_install: bool = True
      
          # Linter-spezifische Steuerung aus [tool.setup.linter]
          # "all" (Default) | "forbidden" | "layers"
          linter_contracts: Literal["all", "forbidden", "layers"] = "all"
      
          # Vollständige pyproject-Struktur für generische Zugriffe
          pyproject_data: Mapping[str, Any] = field(default_factory=dict)
      
          def get_path(self, *path: str, default: Any = None) -> Any:
              """Generischer Zugriff auf verschachtelte pyproject.toml-Werte."""
              data: Any = self.pyproject_data
              for key in path:
                  if not isinstance(data, Mapping):
                      return default
                  data = data.get(key)
                  if data is None:
                      return default
              return data
      
      
      def _min_version_from_segment(segment: str) -> tuple[int, int] | None:
          """
          Extrahiert eine Mindestversion (major, minor) aus einem Segment.
      
          Erwartet Einträge wie ">=3.10" und ignoriert fachlich unpassende Werte.
          """
          result: tuple[int, int] | None = None
          detection: tuple[str, str] | None = RequirementOperator.detect(segment)
      
          if detection is not None:
              name, version_spec = detection
      
              # für requires-python sind Paketnamen unerwartet
              if not name:
                  gte: str = RequirementOperator.GTE
                  if version_spec.startswith(gte):
                      version: str = version_spec.removeprefix(gte).strip()
                      parts: list[str] = version.split(".")
      
                      if len(parts) >= 2:
                          major_str: str = parts[0]
                          minor_str: str = parts[1]
      
                          if major_str.isdecimal() and minor_str.isdecimal():
                              major: int = int(major_str)
                              minor: int = int(minor_str)
                              result = (major, minor)
          return result
      
      
      def _parse_requires_python(spec: str | None) -> tuple[int, int] | None:
          """
          Interpretiert `project.requires-python` als Mindestversion (major, minor).
      
          Ausgewertet wird nur die erste untere Schranke vom Typ ">=X.Y".
          """
          result: tuple[int, int] | None = None
      
          if spec:
              segments = (segment.strip() for segment in spec.split(","))
              for segment in segments:
                  if not segment:
                      continue
      
                  version: tuple[int, int] | None = _min_version_from_segment(segment)
                  if version is not None:
                      result = version
                      break
      
          return result
      
      
      def _normalize_requirements(entries: list[str]) -> Mapping[str, str]:
          """
          Normalisiert eine Liste von Abhängigkeiten in ein Mapping name -> spec.
          """
          result: dict[str, str] = {}
      
          for raw in entries:
              entry: str = raw.strip()
              if not entry:
                  continue
      
              detection: tuple[str, str] | None = RequirementOperator.detect(entry)
              if detection is None:
                  result[entry] = ""
              else:
                  name, version_spec = detection
                  result[name] = version_spec
      
          return result
      
      
      def _load_pyproject_data(path: Path) -> Mapping[str, Any]:
          """
          Lädt pyproject.toml.
      
          Falls keine Datei existiert, wird ein leeres Mapping geliefert,
          so dass das Setup mit Standardprofil weiterlaufen kann.
          """
          # Wenn ein Verzeichnis übergeben wurde, pyproject.toml darin suchen,
          # ansonsten path direkt als Dateipfad interpretieren.
          pyproject_path = path / PYPROJECT_FILENAME if path.is_dir() else path
      
          if not pyproject_path.exists():
              return {}
      
          with pyproject_path.open("rb") as handle:
              data: Mapping[str, Any] = tomllib.load(handle)
      
          return data
      
      
      def _normalize_str_list(value: Any) -> tuple[str, ...]:
          """
          Normalisiert Werte aus der pyproject-Konfiguration auf eine
          geordnete Tupel-Liste von Strings.
          """
          if value is None:
              return ()
      
          if isinstance(value, str):
              value = [value]
      
          return tuple(
              str(item).strip()
              for item in value
              if str(item).strip()
          )
      
      
      def build_profile(repo_root: Path) -> PyProjectProfile:
          """
          Lädt die pyproject.toml genau einmal und baut ein Setup-Profil.
      
          - [project]                  → Dependencies, requires-python
          - [tool.setup]               → steps, exclude, options, linter
          - [tool.setup.linter]        → contracts-Modus ("all" | "forbidden" | "layers")
          - weitere tool-Abschnitte    → über pyproject_data / get_path(...)
          """
          data = _load_pyproject_data(repo_root)
      
          project_table: Mapping[str, Any] = data.get("project", {})
          requires_python_str: str | None = project_table.get("requires-python")
          requires_min_python: tuple[int, int] | None = _parse_requires_python(
              requires_python_str,
          )
      
          # Laufzeit-Abhängigkeiten kommen aus [project].dependencies
          deps_list: list[str] = project_table.get("dependencies", [])
          runtime_requirements: Mapping[str, str] = _normalize_requirements(deps_list)
      
          # Dev-Abhängigkeiten kommen aus [project.optional-dependencies].dev
          optional_deps: Mapping[str, list[str]] = project_table.get(
              "optional-dependencies",
              {},
          )
          dev_requirements: Mapping[str, str] = _normalize_requirements(
              optional_deps.get("dev", []),
          )
      
          tool_table: Mapping[str, Any] = data.get("tool", {})
          setup_table: Mapping[str, Any] = tool_table.get("setup", {})
      
          # [tool.setup].steps / exclude
          step_include: tuple[str, ...] = _normalize_str_list(setup_table.get("steps"))
          step_exclude: tuple[str, ...] = _normalize_str_list(setup_table.get("exclude"))
      
          # [tool.setup].options.<step-id>
          raw_options: Any = setup_table.get("options", {})
          if isinstance(raw_options, Mapping):
              tmp: dict[str, Mapping[str, Any]] = {}
              for key, value in raw_options.items():
                  if isinstance(value, Mapping):
                      tmp[str(key)] = dict(value)
              step_options: Mapping[str, Mapping[str, Any]] = tmp
          else:
              step_options = {}
      
          # [tool.setup].auto_install (optional, Default=True)
          auto_install_raw: Any = setup_table.get("auto_install", True)
          auto_install: bool = bool(auto_install_raw)
      
          # [tool.setup.linter].contracts
          linter_table: Mapping[str, Any] = setup_table.get("linter", {})
          contracts_raw: Any = linter_table.get("contracts", "all")
          contracts_mode = str(contracts_raw).strip().lower()
      
          if contracts_mode not in {"all", "forbidden", "layers"}:
              # Fallback auf "all" bei ungültigen Werten oder leerem String
              linter_contracts: Literal["all", "forbidden", "layers"] = "all"
          else:
              linter_contracts = contracts_mode  # type: ignore[assignment]
      
          profile = PyProjectProfile(
              requires_min_python=requires_min_python,
              runtime_requirements=runtime_requirements,
              dev_requirements=dev_requirements,
              step_include=step_include,
              step_exclude=step_exclude,
              step_options=step_options,
              auto_install=auto_install,
              linter_contracts=linter_contracts,
              pyproject_data=data,
          )
          return profile
  - rel_path: tools/setup/logging.py
    hash: b50bb25900b62e0e66ca3b56683236272e4709b9fd933e2eed86d7193f45d527
    content: |
      """
      Fehlerprotokollierung für den Setup-Prozess.
      
      Dieses Modul stellt eine schlanke `ErrorLog`-Klasse bereit, die Einträge
      in eine Log-Datei des Setup-Prozesses schreibt.
      """
      from __future__ import annotations
      
      from dataclasses import dataclass, field
      from pathlib import Path
      
      
      @dataclass(slots=True)
      class ErrorLog:
          """
          Einfache Fehlerprotokollierung in eine Textdatei.
      
          Die Klasse kapselt die I/O-Logik und wird von den Setup-Schritten
          genutzt, um technische Details konsistent zu protokollieren.
          """
      
          path: Path = field()
      
          def write_error(self, section: str, message: str, details: str | None = None) -> None:
              """
              Schreibt einen Fehlerabschnitt in die Log-Datei.
      
              Parameter:
                  section:
                      Grober Kontext des Fehlers (z. B. 'pytest', 'Import-Linter').
                  message:
                      Kurzbeschreibung des Fehlers.
                  details:
                      Optionaler, ausführlicherer Text (z. B. stdout/stderr).
              """
              lines: list[str] = [
                  "",
                  f"[SECTION] {section}",
                  f"[MESSAGE] {message}",
              ]
      
              if details:
                  lines.append("[DETAILS]")
                  lines.append(details)
      
              lines.append("")
      
              with self.path.open("a", encoding="utf-8") as log_file:
                  log_file.write("\n".join(lines))
  - rel_path: tools/setup/steps/__init__.py
    hash: d367922daa7ac8b9c1ff1093cd43106f16603fd7484c7310a62a83113a538fc7
    content: |
      from __future__ import annotations
      
      """
      Fassade für die Setup-Schritte der UFO-Simulation.
      
      Dieses Paket bündelt die von außen genutzten Funktionen der einzelnen
      Setup-Step-Module und stellt einen stabilen Importpunkt für den Bootstrap
      bereit.
      """
      
      from .base import BaseStep
      from .create_env import CreateEnvStep
      from .install_deps import InstallDepsStep
      from .linter_check import EvaluateImportsStep
      from .test_runner import RunTestsStep
      
      STEPS: tuple[type[BaseStep[object]], ...] = (
          CreateEnvStep,
          InstallDepsStep,
          EvaluateImportsStep,
          RunTestsStep,
      )
      
      __all__ = [cls.__name__ for cls in STEPS]
  - rel_path: tools/setup/steps/base/__init__.py
    hash: 2705d415da775bbe99b1076451d3b952486410fc60d56780169c91716e80015d
    content: |
      # tools/setup/steps/base/__init__.py
      from __future__ import annotations
      
      """
      Basis-API für Setup-Schritte.
      
      Bündelt die zentrale Step-Basis und den StepContext.
      """
      
      from .step import BaseStep
      from .meta import StepContext
      
      __all__: list[str] = [
          "BaseStep",
          "StepContext",
      ]
  - rel_path: tools/setup/steps/base/meta.py
    hash: 0e53489143a0c316af8dafa09a5647860a9ee9622309e7b6dbaf1d4a94e37dc5
    content: |
      # tools/setup/steps/base/meta.py
      from __future__ import annotations
      
      import re
      from abc import ABCMeta
      from dataclasses import dataclass
      from typing import Any, TYPE_CHECKING
      
      from tools.setup.domain import BootstrapConfig, PyProjectProfile
      from tools.setup.logging import ErrorLog
      from tools.setup.ui import SetupConsole
      
      if TYPE_CHECKING:
          # Nur für Typprüfer; zur Laufzeit kein Import → kein Zirkel.
          from tools.setup.steps.base import BaseStep
      
      _STID_PATTERN = re.compile(r"^[a-z0-9_]+$")
      
      
      @dataclass(slots=True)
      class StepContext:
          """
          Gemeinsamer Ausführungskontext für Setup-Schritte.
          """
      
          config: BootstrapConfig
          profile: PyProjectProfile
          console: SetupConsole
          log: ErrorLog
      
      
      class BaseStepMeta(ABCMeta):
          """
          Metaklasse für Setup-Steps.
      
          Validiert:
          - stid existiert und ist ein String
          - stid erfüllt das Pattern [a-z0-9_]+
          - stid ist über alle Steps eindeutig
          """
      
          # Für Debug/Inspektion reicht ein „breiter“ Typ:
          _registry: dict[str, type[Any]] = {}
      
          def __init__(
                  cls,
                  name: str,
                  bases: tuple[type, ...],
                  namespace: dict[str, Any],
                  **kwargs: Any,  # type: ignore[override]
          ) -> None:
              # WICHTIG: keine @dataclass-Dekoration auf der Metaklasse selbst,
              # damit super().__init__ sauber den ABCMeta/type-MRO-Pfad nutzt.
              super().__init__(name, bases, namespace, **kwargs)
      
              # Basis-Klasse selbst nicht validieren
              if name == "BaseStep":
                  return
      
              registry = BaseStepMeta._registry
      
              # ------------------------------------------------------------
              # Sonderfall: dataclass(slots=True) erzeugt Klasse intern neu.
              # Beim zweiten Aufruf kommt eine Klasse mit gleichem Namen und
              # Modul, aber die Attribute (z.B. stid) sind bereits Deskriptoren.
              # -> In diesem Fall NICHT neu validieren, sondern die bereits
              #    registrierte Klasse durch die neue ersetzen.
              # ------------------------------------------------------------
              for existing_stid, existing_cls in list(registry.items()):
                  if (
                          existing_cls.__name__ == cls.__name__
                          and existing_cls.__module__ == cls.__module__
                          and existing_cls is not cls
                  ):
                      registry[existing_stid] = cls
                      return
      
              # Normalfall: erste Definition dieser Step-Klasse
              stid = getattr(cls, "stid", None)
      
              if not isinstance(stid, str) or not _STID_PATTERN.fullmatch(stid):
                  raise ValueError(
                      f"Step {name} hat eine ungültige stid {stid!r} – "
                      "erlaubt sind nur Kleinbuchstaben, Ziffern und Unterstrich."
                  )
      
              if stid in registry and registry[stid] is not cls:
                  other = registry[stid].__name__
                  raise ValueError(
                      f"Step {name} verwendet stid {stid!r}, "
                      f"die bereits von {other} genutzt wird."
                  )
      
              registry[stid] = cls  # type: ignore[assignment]
      
          @classmethod
          def registry(mcls) -> dict[str, type[Any]]:
              """Optionale Debug-API, falls du die registrierten Steps inspizieren willst."""
              return dict(mcls._registry)
  - rel_path: tools/setup/steps/base/step.py
    hash: 04fd3395784ea944c1cd6ee3de12d53cfb3112d4cb430df17a30347be230b46c
    content: |
      # tools/setup/steps/base/step.py
      from __future__ import annotations
      
      import time
      import traceback
      from collections.abc import Sized
      from abc import ABC, abstractmethod
      from dataclasses import dataclass
      from typing import ClassVar, Generic, Iterable, TypeVar, Mapping, Any
      
      from tools.setup.steps.base.meta import BaseStepMeta, StepContext
      from tools.setup.ui import CATALOG
      from tools.setup.ui.progress import ProgressMode, ProgressStep
      from tools.setup.ui.output.error import error
      
      T = TypeVar("T")  # Typ des prepare()-Ergebnisses
      
      
      @dataclass(slots=True)
      class BaseStep(Generic[T], ABC, metaclass=BaseStepMeta):
          """
          Abstrakte Basis eines Setup-Schritts.
      
          Vereinheitlicht:
          - Vorbereitungsphase (prepare)
          - fachliche Ausführung (step)
          - zentralen Orchestrator (run)
          """
      
          # Instanzzustand
          mode: ProgressMode = ProgressMode.AUTO
      
          # Metadaten – Klassenattribute, NICHT Dataclass-Felder
          stid: ClassVar[str] = "generic"
          priority: ClassVar[int] = 0
      
          @property
          def name(self) -> str:
              return type(self).__name__
      
          @property
          def auto_install(self) -> bool:
              """
              Flag für automatische Installation in prepare().
              Default: False – Steps überschreiben bei Bedarf.
              Globale Voreinstellung kann über ctx.profile.auto_install interpretiert werden.
              """
              return False
      
          # ------------------------------------------------------------
          # Konfig-/Text-Helfer
          # ------------------------------------------------------------
      
          def options(self, ctx: StepContext) -> dict[str, object]:
              """
              Liefert Step-spezifische Optionen aus [tool.setup.options.<stid>].
      
              Beispiel-TOML:
                  [tool.setup.options.tests]
                  marker = "not slow"
                  max-workers = 4
              """
              raw: Mapping[str, Any] | None = ctx.profile.step_options.get(self.stid)
              return dict(raw or {})
      
          def output(
                  self,
                  ctx: StepContext,
                  *,
                  field: str = "default",
                  **extra: object,
          ) -> str:
              """
              Liefert einen formatierten Text aus setup_ui.toml mit Fallback.
      
              Für field="header":
                  - texts.<StepName>.header
                  - texts.step_default.header
                  - Fallback: "Setup-{stid} {StepName}"
      
              Für andere Felder:
                  - texts.<StepName>.<field>
                  - texts.step_default.<field>
                  - Fallback: "StepName: status – cause"
              """
              placeholders: dict[str, object] = {
                  "step": self.name,
                  "env": ctx.config.platform.name,
                  "type": self.stid,
                  "module": self.name,
                  **extra,
              }
      
              status = str(extra.get("status", "")).strip()
              cause = str(extra.get("cause", "")).strip()
              parts = [p for p in (status, cause) if p]
      
              if field == "header":
                  fallback = f"Setup-{self.stid} {self.name}"
              else:
                  fallback = f"{self.name}: {' – '.join(parts)}" if parts else self.name
      
              for block in (self.name, "step_default"):
                  if text := CATALOG.format(block, field=field, default="", **placeholders):
                      return text
      
              return fallback
      
          from collections.abc import Sized
          ...
      
          def estimate_total(self, prepared: T | None) -> int | None:
              """
              Liefert eine Schätzung der Anzahl Arbeitseinheiten für den Progress-Balken.
              Diese Methode dient der notwendigkeit bei Spezialfällen, wenn diese Semantik
              nicht passt (z.B. leere Collection soll trotzdem als 1 Einheit gelten).
              """
              if prepared is None:
                  return None
      
              if isinstance(prepared, Sized):
                  return len(prepared)
      
              # einzelnes, nicht-sized Objekt → eine logische Einheit
              return 1
      
          # noinspection PyMethodMayBeStatic
          def _ensure(
                  self,
                  ctx: StepContext,
                  *,
                  spec: str | None = None,
                  cmd: Iterable[str] | None = None,
          ) -> bool:
              """
              Führe eine Installation über tools.setup.utils.install aus.
      
              Entweder:
                  _ensure(ctx, spec="paket")
              oder:
                  _ensure(ctx, cmd=("sh", "-c", "..."))
              """
              from tools.setup.utils import install  # Fassade
      
              assert (spec is not None) ^ (cmd is not None)
      
              kwargs: dict[str, object] = {"cmd": cmd} if cmd else {
                  "python": str(ctx.config.venv_python),
                  "spec": spec,
              }
      
              rc, *_ = install(
                  cwd=ctx.config.repo_root,
                  **kwargs,
              )
              return rc == 0
      
          # ------------------------------------------------------------
          # Template-Method
          # ------------------------------------------------------------
      
          def prepare(self, ctx: StepContext) -> T | None:
              """
              Optionaler Vorbereitungsschritt.
      
              Default: nichts vorbereiten – Subklassen überschreiben.
              """
              return None
      
          @abstractmethod
          def step(
                  self,
                  ctx: StepContext,
                  prepared: T | None,
                  progress: ProgressStep | None,
          ) -> bool:
              """
              Fachlicher Kern des Schritts.
      
              Rückgabe:
                  True  → Step erfolgreich
                  False → Step fehlgeschlagen
              """
              raise NotImplementedError
      
          # ------------------------------------------------------------
          # Orchestrator
          # ------------------------------------------------------------
      
          def run(self, ctx: StepContext) -> bool:
              prepared = self.prepare(ctx)
      
              header_text = self.output(ctx, field="header")
              if not header_text:
                  header_text = f"Setup-{self.stid} {self.name}"
      
              with self.mode.make_context(header_text, ctx.console) as progress:
                  # Total generisch aus prepared ableiten
                  if progress is not None:
                      total_hint = self.estimate_total(prepared)
                      if total_hint is not None:
                          progress.set_total(total_hint)
      
                  try:
                      ok = self.step(ctx, prepared, progress)
                  except BaseException as exc:
                      exc_type_name = type(exc).__name__
                      exc_message = str(exc) or repr(exc)
                      tb_text = "".join(
                          traceback.format_exception(type(exc), exc, exc.__traceback__)
                      )
      
                      msg = self.output(
                          ctx,
                          field="failure",
                          cause=exc_type_name,
                          details=exc_message,
                      )
      
                      if progress is not None:
                          progress.set_status(msg)
                          progress.mark_failed()
      
                      # YAML-Fehlerblock bauen und auf Konsole schreiben
                      block = error(
                          step=self.name,
                          stid=self.stid,
                          exc_type=exc_type_name,
                          message=exc_message,
                          traceback_text=tb_text,
                      )
                      ctx.console.error(block)
      
                      ctx.log.write_error(
                          section=self.name,
                          message=msg,
                          details=tb_text,
                      )
                      return False
      
                  if progress is not None:
                      total = getattr(progress, "total", None)
                      completed = getattr(progress, "completed", 0)
      
                      if total and completed < total:
                          progress.advance(total - completed)  # type: ignore[arg-type]
      
                      if ok:
                          progress.mark_finished()
                      else:
                          progress.mark_failed()
      
                  time.sleep(1.5)
                  return ok
  - rel_path: tools/setup/steps/create_env.py
    hash: 77f9a9c248d454215a90b5375eeab726e6db85a7291123f92c55024b1c1db9e6
    content: |
      # tools/setup/steps/create_env.py
      from __future__ import annotations
      
      import sys
      from dataclasses import dataclass
      from typing import override
      
      from tools.setup.steps.base import BaseStep, StepContext
      from tools.setup.ui.progress import ProgressStep
      from tools.setup.utils.version import check_python_version, ensure_venv
      
      
      @dataclass(slots=True)
      class CreateEnvStep(BaseStep[None]):
          """
          Setup-Schritt zum Erzeugen der Projekt-Virtualenv.
          """
      
          stid = "create_env"
          priority = sys.maxsize - 1000
      
          @override
          def step(
                  self,
                  ctx: StepContext,
                  _prepared: None,
                  progress: ProgressStep | None,
          ) -> bool:
              # 1) Python-Version prüfen
              ok, cause, details = check_python_version(ctx)
              if not ok:
                  msg = self.output(
                      ctx,
                      field="failure",
                      cause=cause,
                      details=details,
                  )
                  if progress is not None:
                      progress.set_status(msg)
                  ctx.log.write_error(
                      section=self.name,
                      message=msg,
                      details=details,
                  )
                  return False
      
              # 2) venv erzeugen
              ok, cause, details = ensure_venv(ctx, True)
              field = "success" if ok else "failure"
              msg = self.output(
                  ctx,
                  field=field,
                  cause=cause,
                  details=details,
              )
      
              if progress is not None:
                  progress.set_status(msg)
      
              if not ok:
                  ctx.log.write_error(
                      section=self.name,
                      message=msg,
                      details=details,
                  )
      
              return ok
  - rel_path: tools/setup/steps/install_deps.py
    hash: 41f01bab11b775343b8967d03840ce1f7752a88b06d04e4a6e6df3e12029d772
    content: |
      from __future__ import annotations
      
      from collections.abc import Sequence
      from dataclasses import dataclass
      from typing import Final, override
      
      from tools.setup.steps.base import BaseStep, StepContext
      from tools.setup.ui import CATALOG
      from tools.setup.ui.progress import ProgressStep
      from tools.setup.utils import run_command, short_output
      
      Command = tuple[tuple[str, ...], str]  # (argv, label)
      
      
      @dataclass(slots=True)
      class InstallDepsStep(BaseStep[Sequence[Command]]):
          """
          Setup-Schritt zur Installation der Projekt-Abhängigkeiten aus pyproject.toml.
      
          Strategie:
          - Projekt im Editable-Modus installieren: python -m pip install -e .
          - Laufzeit-Dependencies aus [project].dependencies einzeln installieren
          - Dev-Dependencies aus [project.optional-dependencies].dev einzeln installieren
          """
      
          stid = "dependencies"
          priority = 9999
      
          @override
          def prepare(self, ctx: StepContext) -> Sequence[Command]:
              python = str(ctx.config.venv_python)
      
              runtime = ctx.profile.runtime_requirements
              dev = ctx.profile.dev_requirements
      
              def build_spec(name: str, spec: str) -> str:
                  return f"{name}{spec}" if spec else name
      
              commands: list[Command] = [((python, "-m", "pip", "install", "-e", "."), "Projekt (editable)",)]
      
              for name, spec in runtime.items():
                  pkg_spec = build_spec(name, spec)
                  commands.append(((python, "-m", "pip", "install", pkg_spec), pkg_spec))
      
              for name, spec in dev.items():
                  pkg_spec = build_spec(name, spec)
                  commands.append(((python, "-m", "pip", "install", pkg_spec), pkg_spec))
      
              return tuple(commands)
      
          @override
          def step(
                  self,
                  ctx: StepContext,
                  prepared: Sequence[Command] | None,
                  progress: ProgressStep | None,
          ) -> bool:
              assert prepared is not None, "InstallDepsStep.prepare() muss Commands liefern."
      
              cwd = str(ctx.config.repo_root)
              total = len(prepared) or 1
      
              def fmt(field: str, default: str, **kwargs: object) -> str:
                  return CATALOG.format(
                      "step_default",
                      field=field,
                      default=default,
                      **kwargs,
                  )
      
              def set_status(field: str, default: str, **kwargs: object) -> None:
                  if progress:
                      progress.set_status(fmt(field=field, default=default, **kwargs))
      
              for index, (argv, label) in enumerate(prepared, start=1):
                  set_status(
                      "progress_running",
                      "Running  /   {details}",
                      details=fmt(
                          "install_details",
                          "Installiere: {package} ({index}/{total})",
                          package=label,
                          index=index,
                          total=total,
                      ),
                  )
      
                  result = run_command(argv, cwd=cwd)
                  raw = (result.stdout or "") + (result.stderr or "")
      
                  if result.returncode != 0:
                      details_text = short_output(raw) or raw or "keine Ausgabe"
      
                      set_status(
                          "progress_failed",
                          "Failed   /   {details}",
                          details=fmt(
                              "install_failed",
                              "{package}: {details}",
                              package=label,
                              details=details_text,
                          ),
                      )
                      if progress:
                          progress.mark_failed()
      
                      msg = self.output(
                          ctx,
                          field="failure",
                          cause="pip_install_failed",
                          details=details_text,
                      )
                      ctx.log.write_error(
                          section=self.name,
                          message=msg,
                          details=raw or "keine Ausgabe",
                      )
                      return False
      
                  if progress:
                      progress.advance(1)
      
              set_status(
                  "progress_finished",
                  "Finished /   {details}",
                  details=fmt(
                      "install_done",
                      "Alle Abhängigkeiten installiert.",
                  ),
              )
      
              if progress:
                  progress.mark_finished()
      
              return True
  - rel_path: tools/setup/steps/linter_check.py
    hash: f752659e6a9b0382edaf14008b8364f19fbf741853a3581800db2ddfeef1c8eb
    content: |
      # tools/setup/steps/linter_check.py
      from __future__ import annotations
      
      from dataclasses import dataclass
      from typing import Any, override
      from collections.abc import Mapping
      
      from tools.setup.steps.base import BaseStep, StepContext
      from tools.setup.ui.progress import ProgressStep
      from tools.setup.ui import CATALOG
      from tools.setup.utils import module
      
      
      @dataclass(slots=True)
      class EvaluateImportsStep(BaseStep[tuple[str, ...]]):
          """
          Setup-Schritt zum Ausführen von import-linter (Import-Regelprüfung).
      
          Design:
          - prepare()
              * prüft, ob importlinter.cli aufrufbar ist (Probe).
              * versucht bei Bedarf Auto-Installation.
              * liest Contracts aus dem bereits geladenen PyProjectProfile und gibt
                die Contract-Namen als Arbeitseinheiten zurück, gefiltert nach
                [tool.setup.linter].contracts.
          - estimate_total()
              * leitet die Progress-Balkenlänge aus der Anzahl Contracts ab.
          - step()
              * führt import-linter pro Contract logisch als eigene Einheit aus und
                aktualisiert den Fortschritt/Status entsprechend.
          """
      
          stid = "import_linter"
          priority = 40
      
          @override
          @property
          def auto_install(self) -> bool:
              """import-linter darf bei Bedarf automatisch nachinstalliert werden."""
              return True
      
          # -------------------------------------------------------------
          # Hilfsfunktionen
          # -------------------------------------------------------------
          def _collect_contracts(self, ctx: StepContext) -> tuple[str, ...]:
              """
              Versucht, Contract-Namen aus dem bereits geladenen PyProjectProfile
              zu extrahieren und anhand von [tool.setup.linter].contracts zu filtern.
      
              Erwartete (vereinfachte) Struktur in pyproject.toml:
      
                  [tool.importlinter]
                  root_package = "..."
      
                  [[tool.importlinter.contracts]]
                  name = "Contract 1"
                  type = "forbidden" | "layers" | ...
      
              Rückgabe:
                  Tuple aller gefundenen Contract-Namen nach Filterung.
                  Fallback: leeres Tuple, falls nichts gefunden werden kann.
              """
              contracts_raw: Any = ctx.profile.get_path(
                  "tool",
                  "importlinter",
                  "contracts",
                  default=[],
              )
              if not isinstance(contracts_raw, list):
                  return ()
      
              mode = ctx.profile.linter_contracts  # "all" | "forbidden" | "layers"
              names: list[str] = []
      
              for item in contracts_raw:
                  if not isinstance(item, Mapping):
                      continue
      
                  type_value = str(item.get("type", "")).strip().lower()
      
                  if mode == "forbidden" and type_value != "forbidden":
                      continue
                  if mode == "layers" and type_value != "layers":
                      continue
                  # mode == "all" → kein Filter auf type
      
                  name = item.get("name")
                  if isinstance(name, str):
                      stripped = name.strip()
                      if stripped:
                          names.append(stripped)
      
              return tuple(names)
      
          @override
          def prepare(self, ctx: StepContext) -> tuple[str, ...]:
              """
              Prüft importlinter.cli, versucht ggf. Auto-Installation und liefert
              die Contract-Namen als Arbeitseinheiten.
              """
              python = str(ctx.config.venv_python)
              cwd = ctx.config.repo_root
      
              def probe() -> tuple[bool, str, str | None]:
                  return module.evaluate(
                      python=python,
                      module="importlinter.cli",
                      cwd=cwd,
                      extra_args=("--help",),
                  )
      
              def fail(prefix: str, exc_info: str | None, output: str) -> None:
                  cause, details = module.classify(
                      exc_info=exc_info,
                      output=output,
                      module="importlinter",
                  )
                  text = details or output or ""
                  msg = self.output(ctx, field="failure", cause=cause, details=text)
                  ctx.log.write_error(section=self.name, message=msg, details=text)
                  raise RuntimeError(f"{prefix}: {cause}: {details}")
      
              # 1. Probe
              ok, output, exc_info = probe()
      
              # 2. Optional: Auto-Installation + erneute Probe
              if self.auto_install and not ok:
                  rc, raw_install, _short_install = module.install(
                      python=python,
                      spec="import-linter",
                      cwd=cwd,
                  )
                  ok_install = rc == 0
                  if not ok_install:
                      fail(
                          "import-linter konnte nicht installiert werden",
                          exc_info=None,
                          output=raw_install,
                      )
      
                  ok, output, exc_info = probe()
      
              # 3. Finale Prüfung
              if not ok:
                  fail(
                      "import-linter Probe fehlgeschlagen",
                      exc_info=exc_info,
                      output=output,
                  )
      
              # Contracts kommen jetzt ausschließlich aus dem bereits geladenen Profil
              return self._collect_contracts(ctx)
      
          @override
          def estimate_total(self, prepared: tuple[str, ...] | None) -> int | None:
              if prepared:
                  return len(prepared)
      
              return 1
      
          @override
          def step(
                  self,
                  ctx: StepContext,
                  prepared: tuple[str, ...] | None,
                  progress: ProgressStep | None,
          ) -> bool:
      
              python = str(ctx.config.venv_python)
              cwd = ctx.config.repo_root
      
              contracts = prepared or tuple()
              if not contracts:
                  # Fallback: eine logische Einheit, z. B. "Gesamtkonfiguration"
                  contracts = ("Konfigurationsprüfung",)
      
              total = len(contracts)
      
              ok_overall = True
              cause = ""
              details = ""
              last_output = ""
      
              for index, contract in enumerate(contracts, start=1):
                  if progress is not None:
                      contract_details = CATALOG.format(
                          "ImportLinterStep",
                          field="import_details",
                          default="Contract {index}/{total}: {contract}",
                          index=index,
                          total=total,
                          contract=contract,
                      )
                      running = CATALOG.format(
                          "step_default",
                          field="progress_running",
                          default="Running  /   {details}",
                          details=contract_details,
                      )
                      progress.set_status(running)
      
                  # Technisch wird hier die gesamte Konfiguration geprüft – die
                  # Contract-Namen dienen primär der Visualisierung.
                  ok, output, exc_info = module.evaluate(
                      python=python,
                      module="importlinter.cli",
                      cwd=cwd,
                      extra_args=(),
                  )
                  last_output = output or ""
      
                  if not ok:
                      kind, det = module.classify(
                          exc_info=exc_info,
                          output=output,
                          module="importlinter",
                      )
                      ok_overall = False
                      cause = kind
                      details = det or output or "keine Ausgabe"
      
                  if progress is not None:
                      progress.advance(1)
      
                  if not ok:
                      break
      
              msg = self.output(
                  ctx,
                  field="success" if ok_overall else "failure",
                  cause=cause,
                  details=details or last_output or "",
              )
      
              if progress is not None:
                  field = "import_done" if ok_overall else "import_failed"
                  default_details = (
                      "Alle Import-Regeln eingehalten."
                      if ok_overall
                      else "Import-Regeln verletzt – Details siehe Log."
                  )
                  details_text = CATALOG.format(
                      "ImportLinterStep",
                      field=field,
                      default=default_details,
                  )
      
                  status_field = "progress_finished" if ok_overall else "progress_failed"
                  status_default = (
                      "Finished /   {details}"
                      if ok_overall
                      else "Failed   /   {details}"
                  )
      
                  progress.set_status(
                      CATALOG.format(
                          "step_default",
                          field=status_field,
                          default=status_default,
                          details=details_text,
                      )
                  )
      
              if not ok_overall:
                  ctx.log.write_error(
                      section=self.name,
                      message=msg,
                      details=details or last_output or "",
                  )
      
              return ok_overall
  - rel_path: tools/setup/steps/test_runner.py
    hash: 4997a23ae91a8120b0013b13b12bc954ab06644d2b2cfdca74315853689ac3df
    content: |
      # tools/setup/steps/test_runner.py
      from __future__ import annotations
      
      from dataclasses import dataclass
      from typing import override
      
      from tools.setup.steps.base import BaseStep, StepContext
      from tools.setup.ui.progress import ProgressStep
      from tools.setup.ui import CATALOG
      from tools.setup.utils import module
      
      
      @dataclass(slots=True)
      class RunTestsStep(BaseStep[tuple[str, ...]]):
          """
          Setup-Schritt zum Ausführen der Test-Suite via pytest.
      
          Design:
          - prepare() sammelt alle Test-NodeIDs via "pytest --collect-only -q".
          - estimate_total() leitet die Balkenlänge aus der Anzahl Tests ab.
          - step() führt jeden Test einzeln aus und aktualisiert Progress/Status.
          """
      
          stid = "tests"
          priority = 0
      
          @override
          def prepare(self, ctx: StepContext) -> tuple[str, ...]:
              """Sammelt alle Test-NodeIDs, die später als Arbeitseinheiten dienen."""
              ok, output, exc_info = module.evaluate(
                  python=str(ctx.config.venv_python),
                  module="pytest",
                  cwd=ctx.config.repo_root,
                  extra_args=("--collect-only", "-q"),
              )
      
              if not ok:
                  kind, details = module.classify(
                      exc_info=exc_info,
                      output=output,
                      module="pytest",
                  )
                  msg = self.output(
                      ctx,
                      field="failure",
                      cause=kind,
                      details=details or output or "pytest --collect-only fehlgeschlagen",
                  )
                  ctx.log.write_error(
                      section=self.name,
                      message=msg,
                      details=details or output or "",
                  )
                  # Harte Exception → BaseStep.run() behandelt das wie einen Step-Fehler
                  raise RuntimeError(f"pytest Collect-Phase fehlgeschlagen: {kind}: {details}")
      
              tests: list[str] = []
              for line in (output or "").splitlines():
                  stripped = line.strip()
                  if not stripped:
                      continue
                  # Grober Filter: pytest gibt bei -q pro Test üblicherweise eine NodeID aus.
                  if stripped.startswith(("collected ", "<", "=")):
                      continue
                  tests.append(stripped)
      
              return tuple(tests)
      
          @override
          def step(
                  self,
                  ctx: StepContext,
                  prepared: tuple[str, ...] | None,
                  progress: ProgressStep | None,
          ) -> bool:
              tests = prepared or tuple()
              python = str(ctx.config.venv_python)
              cwd = ctx.config.repo_root
      
              # Fall: keine Tests gefunden → einmaliger pytest-Run als Fallback.
              if not tests:
                  ok, output, exc_info = module.evaluate(
                      python=python,
                      module="pytest",
                      cwd=cwd,
                      extra_args=(),
                  )
      
                  cause = ""
                  details = ""
      
                  match exc_info, ok:
                      case str() as err, _:
                          cause = "tests_running_error"
                          details = err
                      case None, False:
                          cause = "tests_failed"
                          details = output or "keine Ausgabe"
      
                  msg = self.output(
                      ctx,
                      field="success" if ok else "failure",
                      cause=cause,
                      details=details,
                  )
      
                  if progress is not None:
                      # Status über CATALOG (Running/Finished/Failed) aktualisieren
                      field = "progress_finished" if ok else "progress_failed"
                      default = (
                          "Finished /   Alle Tests erfolgreich."
                          if ok
                          else "Failed   /   Tests fehlgeschlagen – Details siehe Log."
                      )
                      progress.set_status(
                          CATALOG.format(
                              "step_default",
                              field=field,
                              default=default,
                              details=details or output or "",
                          )
                      )
      
                  if not ok:
                      ctx.log.write_error(
                          section=self.name,
                          message=msg,
                          details=details or output or "",
                      )
      
                  return ok
      
              total = len(tests)
              ok_overall = True
              cause = ""
              details = ""
              last_output = ""
      
              for index, nodeid in enumerate(tests, start=1):
                  # Fortschritts-Text: konkreter Testname
                  if progress is not None:
                      test_details = CATALOG.format(
                          "RunTestsStep",
                          field="test_details",
                          default="Test {index}/{total}: {test}",
                          index=index,
                          total=total,
                          test=nodeid,
                      )
                      running = CATALOG.format(
                          "step_default",
                          field="progress_running",
                          default="Running  /   {details}",
                          details=test_details,
                      )
                      progress.set_status(running)
      
                  ok, output, exc_info = module.evaluate(
                      python=python,
                      module="pytest",
                      cwd=cwd,
                      extra_args=(nodeid,),
                  )
                  last_output = output or ""
      
                  test_cause = ""
                  test_details = ""
      
                  match exc_info, ok:
                      case str() as err, _:
                          test_cause = "tests_running_error"
                          test_details = err
                      case None, False:
                          test_cause = "tests_failed"
                          test_details = output or "keine Ausgabe"
      
                  if progress is not None:
                      progress.advance(1)
      
                  if not ok:
                      ok_overall = False
                      cause = test_cause
                      details = test_details
                      break
      
              msg = self.output(
                  ctx,
                  field="success" if ok_overall else "failure",
                  cause=cause,
                  details=details or last_output or "",
              )
      
              # Finaler Status unter dem Balken
              if progress is not None:
                  field = "tests_done" if ok_overall else "tests_failed"
                  default_details = (
                      "Alle Tests erfolgreich."
                      if ok_overall
                      else "Tests fehlgeschlagen – Details siehe Log."
                  )
                  details_text = CATALOG.format(
                      "RunTestsStep",
                      field=field,
                      default=default_details,
                  )
      
                  status_field = "progress_finished" if ok_overall else "progress_failed"
                  status_default = (
                      "Finished /   {details}"
                      if ok_overall
                      else "Failed   /   {details}"
                  )
      
                  progress.set_status(
                      CATALOG.format(
                          "step_default",
                          field=status_field,
                          default=status_default,
                          details=details_text,
                      )
                  )
      
              if not ok_overall:
                  ctx.log.write_error(
                      section=self.name,
                      message=msg,
                      details=details or last_output or "",
                  )
      
              return ok_overall
  - rel_path: tools/setup/ui/__init__.py
    hash: 1f0e990a42b38bada39f55fa230ab7ec4893132e45b372fff25fd7439766aa06
    content: |
      # tools/setup/ui/__init__.py
      from __future__ import annotations
      
      """
      Öffentliche UI-Schnittstellen für das Setup.
      """
      
      from tools.setup.ui.console import SetupConsole
      
      from tools.setup.ui.progress.step import ProgressStep
      from tools.setup.ui.progress.mode import ProgressMode
      
      from tools.setup.ui.resources import (
          TextBlock,
          TextCatalog,
          CATALOG,
      )
      from tools.setup.ui.resources.icons import (
          MessageLevel,
          ProgressStatus,
      )
      
      __all__ = [
          "SetupConsole",
          "ProgressStep",
          "ProgressMode",
          "TextBlock",
          "TextCatalog",
          "CATALOG",
          "MessageLevel",
          "ProgressStatus",
      ]
  - rel_path: tools/setup/ui/console.py
    hash: fcc6221481c58b49330e3afb9d92fdf5e8f24c8ac90b197b6ccd743ed039b2aa
    content: |
      # tools/setup/ui/console.py
      from __future__ import annotations
      
      from dataclasses import dataclass
      
      from tools.setup.ui.resources.icons import MessageLevel
      
      
      @dataclass(slots=True)
      class SetupConsole:
          """
          Schlankes Konsolen-Frontend für das Setup ohne externe Abhängigkeiten.
      
          Bietet eine kleine, klar definierte API für Setup-Schritte.
          """
      
          # noinspection PyMethodMayBeStatic
          def _emit(self, level: MessageLevel, message: str) -> None:
              prefix = level.icon
              line = f"{prefix} {message}" if prefix else message
              print(line)
      
          # öffentliche API – von Steps verwendet
          def info(self, message: str) -> None:
              self._emit(MessageLevel.INFO, message)
      
          def warning(self, message: str) -> None:
              self._emit(MessageLevel.WARNING, message)
      
          def error(self, message: str) -> None:
              self._emit(MessageLevel.ERROR, message)
      
          def result(self, message: str, ok: bool) -> None:
              level = MessageLevel.SUCCESS if ok else MessageLevel.ERROR
              self._emit(level, message)
      
          # noinspection PyMethodMayBeStatic
          def header(self, message: str) -> None:
              # Header bewusst ohne Level-Icon, um die Einleitung nicht zu überfrachten
              print(message)
  - rel_path: tools/setup/ui/output/__init__.py
    hash: 1acc797a9f8afa2cbb5f3f09f2789e5297b7fef7ebac47d56af8b92d9be1da27
    content: |
      from __future__ import annotations
      
      from .message import Message
      from .error import error
      
      __all__ = ["Message", "error"]
  - rel_path: tools/setup/ui/output/error.py
    hash: e9759ec28788a5b13412b729d73d4e6975a8c2862af81011142c7dae823403f2
    content: |
      # tools/setup/ui/error.py
      from __future__ import annotations
      
      from datetime import datetime, timezone
      
      
      def error(
              *,
              step: str,
              stid: str,
              exc_type: str,
              message: str,
              traceback_text: str,
              timestamp: datetime | None = None,
      ) -> str:
          ts = timestamp or datetime.now(timezone.utc)
          iso = ts.isoformat(timespec="seconds")
      
          lines: list[str] = [
              "error:",
              f"  step: {step}",
              f"  stid: {stid}",
              f"  type: {exc_type}",
              f"  message: {message}",
              "  traceback: |",
          ]
          for line in traceback_text.rstrip().splitlines():
              lines.append(f"    {line}")
          lines.append(f"  timestamp: {iso}")
          lines.append("")
      
          return "\n".join(lines)
  - rel_path: tools/setup/ui/output/message.py
    hash: 40938c752242a38be547f32290ab972d8cd7e9224893ff37087e879cf396991d
    content: |
      from __future__ import annotations
      
      """
      Strukturiertes Nachrichtenmodell für die Setup-Konsole.
      
      Dieses Modul kapselt den Nachrichtentyp, der von der SetupConsole
      für eine einheitliche Ausgabe verwendet wird.
      """
      
      from dataclasses import dataclass
      
      from tools.setup.ui.resources.icons import MessageLevel
      
      
      @dataclass(slots=True, frozen=True)
      class Message:
          """
          Strukturierte Nachricht für die Setup-Konsole.
      
          Attributes:
              level: Logische Stufe der Nachricht (info, success, warning, error, plain).
              content: Auszugebender Nachrichtentext (muss nichtleer sein).
          """
      
          level: MessageLevel
          content: str
      
          def __post_init__(self) -> None:
              if not self.content:
                  raise ValueError("Message.content must not be empty")
  - rel_path: tools/setup/ui/progress/__init__.py
    hash: 180321fb53b6747e9a9e0f70468eaa091a98384f215a79d9fad5b95eb64e12f9
    content: |
      # tools/setup/ui/progress/__init__.py
      from __future__ import annotations
      
      """
      Interne Prozessdarstellungsebene für das Setup.
      
      Dieses Paket bündelt:
      - ProgressStep (Fortschrittsanzeige)
      - ProgressMode (Steuerung des Fortschrittsverhaltens)
      """
      
      from .mode import ProgressMode
      from .step import ProgressStep
      
      __all__: list[str] = ["ProgressMode", "ProgressStep"]
  - rel_path: tools/setup/ui/progress/mode.py
    hash: 873b4c9b85def346d0cf0ee7cc84aa470fcddb53baa5720c29762cae6c19ea38
    content: |
      # tools/setup/ui/progress/mode.py
      from __future__ import annotations
      
      """
      Steuerung des Fortschrittsverhaltens von Setup-Schritten.
      """
      
      from contextlib import nullcontext
      from enum import Enum, auto
      from typing import ContextManager, TYPE_CHECKING
      
      from tools.setup.ui.console import SetupConsole
      
      if TYPE_CHECKING:
          from .step import ProgressStep
      
      
      class ProgressMode(Enum):
          """
          Steuerung des Fortschrittsverhaltens eines Setup-Schritts.
      
          NONE   → keine Fortschrittsanzeige
          AUTO   → Standard-Fortschrittsanzeige
          SIMPLE → aktuell identisch zu AUTO, für spätere Varianten reserviert
          """
      
          NONE = auto()
          AUTO = auto()
          SIMPLE = auto()
      
          def make_context(
                  self,
                  description: str,
                  console: SetupConsole,
          ) -> ContextManager["ProgressStep | None"]:
              """
              Liefert den passenden Kontextmanager:
      
              - NONE  → nullcontext(None) (kein Fortschritt)
              - AUTO/SIMPLE → ProgressStep mit initial indeterminiertem Balken.
              """
              if self is ProgressMode.NONE:
                  return nullcontext(None)
      
              from .step import ProgressStep
      
              return ProgressStep(
                  description=description,
                  total=None,
                  console=console,
              )
  - rel_path: tools/setup/ui/progress/step.py
    hash: e369c77978e25b45b87937cd7003567dc5f3e4526ae73df800f379188f45f6df
    content: |-
      from __future__ import annotations
      
      import sys
      from dataclasses import dataclass, field
      from threading import Lock
      from types import TracebackType
      from typing import Final
      
      from tools.setup.ui.console import SetupConsole
      from tools.setup.ui.resources.icons import ProgressStatus
      
      # einfache ANSI-Farben
      _RESET = "\x1b[0m"
      _GREEN = "\x1b[32m"
      _RED = "\x1b[31m"
      _DIM = "\x1b[2m"
      
      _BAR_WIDTH: Final[int] = 40
      
      
      @dataclass(slots=True)
      class ProgressStep:
          """
          Minimalistisch-moderner Fortschritt:
      
              Setup-<stid> <StepName>: <info>      (header, 1×)
              [██░░…]  42%  ⏳ Running / ...       (eine Zeile, via \\r aktualisiert)
      
          Besonderheit:
          - Sichtbarer Fortschritt läuft immer in 1%-Schritten von alt → neu,
            auch wenn intern Sprünge wie 0 → 17 → 32 ankommen.
          """
      
          description: str
          total: int | None
          console: SetupConsole
      
          _status: ProgressStatus = field(default=ProgressStatus.STARTING, init=False, repr=False)
          _completed: int = field(default=0, init=False, repr=False)
          _status_text: str = field(default="", init=False, repr=False)
          _lock: Lock = field(default_factory=Lock, init=False, repr=False)
      
          _header_printed: bool = field(default=False, init=False, repr=False)
          _last_line: str = field(default="", init=False, repr=False)
      
          # sichtbarer Prozentwert (0–100), unabhängig von _completed
          _display_percent: int = field(default=0, init=False, repr=False)
      
          # ------------------------------------------------------------
          # Eigenschaften, die BaseStep.run erwartet
          # ------------------------------------------------------------
      
          @property
          def completed(self) -> int:
              return self._completed
      
          @property
          def status(self) -> ProgressStatus:
              return self._status
      
          # ------------------------------------------------------------
          # Kontextmanager
          # ------------------------------------------------------------
      
          def __enter__(self) -> "ProgressStep":
              with self._lock:
                  self._status = ProgressStatus.STARTING
                  self._status_text = self._status.label
                  self._completed = 0
                  self._display_percent = 0
                  self._render_locked()
              return self
      
          def __exit__(
              self,
              exc_type: type[BaseException] | None,
              exc: BaseException | None,
              tb: TracebackType | None,
          ) -> bool:
              return False
      
          # ------------------------------------------------------------
          # Öffentliche API für Steps / BaseStep.run
          # ------------------------------------------------------------
      
          def set_total(self, total: int | None) -> None:
              """
              total=None → indeterminiert (Text "Aktueller Schritt …")
              total>0    → deterministischer Prozentbalken
              """
              with self._lock:
                  self.total = total
                  if total is None:
                      self._completed = 0
                      self._display_percent = 0
                  else:
                      self._completed = min(self._completed, total)
                      if self._status is ProgressStatus.STARTING:
                          self._status = ProgressStatus.RUNNING
                          if not self._status_text:
                              self._status_text = self._status.label
                  self._render_locked()
      
          def advance(self, steps: int = 1) -> None:
              """
              Erhöht den logischen Fortschritt um `steps` und rendert neu.
              """
              with self._lock:
                  if self.total and self.total > 0:
                      self._completed = min(self.total, self._completed + steps)
                      if self._status is ProgressStatus.STARTING:
                          self._status = ProgressStatus.RUNNING
                  self._render_locked()
      
          def set_status(self, text: str) -> None:
              """
              Aktualisiert den Status-Text (z. B. "Installiere: Paket X (3/12)").
              """
              with self._lock:
                  self._status_text = text
                  self._render_locked()
      
          def mark_finished(self) -> None:
              with self._lock:
                  self._status = ProgressStatus.FINISHED
                  if self.total and self.total > 0:
                      self._completed = self.total
                  if not self._status_text:
                      self._status_text = self._status.label
                  self._render_locked(final=True)
      
          def mark_failed(self) -> None:
              with self._lock:
                  self._status = ProgressStatus.FAILED
                  if self.total and self.total > 0:
                      self._completed = self.total
                  if not self._status_text:
                      self._status_text = self._status.label
                  self._render_locked(final=True)
      
          def emit_info(self, *, step: str, message: str) -> None:
              """
              Zusatz-Infos, z. B. Debug-Hinweise während des Steps.
              """
              with self._lock:
                  # laufende Progresszeile sauber beenden
                  if self._last_line:
                      sys.stdout.write("\n")
                      sys.stdout.flush()
                      self._last_line = ""
                  print(f"info: {step}: {message}", flush=True)
      
          # ------------------------------------------------------------
          # Rendering-Helfer
          # ------------------------------------------------------------
      
          def _build_header(self) -> str:
              return self.description
      
          def _build_bar_from_percent(self, percent: int | None) -> str:
              """
              Baut den Balken aus einem Prozentwert (0–100) oder indeterminiert.
              """
              if percent is None:
                  return "Aktueller Schritt …"
      
              percent = max(0, min(100, percent))
              filled = int(_BAR_WIDTH * (percent / 100))
              empty = _BAR_WIDTH - filled
              return f"[{'█' * filled}{'░' * empty}] {percent:3d}%"
      
          def _build_status(self) -> str:
              text = self._status_text or self._status.label
              base = f"{self._status.icon} {text}"
      
              if self._status is ProgressStatus.FINISHED:
                  return f"{_GREEN}{base}{_RESET}"
              if self._status is ProgressStatus.FAILED:
                  return f"{_RED}{base}{_RESET}"
              return f"{_DIM}{base}{_RESET}"
      
          def _build_line_for_percent(self, percent: int | None) -> str:
              bar = self._build_bar_from_percent(percent)
              status = self._build_status()
              return f"{bar}  {status}"
      
          # ------------------------------------------------------------
          # Zentrales Rendering
          # ------------------------------------------------------------
      
          def _render_locked(self, *, final: bool = False) -> None:
              """
              Header einmal ausgeben, Fortschritt in 1%-Schritten von alt → neu animieren.
              """
              # Header genau einmal
              if not self._header_printed:
                  print(self._build_header(), flush=True)
                  self._header_printed = True
      
              # indeterminierter Modus: kein % → nur eine Zeile
              if self.total is None or self.total <= 0:
                  line = self._build_line_for_percent(None)
                  if line != self._last_line:
                      sys.stdout.write("\r" + line)
                      sys.stdout.flush()
                      self._last_line = line
                  if final:
                      sys.stdout.write("\n")
                      sys.stdout.flush()
                      self._last_line = ""
                  return
      
              # Ziel-Prozent aus logischem Stand
              target_ratio = self._completed / self.total if self.total else 0.0
              target_percent = max(0, min(100, int(target_ratio * 100)))
      
              # Rückwärtsbewegung clampen
              if target_percent < self._display_percent:
                  self._display_percent = target_percent
      
              # „Animation“: von aktuellem Display-Wert bis Ziel hochzählen
              start = self._display_percent
              end = target_percent
      
              if start == end and not final:
                  # nichts zu tun
                  return
      
              for p in range(start + 1, end + 1) if end > start else [start]:
                  self._display_percent = p
                  line = self._build_line_for_percent(p)
                  # Minimaler Spam-Schutz
                  if line == self._last_line:
                      continue
                  sys.stdout.write("\r" + line)
                  sys.stdout.flush()
                  self._last_line = line
      
              # finaler Abschluss → Zeilenumbruch setzen
              if final:
                  sys.stdout.write("\n")
                  sys.stdout.flush()
                  # self._last_line = ""
  - rel_path: tools/setup/ui/resources/__init__.py
    hash: b88acb9a817a39e4d08ea6d7b4358e3a18b942d5dfb4f2e2d46e04b18d2b4eef
    content: |
      from __future__ import annotations
      
      """
      Ressourcen für UI-Texte und Icons des Setup-Prozesses.
      
      Dieses Unterpaket stellt:
      - :class:`TextBlock` als Basistyp für Textbausteine,
      - :class:`TextCatalog` als TOML-basierte Sammlung von Texten und Icons,
      - :data:`CATALOG` als vorkonfigurierte Standardinstanz
      bereit.
      """
      
      from .block import TextBlock
      from .catalog import TextCatalog, CATALOG
      
      __all__: tuple[str, ...] = (
          "TextBlock",
          "TextCatalog",
          "CATALOG",
      )
  - rel_path: tools/setup/ui/resources/block.py
    hash: 3d4b3633b498a32f6e740d48c3c9f0885ffc67a5a94f16200f1689913f918319
    content: |
      from __future__ import annotations
      
      """
      Grundlegender Textbaustein für UI-Ressourcen im Setup.
      
      Dieses Modul definiert die generische Struktur eines Textblocks,
      der von Katalogen wie TextCatalog verwendet wird.
      """
      
      from dataclasses import dataclass
      from typing import Any, Mapping
      
      
      @dataclass(slots=True, frozen=True)
      class TextBlock:
          """
          Textbaustein mit frei definierbaren Feldern.
      
          Typische Felder (konventionell):
          - title
          - intro
          - body
          - hint
          """
      
          key: str
          fields: Mapping[str, Any]
      
          @staticmethod
          def _normalize(value: Any, default: str) -> str:
              """
              Normalisiert einen Feldwert zu einem String.
      
              None → default, alles andere → str(value).
              """
              result: str = default if value is None else str(value)
              return result
      
          def get(self, field: str, default: str = "") -> str:
              """
              Liefert ein Feld oder einen Default-Text.
      
              Args:
                  field: Feldname innerhalb des Blocks.
                  default: Rückgabewert, falls das Feld nicht existiert.
      
              Returns:
                  Feldinhalt als String oder der Default-Wert.
              """
              raw_value: Any = self.fields.get(field, default)
              result: str = self._normalize(raw_value, default)
              return result
      
          def format(self, field: str = "body", **kwargs: Any) -> str:
              """
              Formatiert ein Feld mit den gegebenen Platzhaltern.
      
              Nicht vorhandene Felder werden als leerer String behandelt.
      
              Args:
                  field: Feldname, der formatiert werden soll.
                  **kwargs: Platzhalter für die Formatierung.
      
              Returns:
                  Formatierter Text oder ein leerer String.
              """
              template: str = self.get(field, "")
              result: str = "" if not template else template.format(**kwargs)
              return result
  - rel_path: tools/setup/ui/resources/catalog.py
    hash: deda6e93a838d8db6e47bd691ba3987e9fa48d19cc834af93b802eb953276f7a
    content: |
      from __future__ import annotations
      
      """
      Text- und Icon-Katalog für das Setup der UFO-Simulation.
      
      Dieses Modul lädt die Ressourcen aus der TOML-Datei `setup_ui.toml`
      und stellt eine Lookup-API für Texte und Icons bereit.
      """
      
      from dataclasses import dataclass
      from pathlib import Path
      from typing import Any, Final, Mapping, Optional
      
      import tomllib
      
      from tools.setup.ui.resources.block import TextBlock
      
      
      @dataclass(slots=True, frozen=True)
      class TextCatalog:
          """
          Katalog aller Textbausteine und Icons für das Setup.
      
          Lädt Inhalte aus der TOML-Ressource `setup_ui.toml` und bietet
          Zugriff über `text()`, `format()` und `icon()`.
          """
      
          _blocks: Mapping[str, TextBlock]
          _icons: Mapping[str, str]
      
          @classmethod
          def load(cls, path: Path) -> "TextCatalog":
              """
              Erzeugt einen Katalog aus der angegebenen TOML-Datei.
      
              Args:
                  path: Pfad zur TOML-Datei mit den UI-Ressourcen.
      
              Returns:
                  Initialisierter TextCatalog. Bei fehlender Datei ein leerer Katalog.
              """
              blocks: dict[str, TextBlock] = {}
              icons: dict[str, str] = {}
      
              if path.exists():
                  with path.open("rb") as f:
                      raw: dict[str, Any] = tomllib.load(f)
      
                      blocks = {
                          name: TextBlock(key=name, fields=fields)
                          for name, fields in raw.get("texts", {}).items()
                      }
      
                      icons = {name: str(value) for name, value in raw.get("icons", {}).items()}
      
              catalog: TextCatalog = cls(_blocks=blocks, _icons=icons)
              return catalog
      
          @classmethod
          def default(cls) -> "TextCatalog":
              """
              Lädt den Standard-Katalog aus `setup_ui.toml` neben diesem Modul.
              """
              path: Path = Path(__file__).with_name("setup_ui.toml")
              catalog: TextCatalog = cls.load(path)
              return catalog
      
          def _resolve_field(
                  self,
                  key: str,
                  field: str,
                  default: str,
          ) -> str:
              """
              Interner Helfer zur Feldauflösung mit Fallback.
      
              Args:
                  key: Name des Textblocks.
                  field: Feldname innerhalb des Blocks.
                  default: Fallback-Text.
      
              Returns:
                  Aufgelöster Feldwert oder Default.
              """
              block: Optional[TextBlock] = self._blocks.get(key)
              value: str = block.get(field, default) if not block is None else default
              return value
      
          def text(self, key: str, field: str = "body", default: str = "") -> str:
              """
              Liefert ein Textfeld aus dem angegebenen Block oder einen Default.
              """
              result: str = self._resolve_field(key, field, default)
              return result
      
          def format(self, key: str, field: str = "body", **kwargs: Any) -> str:
              """
              Liefert einen formatierten Text aus dem angegebenen Block.
      
              Nicht vorhandene Blöcke oder Felder liefern einen leeren String.
              """
              template: str = self._resolve_field(key, field, "")
              result: str = "" if not template else template.format(**kwargs)
              return result
      
          def icon(self, key: str, default: str) -> str:
              """
              Liefert ein Icon (Emoji oder Zeichenfolge) für den angegebenen Schlüssel.
      
              Falls kein Icon definiert ist, wird der Default-Wert verwendet.
              """
              icon_value: Optional[str] = self._icons.get(key)
              result: str = default if icon_value is None else icon_value
              return result
      
          @classmethod
          def load_catalog(cls, path: Path | None = None) -> TextCatalog:
              """
              Liefert entweder den Standardkatalog oder eine benutzerdefinierte Variante.
      
              Semantik:
              - path is None          → interner Standardkatalog (setup_ui.toml neben diesem Modul)
              - path ist ein Ordner   → es wird path / "setup_ui.toml" verwendet
              - path ist eine Datei   → genau diese Datei wird geladen
              """
              if path is None:
                  return cls.default()
      
              candidate = path
      
              # Wenn ein Verzeichnis übergeben wurde, dort nach setup_ui.toml suchen
              if candidate.is_dir():
                  candidate = candidate / "setup_ui.toml"
      
              # cls.load(...) ist bereits robust: bei fehlender Datei → leerer Katalog
              return cls.load(candidate)
      
      
      CATALOG: Final[TextCatalog] = TextCatalog.load_catalog()
  - rel_path: tools/setup/ui/resources/icons.py
    hash: cb34792dfb6b7cd0fdd2e367d56bfe5432b74b6becbabfe4544314777a157790
    content: |
      # tools/setup/ui/resources/icons.py
      from __future__ import annotations
      
      """
      Enum-basierte Icon- und Statusdefinitionen für das Setup-UI.
      
      Dieses Modul kapselt:
      - MessageLevel: logische Stufen für Konsolenmeldungen (info, success, ...)
      - ProgressStatus: Zustände von Fortschrittsblöcken inkl. Icon-/Label-Metadaten.
      """
      
      from enum import Enum
      from functools import cached_property
      from typing import Final
      
      from tools.setup.ui.resources.catalog import CATALOG
      
      
      class MessageLevel(Enum):
          """Logische Stufen für strukturierte Konsolenausgaben."""
      
          INFO = ("info", "ℹ️", None)
          SUCCESS = ("success", "✅", "bold green")
          WARNING = ("warning", "⚠️", "yellow")
          ERROR = ("error", "❌", "bold red")
          CONTINUE = ("continue", "🚀", None)
          PLAIN = ("plain", "", None)
      
          def __init__(self, icon_key: str, fallback_icon: str, style: str | None) -> None:
              self._icon_key: Final[str] = icon_key
              self._fallback_icon: Final[str] = fallback_icon
              self.style: str | None = style
      
          @cached_property
          def icon(self) -> str:
              """Liefert das Icon aus dem Katalog oder den Fallback."""
              return CATALOG.icon(self._icon_key, self._fallback_icon)
      
      
      class ProgressStatus(Enum):
          """
          Interner Status eines Fortschrittsblocks inkl. Icon- und Label-Metadaten.
          """
      
          # Keys passend zu [icons] in setup_ui.toml: start, run, ok, fail
          STARTING = ("start", "🔄", "started")
          RUNNING = ("run", "⏳", "running")
          FINISHED = ("ok", "✅", "finished")
          FAILED = ("fail", "❌", "failed")
      
          def __init__(self, icon_key: str, fallback_icon: str, label: str) -> None:
              self._icon_key: Final[str] = icon_key
              self._fallback_icon: Final[str] = fallback_icon
              self.label: str = label
      
          @cached_property
          def icon(self) -> str:
              """Liefert das Icon aus dem Katalog oder den Fallback."""
              return CATALOG.icon(self._icon_key, self._fallback_icon)
  - rel_path: tools/setup/ui/resources/setup_ui.toml
    hash: 4c24d79615f7d5f7f1c2d889e1c8b8c9e60c5c0dccb77a843bbfa7b57b87c313
    content: |-
      [texts.setup_header]
      license = """
      UFO-Simulation Schulung – Lizenzhinweise (Kurzfassung)
      
      Dieses Schulungsprojekt basiert auf der im Repository angegebenen Lizenz.
      Die Nutzung erfolgt im Rahmen von Ausbildung, Studium und interner Schulung.
      """
      title = "──────────────────────────── UFO-Simulation – Setup ────────────────────────────"
      intro = "Willkommen zum automatisierten Setup der UFO-Simulation."
      body = """
      Dieses Programm richtet eine isolierte Python-Umgebung ein,
      installiert alle benötigten Abhängigkeiten und prüft die Installation.
      
      In diesem Setup werden nacheinander ausgeführt:
      
      1. Prüfung der Python-Version
      2. Erzeugen bzw. Wiederverwenden der virtuellen Umgebung (.venv)
      3. Installation der Runtime-Dependencies
      4. Installation der Dev-Dependencies
      5. Import-Contract-Prüfung via import-linter
      6. Ausführen der pytest-Tests zur Validierung der Installation
      
      Dies kann einen Moment dauern – bitte warte, bis alle Schritte abgeschlossen sind.
      """
      [texts.module_setup]
      default = "Setup-{typ} {module}: {info}"
      
      [texts.tests]
      skipped_hint = "pytest wurde aufgrund der Skip-Konfiguration nicht ausgeführt."
      
      [texts.args]
      default = "{type} wurde aufgrund des arguments {arg} {action}"
      
      [texts.next]
      title = "Nächste Schritte (Überblick)"
      body = """
      1. Virtuelle Umgebung aktivieren:
         {activate_cmd}
      
      2. Projekt starten ...
      """
      
      [texts.legend]
      body = """
      Legende der Symbole:
      
      {info}    – Information / Hinweis
      {success} – Schritt erfolgreich abgeschlossen
      {warning} – Warnung (Setup kann weiterlaufen, Ergebnis prüfen)
      {error}   – Fehler (Setup wird abgebrochen)
      {continue} – Hinweise zu Start und nächsten Schritten
      """
      
      [icons]
      info = "ℹ️"
      success = "✅"
      warning = "⚠️"
      error = "❌"
      continue = "🚀"
      start = "🔄"
      run = "⏳"
      ok = "✅"
      fail = "❌"
      
      [texts.step_default]
      success = "{step}: erfolgreich abgeschlossen."
      failure = "{step}: Fehler unter {env}: {cause}\n{details}"
      default = "{step}: {details}"
      
      # Neu: generische Progress-Zeile für laufende Arbeiten
      progress_running = "Running  /   {details}"
      progress_failed = "Failed   /   {details}"
      progress_finished = "Finished /   {details}"
      
      # Neu: Standard-Details für Installationsfortschritt (kann von anderen Steps wiederverwendet werden)
      install_details = "Installiere: {package} ({index}/{total})"
      install_done = "Alle Abhängigkeiten installiert."
      install_failed = "{package}: {details}"
      
      [texts.RunTestsStep]
      failure = "Tests im Schritt {step} unter {env} fehlgeschlagen: {cause}\n{details}"
  - rel_path: tools/setup/utils/__init__.py
    hash: 8ec15af2d6c45840f0ad5eba29f797ff03691cd3983a725c2e4be409caff8058
    content: |
      from __future__ import annotations
      
      """
      Gemeinsame Hilfsfunktionen für das Setup-System der UFO-Simulation.
      
      Dieses Modul bündelt die häufig verwendeten Utility-Funktionen:
      
      Es dient als schmale Fassade auf die eigentlichen Implementierungen
      in ``context`` und ``pause``.
      """
      
      from .context import run_command, short_output
      from .module import evaluate, classify, install
      from .version import ensure_venv, venv_create
      
      __all__: list[str] = [
          "run_command",
          "short_output",
          "evaluate",
          "classify",
          "install",
          "ensure_venv",
          "venv_create",
      ]
  - rel_path: tools/setup/utils/context.py
    hash: e14dad4aff92f1a781aa1deac84d067db3f10c43faf2af61dd215c60f40fed50
    content: |
      from __future__ import annotations
      
      import traceback
      
      """
      Technische Hilfsfunktionen für den Setup-Prozess.
      
      Dieses Modul bündelt generische Helfer wie Subprozess-Aufrufe und das
      Kürzen langer Konsolen-Ausgaben.
      """
      
      from dataclasses import dataclass
      from collections.abc import Sequence
      from typing import Final
      
      import subprocess
      
      
      @dataclass(slots=True, frozen=True)
      class CommandResult:
          """Ergebnis eines Subprozess-Aufrufs."""
      
          args: tuple[str, ...]
          returncode: int
          stdout: str
          stderr: str
      
          @property
          def ok(self) -> bool:
              """True, wenn der Prozess mit Exit-Code 0 beendet wurde."""
              return self.returncode == 0
      
      
      DEFAULT_MAX_LINES: Final[int] = 10
      
      
      def run_command(
              args: Sequence[str],
              *,
              cwd: str | None = None,
              timeout: float | None = None,
      ) -> CommandResult:
          """
          Führt einen Subprozess mit den gegebenen Argumenten aus.
      
          Args:
              args: Befehlsargumente, z. B. ("python", "-m", "pytest").
              cwd: Optionales Working-Directory.
              timeout: Optionaler Timeout in Sekunden.
      
          Returns:
              Ein CommandResult mit Exit-Code sowie stdout/stderr (immer als String).
          """
          completed = subprocess.run(
              tuple(args),
              cwd=cwd,
              timeout=timeout,
              check=False,
              text=True,
              capture_output=True,
          )
      
          return CommandResult(
              args=tuple(args),
              returncode=completed.returncode,
              stdout=completed.stdout or "",
              stderr=completed.stderr or "",
          )
      
      
      def short_output(output: str, *, max_lines: int = 40) -> str:
          """
          Begrenzt eine Ausgabe auf die ersten `max_lines` Zeilen.
      
          Leere oder whitespace-only Eingaben liefern einen leeren String.
      
          Args:
              output: Originale Ausgabe (z. B. pytest-Log).
              max_lines: Maximale Anzahl der zurückgegebenen Zeilen.
      
          Returns:
              Gekürzte Ausgabe oder ein leerer String bei leerem Input.
          """
          stripped: str = output.strip()
          result: str = ""
      
          if stripped:
              lines: list[str] = stripped.splitlines()
              line_count: int = len(lines)
      
              if line_count <= max_lines:
                  result = stripped
              else:
                  head: str = "\n".join(lines[:max_lines])
                  remaining: int = line_count - max_lines
                  result = f"{head}\n... ({remaining} weitere Zeilen ausgeblendet)"
      
          return result
  - rel_path: tools/setup/utils/module.py
    hash: 3473ba12636fd577eb9d782297d23bfc15ac652b27605f4390686ef2d1ae7777
    content: |
      # tools/setup/utils/module.py
      from __future__ import annotations
      
      """
      Generische Hilfsfunktionen für Modul-/CLI-Prüfungen im Setup.
      
      Enthält:
      - evaluate  → `python -m <module> [args]` testweise ausführen
      - classify  → Fehlerursache grob klassifizieren
      - install   → generische Paketinstallation via `pip` oder externen Befehl
      """
      
      import subprocess
      from pathlib import Path
      from typing import Final, Iterable, overload
      
      from tools.setup.utils.context import run_command, short_output
      
      _PIP_ARGS: Final[tuple[str, ...]] = ("-m", "pip", "install", "--progress-bar", "off")
      
      
      def evaluate(
              python: str,
              module: str,
              *,
              cwd: Path | None = None,
              extra_args: tuple[str, ...] = ("--help",),
      ) -> tuple[bool, str, str | None]:
          """
          Führt einen minimalen Testlauf für `python -m <module> [extra_args]` aus.
      
          Rückgabe:
              ok       – True, wenn returncode == 0
              output   – kombinierte stdout/stderr-Ausgabe
              exc_info – Fehlermeldung, falls der Interpreter selbst nicht gestartet werden konnte
          """
      
          hold: tuple[bool, str, str | None]
      
          try:
              result = subprocess.run(
                  (python, "-m", module, *extra_args),
                  cwd=cwd,
                  capture_output=True,
                  text=True,
                  check=False,
              )
              comb = (result.stdout or "") + (result.stderr or "")
              hold = (result.returncode == 0, comb, None)
      
          except (OSError, FileNotFoundError) as exc:
              # Interpreter (z. B. .venv/bin/python) nicht auffindbar
              hold = (False, "", str(exc))
      
          return hold
      
      
      def classify(
              exc_info: str | None,
              output: str,
              *,
              module: str,
      ) -> tuple[str, str]:
          """
          Klassifiziert Fehler für einen Modulaufruf in (kind, details).
      
          kind    → "interpreter", "module_missing", "module_error"
          details → Text für Log & Ausgabe
          """
          text = (output or "").lower()
      
          match exc_info, text:
              case str() as e, _:
                  return "interpreter", e
              case None, s if "no module named" in s and module in s:
                  return "module_missing", output
              case _:
                  return "module_error", output
      
      
      @overload
      def install(
              *,
              python: str,
              spec: str,
              cwd: Path | None = None,
      ) -> tuple[int, str, str]:
          """
          Installation via `python -m pip install <spec>`.
          """
          ...
      
      
      @overload
      def install(
              *,
              cmd: Iterable[str],
              cwd: Path | None = None,
      ) -> tuple[int, str, str]:
          """
          Generischer Installationsbefehl (z. B. Installer-Skript).
          """
          ...
      
      
      def install(
              *,
              python: str | None = None,
              spec: str | None = None,
              cmd: Iterable[str] | None = None,
              cwd: Path | None = None,
      ) -> tuple[int, str, str]:
          """
          Installiert ein Paket oder führt einen generischen Installationsbefehl aus.
      
          Varianten:
              - python+spec → `python -m pip install <spec>`
              - cmd        → externer Befehl (z. B. Installer-Skript)
      
          Rückgabe:
              returncode
              raw_output   – stdout+stderr (vollständig)
              short_output – ggf. gekürzte Version für Konsolen-Anzeige
          """
      
          argv: tuple[str, ...] | None = None
      
          match python, spec, cmd:
              case str() as py, str() as s, None:
                  argv: tuple[str, ...] = (py, *_PIP_ARGS, s)
              case None, None, external if external is not None:
                  argv = tuple(external)
              case _:
                  raise ValueError(
                      "install(): entweder python+spec oder cmd angeben, nicht mehrere oder keine."
                  )
      
          result = run_command(argv, cwd=cwd)
      
          raw = (result.stdout or "") + (result.stderr or "")
          short = short_output(raw)
          return result.returncode, raw, short
  - rel_path: tools/setup/utils/version.py
    hash: 07bfc2db7ea4158b296d257ab2b7157bf9486deb24563546ca39bde84d5f81d3
    content: |
      import sys
      from pathlib import Path
      from venv import create as venv_create
      
      from tools.setup.steps.base import StepContext
      
      
      def check_python_version(ctx: StepContext) -> tuple[bool, str, str]:
          required = ctx.profile.requires_min_python
          assert required is not None  # Profil muss eine Version liefern
      
          req_major, req_minor = required
          cur_major, cur_minor = sys.version_info[:2]
      
          if (cur_major, cur_minor) < (req_major, req_minor):
              return (
                  False,
                  "python_version_mismatch",
                  f"current={cur_major}.{cur_minor}, required>={req_major}.{req_minor}",
              )
      
          return True, "", ""
      
      
      def ensure_venv(ctx: StepContext, safety_check: bool = True) -> tuple[bool, str, str]:
          venv_dir: Path = ctx.config.venv_dir
          repo_root: Path = ctx.config.repo_root
      
          # Sicherheitsgurt: venv darf nur im aktuellen Projekt liegen
          try:
              venv_dir.relative_to(repo_root)
          except ValueError:
              return (
                  False,
                  "venv_outside_repo",
                  f"venv_dir={venv_dir} liegt nicht unter repo_root={repo_root}",
              )
      
          # Optional: Name prüfen, um versehentliche Fremdpfade zu vermeiden
          if all((safety_check, venv_dir.name != ".venv")):
              return (
                  False,
                  "venv_unexpected_name",
                  f"erwartet .venv, gefunden {venv_dir.name}",
              )
      
          try:
              # Bewusster Reset: vorhandene venv wird überschrieben
              venv_create(venv_dir, with_pip=True, clear=True)
          except OSError as exc:
              return (
                  False,
                  "venv_create_failed",
                  str(exc),
              )
      
          return True, "", ""
