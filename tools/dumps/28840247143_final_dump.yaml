dump_path: /Users/tomwerner/PycharmProjects/ufo-simulation-schulung/tools/dumps/28840247143_final_dump.yaml
root: /Users/tomwerner/PycharmProjects/ufo-simulation-schulung/tools
hash: ab31e4b37ce0172512f09f03835cf2c19053e488a598d67a2d125c3bf9c7814e
dirs:
  - setup
  - setup/domain
  - setup/steps
  - setup/steps/base
  - setup/ui
  - setup/ui/output
  - setup/ui/progress
  - setup/ui/resources
  - setup/utils
files:
  - rel_path: __init__.py
    hash: 1c8d46762ba64ffd8846ffd797375163dfb66ddb97a5345f72eab6becd266541
    content: |
      # tools/__init__.py
      from __future__ import annotations
      
      """
      Werkzeugpaket für das Projekt »ufo-simulation-schulung«.
      
      Dieses Paket bündelt interne Hilfstools.
      Der Setup-Einstieg liegt in ``tools.bootstrap.execute``.
      """
      
      __all__: list[str] = []
  - rel_path: bootstrap.py
    hash: 9f74c3fa6a42b35e8e41d78d6ba874be1fabefbc573ec508ae2900380b5be9ca
    content: |
      # tools/bootstrap.py
      from __future__ import annotations
      
      import sys
      from dataclasses import dataclass, fields
      from typing import Iterable
      
      from tools.setup.domain import BootstrapConfig, build_profile
      from tools.setup.domain import PyProjectProfile
      from tools.setup.logging import ErrorLog
      from tools.setup.steps import BaseStep  # nur für Typ-Hints
      from tools.setup.steps.base import BaseStepContext
      from tools.setup.ui import SetupConsole
      from tools.setup.ui.resources import CATALOG
      
      
      # ------------------------------------------------------------
      # 1) SETUP HEADER AUFBAUEN
      # ------------------------------------------------------------
      
      @dataclass(slots=True)
      class Segment:
          license: str
          title: str
          intro: str
          body: str
      
          def __iter__(self) -> Iterable[str]:
              return (getattr(self, f.name) for f in fields(self))
      
          @classmethod
          def from_catalog(cls, cat=CATALOG) -> "Segment":
              return cls(
                  **{
                      f.name: cat.text("setup_header", field=f.name, default="")
                      for f in fields(cls)
                  }
              )
      
      
      # ------------------------------------------------------------
      # 2) Low-Level-Utility-Funktionen
      # ------------------------------------------------------------
      
      def _build_log(config: BootstrapConfig) -> ErrorLog:
          """Bereitet das ErrorLog vor (leert bestehende Datei)."""
          path = config.log_path
          path.write_text("", encoding="utf-8")
          return ErrorLog(path)
      
      
      def _select_steps(profile: PyProjectProfile) -> tuple[type[BaseStep[object]], ...]:
          """
          Wählt die auszuführenden Steps ausschließlich auf Basis ihrer ``stid``
          und der Konfiguration aus [tool.setup].
          """
          from tools.setup.steps import STEPS  # tatsächliche Klassen
      
          by_stid: dict[str, type[BaseStep[object]]] = {}
          for cls in STEPS:
              stid = cls.stid
              if stid in by_stid and by_stid[stid] is not cls:
                  other = by_stid[stid].__name__
                  raise ValueError(
                      f"Doppelte stid {stid!r} bei {cls.__name__} und {other}.",
                  )
              by_stid[stid] = cls
      
          if profile.step_include:
              ordered_ids = [stid for stid in profile.step_include if stid in by_stid]
      
          else:
              ordered_ids = [
                  cls.stid
                  for cls in sorted(by_stid.values(), key=lambda c: c.priority, reverse=True)
              ]
      
          exclude_ids = set(profile.step_exclude)
          return tuple(
              by_stid[stid]
              for stid in ordered_ids
              if stid not in exclude_ids
          )
      
      
      # ------------------------------------------------------------
      # 3) Step-Orchestrierung
      # ------------------------------------------------------------
      
      def leaf(ctx: BaseStepContext) -> bool:
          """
          Führt alle konfigurierten Setup-Schritte aus und bricht nach dem
          ersten fehlgeschlagenen Step ab.
          """
          process = (cls() for cls in _select_steps(ctx.profile))
          return all((ok := step.run(ctx)) for step in process)
      
      
      # ------------------------------------------------------------
      # 4) High-Level-Orchestrator
      # ------------------------------------------------------------
      
      def execute(argv: list[str] | None = None) -> int:
          """
          Führt den kompletten Setup-Prozess aus:
      
          - Config, Profile, Log, Konsole erzeugen
          - Header anzeigen
          - Steps via leaf(ctx) ausführen
          - ggf. Next-Steps anzeigen
      
          CLI-Argumente (argv) werden bewusst ignoriert; das Verhalten
          wird ausschließlich über die pyproject.toml gesteuert.
          """
          config = BootstrapConfig()
          profile = build_profile(config.repo_root)
          log = _build_log(config)
      
          console = SetupConsole()
          ctx = BaseStepContext(
              config=config,
              profile=profile,
              log=log,
              console=console,
          )
      
          seg = Segment.from_catalog(CATALOG)
          if seg.license:
              console.info(seg.license)
          if seg.title:
              console.header(seg.title)
          for part in (seg.intro, seg.body):
              if part:
                  console.info(part)
      
          ok = leaf(ctx)
      
          if ok:
              title = CATALOG.text("next", field="title", default="")
              body = CATALOG.text("next", field="body", default="").format(
                  activate_cmd=config.activation_command,
              )
              if title:
                  console.info(title)
              if body:
                  console.info(body)
      
          return 0 if ok else 1
      
      
      def console_script() -> None:
          """Entry-Point für pyproject.toml / setup_new.py."""
          raise SystemExit(execute(sys.argv[1:]))
  - rel_path: setup/__init__.py
    hash: 09d3d6be5d1ced3a61e37a7ab409317dc24fc9f5dc7464d688df294b60f7a32a
    content: |
      # tools/setup/__init__.py
      from __future__ import annotations
      
      """
      Setup-Paket für das Projekt »ufo-simulation-schulung«.
      
      Kapselt:
      - Konfiguration und Projektprofil (``domain``),
      - Setup-Schritte (``steps``),
      - Konsolen- und UI-Hilfen (``ui``),
      - Hilfsfunktionen (``utils``).
      """
      
      __all__: list[str] = []
  - rel_path: setup/domain/__init__.py
    hash: 4258eee4cd4d89f87b58b3ff5e47575ac112f9b48828622db3d6c4bfdf8aa712
    content: |
      from __future__ import annotations
      
      """
      Domänenspezifische Typen und Profile für das Setup.
      
      Dieses Unterpaket stellt die zentralen Modelle bereit:
      - :class:`BootstrapConfig` für Pfade und Laufzeitparameter,
      - :class:`PyProjectProfile` für abgeleitete Projektinformationen,
      - :func:`load_pyproject_profile` zum Laden des Profils aus der ``pyproject.toml``.
      """
      
      from .config import BootstrapConfig
      from .profile import PyProjectProfile, build_profile
      
      __all__: list[str] = [
          "BootstrapConfig",
          "PyProjectProfile",
          "build_profile",
      ]
  - rel_path: setup/domain/config.py
    hash: a92f7fd7d6265f45e8698f7e883f3ecb45d2e2c6a988270d1cdf994263f1e667
    content: |
      # tools/setup/domain/config.py
      from __future__ import annotations
      
      from dataclasses import dataclass, field
      from enum import Enum
      from pathlib import Path
      from sys import platform as _platform
      
      
      class Platform(Enum):
          """Logische Plattformklasse für Venv-Layout (WINDOWS / POSIX)."""
      
          WINDOWS = "windows"
          POSIX = "posix"
      
      
      def default_repo_root() -> Path:
          """Liefert die Projektwurzel relativ zu diesem Modul."""
          return Path(__file__).resolve().parents[3]
      
      
      @dataclass(slots=True)
      class BootstrapConfig:
          """
          Zentrale technische Konfiguration für das Setup.
      
          Beinhaltet:
          - Projektwurzel (repo_root)
          - abgeleitete Pfade/Kommandos (venv_dir, venv_python, log_path, activation_command)
      
          Projekt- / Step-spezifisches Verhalten (Step-Auswahl, Optionen etc.)
          wird ausschließlich über die pyproject.toml im PyProjectProfile konfiguriert.
          """
      
          repo_root: Path = field(default_factory=default_repo_root)
      
          @property
          def platform(self) -> Platform:
              """Ermittelt die logische Plattform (WINDOWS oder POSIX)."""
              normalized = _platform.lower()
              if normalized.startswith(("win", "msys", "cygwin")):
                  return Platform.WINDOWS
              return Platform.POSIX
      
          @property
          def venv_dir(self) -> Path:
              """.venv-Verzeichnis unterhalb der Projektwurzel."""
              return self.repo_root / ".venv"
      
          @property
          def venv_python(self) -> str:
              """Pfad zur Python-Binary im Virtualenv."""
              rel = (
                  "Scripts/python.exe"
                  if self.platform is Platform.WINDOWS
                  else "bin/python"
              )
              return str(self.venv_dir / rel)
      
          @property
          def log_path(self) -> Path:
              """Pfad zur Setup-Logdatei."""
              return self.repo_root / "setup.log"
      
          @property
          def activation_command(self) -> str:
              """Shell-Befehl zur Aktivierung der virtuellen Umgebung."""
              if self.platform is Platform.WINDOWS:
                  return r".\.venv\Scripts\Activate.ps1"
              return "source .venv/bin/activate"
  - rel_path: setup/domain/profile.py
    hash: 3ce6e3736cb7f23b7118a360f78518a8f607e56fc224a8b8d1e29fa7e0f6c1c5
    content: |
      # tools/setup/domain/profile.py
      from __future__ import annotations
      
      """
      Projektprofil auf Basis von pyproject.toml.
      """
      
      from dataclasses import dataclass, field
      from enum import StrEnum
      from pathlib import Path
      from typing import Any, Final, Mapping, Literal
      import tomllib
      
      PYPROJECT_FILENAME: Final[str] = "pyproject.toml"
      
      
      class RequirementOperator(StrEnum):
          """Unterstützte Vergleichsoperatoren für Dependency-Spezifikationen."""
      
          NOT_EQUAL = "!="
          EQUAL = "=="
          GTE = ">="
          LTE = "<="
          GT = ">"
          LT = "<"
          COMPAT = "~="
          EXACT = "==="
      
          @classmethod
          def detect(cls, text: str) -> tuple[str, str] | None:
              """Zerlegt eine Requirement-Spezifikation in (name, version_spec).
      
              Beispiele:
              - "importlinter>=2.0" -> ("importlinter", ">=2.0")
              - ">=3.10"            -> ("", ">=3.10")  (z. B. für requires-python)
      
              Liefert None, wenn kein Vergleichsoperator aus RequirementOperator gefunden wird.
              """
              spec = text.strip()
              if not spec:
                  return None
      
              # Längere Operatoren zuerst prüfen (z. B. ">=" vor ">")
              operators = sorted(
                  cls.__members__.values(),  # type: dict[str, RequirementOperator].values
                  key=lambda o: len(o.value),  # hier ist o klar ein RequirementOperator
                  reverse=True,
              )
      
              candidates: list[tuple[int, str]] = [
                  (pos, op_str)
                  for op in operators
                  if (op_str := op.value)  # op_str: str
                  if (pos := spec.find(op_str)) != -1
              ]
      
              if not candidates:
                  return None
      
              best_pos, best_op = min(candidates, key=lambda t: t[0])
      
              name = spec[:best_pos].strip()
              version_spec = spec[best_pos:].strip()
              return name, version_spec
      
      
      @dataclass(slots=True)
      class PyProjectProfile:
          """Setup-relevante Inhalte aus pyproject.toml."""
      
          requires_min_python: tuple[int, int] | None
          runtime_requirements: Mapping[str, str] = field(default_factory=dict)
          dev_requirements: Mapping[str, str] = field(default_factory=dict)
      
          # Step-Steuerung aus [tool.setup]
          step_include: tuple[str, ...] = field(default_factory=tuple)
          step_exclude: tuple[str, ...] = field(default_factory=tuple)
          step_options: Mapping[str, Mapping[str, Any]] = field(default_factory=dict)
          verbosity: int = 1
          auto_install: bool = True
      
          # Linter-spezifische Steuerung aus [tool.setup.linter]
          # "all" (Default) | "forbidden" | "layers"
          linter_contracts: Literal["all", "forbidden", "layers"] = "all"
      
          # Vollständige pyproject-Struktur für generische Zugriffe
          pyproject_data: Mapping[str, Any] = field(default_factory=dict)
      
          def get_path(self, *path: str, default: Any = None) -> Any:
              """Generischer Zugriff auf verschachtelte pyproject.toml-Werte."""
              data: Any = self.pyproject_data
              for key in path:
                  if not isinstance(data, Mapping):
                      return default
                  data = data.get(key)
                  if data is None:
                      return default
              return data
      
      
      def _min_version_from_segment(segment: str) -> tuple[int, int] | None:
          """
          Extrahiert eine Mindestversion (major, minor) aus einem Segment.
      
          Erwartet Einträge wie ">=3.10" und ignoriert fachlich unpassende Werte.
          """
          result: tuple[int, int] | None = None
          detection: tuple[str, str] | None = RequirementOperator.detect(segment)
      
          if detection is not None:
              name, version_spec = detection
      
              # für requires-python sind Paketnamen unerwartet
              if not name:
                  gte: str = RequirementOperator.GTE
                  if version_spec.startswith(gte):
                      version: str = version_spec.removeprefix(gte).strip()
                      parts: list[str] = version.split(".")
      
                      if len(parts) >= 2:
                          major_str: str = parts[0]
                          minor_str: str = parts[1]
      
                          if major_str.isdecimal() and minor_str.isdecimal():
                              major: int = int(major_str)
                              minor: int = int(minor_str)
                              result = (major, minor)
          return result
      
      
      def _parse_requires_python(spec: str | None) -> tuple[int, int] | None:
          """
          Interpretiert `project.requires-python` als Mindestversion (major, minor).
      
          Ausgewertet wird nur die erste untere Schranke vom Typ ">=X.Y".
          """
          result: tuple[int, int] | None = None
      
          if spec:
              segments = (segment.strip() for segment in spec.split(","))
              for segment in segments:
                  if not segment:
                      continue
      
                  version: tuple[int, int] | None = _min_version_from_segment(segment)
                  if version is not None:
                      result = version
                      break
      
          return result
      
      
      def _normalize_requirements(entries: list[str]) -> Mapping[str, str]:
          """
          Normalisiert eine Liste von Abhängigkeiten in ein Mapping name -> spec.
          """
          result: dict[str, str] = {}
      
          for raw in entries:
              entry: str = raw.strip()
              if not entry:
                  continue
      
              detection: tuple[str, str] | None = RequirementOperator.detect(entry)
              if detection is None:
                  result[entry] = ""
              else:
                  name, version_spec = detection
                  result[name] = version_spec
      
          return result
      
      
      def _load_pyproject_data(path: Path) -> Mapping[str, Any]:
          """
          Lädt pyproject.toml.
      
          Falls keine Datei existiert, wird ein leeres Mapping geliefert,
          so dass das Setup mit Standardprofil weiterlaufen kann.
          """
          # Wenn ein Verzeichnis übergeben wurde, pyproject.toml darin suchen,
          # ansonsten path direkt als Dateipfad interpretieren.
          pyproject_path = path / PYPROJECT_FILENAME if path.is_dir() else path
      
          if not pyproject_path.exists():
              return {}
      
          with pyproject_path.open("rb") as handle:
              data: Mapping[str, Any] = tomllib.load(handle)
      
          return data
      
      
      def _normalize_str_list(value: Any) -> tuple[str, ...]:
          """
          Normalisiert Werte aus der pyproject-Konfiguration auf eine
          geordnete Tupel-Liste von Strings.
          """
          if value is None:
              return ()
      
          if isinstance(value, str):
              value = [value]
      
          return tuple(
              str(item).strip()
              for item in value
              if str(item).strip()
          )
      
      
      def build_profile(repo_root: Path) -> PyProjectProfile:
          """
          Lädt die pyproject.toml genau einmal und baut ein Setup-Profil.
      
          - [project]                  → Dependencies, requires-python
          - [tool.setup]               → steps, exclude, options, linter
          - [tool.setup.linter]        → contracts-Modus ("all" | "forbidden" | "layers")
          - weitere tool-Abschnitte    → über pyproject_data / get_path(...)
          """
          data = _load_pyproject_data(repo_root)
      
          project_table: Mapping[str, Any] = data.get("project", {})
          requires_python_str: str | None = project_table.get("requires-python")
          requires_min_python: tuple[int, int] | None = _parse_requires_python(
              requires_python_str,
          )
      
          # Laufzeit-Abhängigkeiten kommen aus [project].dependencies
          deps_list: list[str] = project_table.get("dependencies", [])
          runtime_requirements: Mapping[str, str] = _normalize_requirements(deps_list)
      
          # Dev-Abhängigkeiten kommen aus [project.optional-dependencies].dev
          optional_deps: Mapping[str, list[str]] = project_table.get(
              "optional-dependencies",
              {},
          )
          dev_requirements: Mapping[str, str] = _normalize_requirements(
              optional_deps.get("dev", []),
          )
      
          tool_table: Mapping[str, Any] = data.get("tool", {})
          setup_table: Mapping[str, Any] = tool_table.get("setup", {})
      
          # [tool.setup].steps / exclude
          step_include: tuple[str, ...] = _normalize_str_list(setup_table.get("steps"))
          step_exclude: tuple[str, ...] = _normalize_str_list(setup_table.get("exclude"))
      
          # [tool.setup].options.<step-id>
          raw_options: Any = setup_table.get("options", {})
          if isinstance(raw_options, Mapping):
              tmp: dict[str, Mapping[str, Any]] = {}
              for key, value in raw_options.items():
                  if isinstance(value, Mapping):
                      tmp[str(key)] = dict(value)
              step_options: Mapping[str, Mapping[str, Any]] = tmp
          else:
              step_options = {}
      
          # [tool.setup].auto_install (optional, Default=True)
          auto_install_raw: Any = setup_table.get("auto_install", True)
          auto_install: bool = bool(auto_install_raw)
      
          # [tool.setup.linter].contracts
          linter_table: Mapping[str, Any] = setup_table.get("linter", {})
          contracts_raw: Any = linter_table.get("contracts", "all")
          contracts_mode = str(contracts_raw).strip().lower()
      
          if contracts_mode not in {"all", "forbidden", "layers"}:
              # Fallback auf "all" bei ungültigen Werten oder leerem String
              linter_contracts: Literal["all", "forbidden", "layers"] = "all"
          else:
              linter_contracts = contracts_mode  # type: ignore[assignment]
      
          profile = PyProjectProfile(
              requires_min_python=requires_min_python,
              runtime_requirements=runtime_requirements,
              dev_requirements=dev_requirements,
              step_include=step_include,
              step_exclude=step_exclude,
              step_options=step_options,
              auto_install=auto_install,
              linter_contracts=linter_contracts,
              pyproject_data=data,
          )
          return profile
  - rel_path: setup/logging.py
    hash: b50bb25900b62e0e66ca3b56683236272e4709b9fd933e2eed86d7193f45d527
    content: |
      """
      Fehlerprotokollierung für den Setup-Prozess.
      
      Dieses Modul stellt eine schlanke `ErrorLog`-Klasse bereit, die Einträge
      in eine Log-Datei des Setup-Prozesses schreibt.
      """
      from __future__ import annotations
      
      from dataclasses import dataclass, field
      from pathlib import Path
      
      
      @dataclass(slots=True)
      class ErrorLog:
          """
          Einfache Fehlerprotokollierung in eine Textdatei.
      
          Die Klasse kapselt die I/O-Logik und wird von den Setup-Schritten
          genutzt, um technische Details konsistent zu protokollieren.
          """
      
          path: Path = field()
      
          def write_error(self, section: str, message: str, details: str | None = None) -> None:
              """
              Schreibt einen Fehlerabschnitt in die Log-Datei.
      
              Parameter:
                  section:
                      Grober Kontext des Fehlers (z. B. 'pytest', 'Import-Linter').
                  message:
                      Kurzbeschreibung des Fehlers.
                  details:
                      Optionaler, ausführlicherer Text (z. B. stdout/stderr).
              """
              lines: list[str] = [
                  "",
                  f"[SECTION] {section}",
                  f"[MESSAGE] {message}",
              ]
      
              if details:
                  lines.append("[DETAILS]")
                  lines.append(details)
      
              lines.append("")
      
              with self.path.open("a", encoding="utf-8") as log_file:
                  log_file.write("\n".join(lines))
  - rel_path: setup/steps/__init__.py
    hash: d367922daa7ac8b9c1ff1093cd43106f16603fd7484c7310a62a83113a538fc7
    content: |
      from __future__ import annotations
      
      """
      Fassade für die Setup-Schritte der UFO-Simulation.
      
      Dieses Paket bündelt die von außen genutzten Funktionen der einzelnen
      Setup-Step-Module und stellt einen stabilen Importpunkt für den Bootstrap
      bereit.
      """
      
      from .base import BaseStep
      from .create_env import CreateEnvStep
      from .install_deps import InstallDepsStep
      from .linter_check import EvaluateImportsStep
      from .test_runner import RunTestsStep
      
      STEPS: tuple[type[BaseStep[object]], ...] = (
          CreateEnvStep,
          InstallDepsStep,
          EvaluateImportsStep,
          RunTestsStep,
      )
      
      __all__ = [cls.__name__ for cls in STEPS]
  - rel_path: setup/steps/base/__init__.py
    hash: 771fad67cefe830c4d0fc7afa7f96d272bcbf60d4d2b294f43d8efe94dcc7d73
    content: |
      # tools/setup/steps/base/__init__.py
      from __future__ import annotations
      
      """
      Basis-API für Setup-Schritte.
      
      Bündelt die zentrale Step-Basis und den StepContext.
      """
      
      from .step import BaseStep
      from .meta import BaseStepContext
      from .result import StepResult, PrepareResult
      from .decorator import handle_step, handle_prepare
      
      __all__: list[str] = [
          # step interface
          "BaseStep",
          "BaseStepContext",
          # result types
          "StepResult",
          "PrepareResult",
          # decorators
          "handle_step",
          "handle_prepare",
      ]
  - rel_path: setup/steps/base/decorator.py
    hash: 947bb471c67341829908718e11b084793fa601f5e3bcd24723ef02c67aa68561
    content: |-
      from __future__ import annotations
      
      from functools import wraps
      from typing import (
          Any,
          Callable,
          TYPE_CHECKING,
          TypeVar,
          ParamSpec,
          Concatenate,
      )
      
      from tools.setup.steps.base.result import StepResult, PrepareResult
      from tools.setup.ui.output.error import error as format_error
      from tools.setup.ui.progress import ProgressStep
      
      if TYPE_CHECKING:
          from tools.setup.steps.base.meta import BaseStepContext
          from tools.setup.steps.base.step import BaseStep  # optional, nur für Self-Typ
      
      T = TypeVar("T")
      S = TypeVar("S", bound="BaseStep[Any]")     # Self-Typ des Steps
      
      P = ParamSpec("P")                          # zusätzliche Parameter nach ctx
      
      PrepT = TypeVar("PrepT")                    # Typ von prepared
      ProgT = TypeVar("ProgT")                    # Typ von progress
      
      _FAILURE_TEMPLATE = "{name}-Phase fehlgeschlagen."
      
      
      def _log_failure(
          self: Any,
          ctx: "BaseStepContext",
          *,
          func: Callable[..., Any],
          cause: str | None = None,
          details: str | None = None,
          label: str | None = None,
          error_hint: str | None = None,
          with_block: bool = True,
      ) -> None:
          """Gemeinsame Fehlerbehandlung für Step- und Prepare-Ergebnisse.
      
          - formatiert Message via self.output(...)
          - schreibt in ctx.log
          - optional: YAML-Errorblock in self._error_block für BaseStep.run(...)
          """
      
          qualname = getattr(func, "__qualname__", getattr(func, "__name__", "step"))
          effective_label = label or qualname
          default_details = _FAILURE_TEMPLATE.format(name=effective_label)
      
          effective_cause = cause or f"{qualname}_failed"
          effective_details = details or default_details
          effective_error_hint = error_hint or ""
      
          msg = self.output(
              ctx,
              field="failure",
              cause=effective_cause,
              details=effective_details,
          )
      
          ctx.log.write_error(
              section=self.name,
              message=msg,
              details=effective_details,
          )
      
          if with_block:
              # YAML-Block für BaseStep.run(...), z. B. unter dem Progress-Balken
              self._error_block = format_error(
                  step=self.name,
                  stid=self.stid,
                  exc_type=effective_cause,
                  message=effective_error_hint or effective_label or "Schritt fehlgeschlagen",
                  traceback_text=effective_details,
              )
      
      
      def handle_prepare(
          func: Callable[
              Concatenate[S, BaseStepContext, P],
              PrepareResult[T],
          ],
      ) -> Callable[
          Concatenate[S, BaseStepContext, P],
          T | None,
      ]:
          """Dekorator für prepare(...)-Implementierungen, die PrepareResult[T] liefern."""
      
          @wraps(func)
          def wrapper(
              self: S,
              ctx: BaseStepContext,
              *args: P.args,
              **kwargs: P.kwargs,
          ) -> T | None:
              result: PrepareResult[T] = func(self, ctx, *args, **kwargs)
              label = getattr(func, "__qualname__", "prepare")
      
              if not result.ok:
                  _log_failure(
                      self,
                      ctx,
                      func=func,
                      cause=result.cause,
                      details=result.details,
                      label=label,
                      error_hint=result.error_hint,
                      with_block=False,  # Errorblock wird erst später geschrieben
                  )
      
                  default_msg = _FAILURE_TEMPLATE.format(name=label)
                  raise_msg = result.error_hint or result.details or default_msg
                  # wichtig: Laufzeitverhalten unverändert
                  raise RuntimeError(raise_msg)
      
              return result.payload
      
          return wrapper
      
      
      def handle_step(
          func: Callable[
              [S, BaseStepContext, PrepT | None, ProgressStep | None],
              StepResult,
          ],
      ) -> Callable[
          [S, BaseStepContext, PrepT | None, ProgressStep | None],
          bool,
      ]:
          """Dekorator für step(...)-Implementierungen, die StepResult liefern."""
      
          @wraps(func)
          def wrapper(
              self: S,
              ctx: BaseStepContext,
              prepared: PrepT | None,
              progress: ProgressStep | None,
          ) -> bool:
              result: StepResult = func(self, ctx, prepared, progress)
      
              if progress is not None:
                  if result.ok:
                      text = result.label or "OK"
                      progress.set_status(f"Finished /   {text}")
                  else:
                      text = result.label or result.error_hint or "Fehler"
                      progress.set_status(f"Failed   /   {text}")
      
              if not result.ok:
                  _log_failure(
                      self,
                      ctx,
                      func=func,
                      cause=result.cause,
                      details=result.details,
                      label=result.label,
                      error_hint=result.error_hint,
                      with_block=True,
                  )
      
              return result.ok
      
          return wrapper
  - rel_path: setup/steps/base/meta.py
    hash: 6a0bb12a83aae5d110790bc45e907d2061eedd1bb6c809f24995e85b41650c3e
    content: |-
      # tools/setup/steps/base/meta.py
      from __future__ import annotations
      
      import re
      from abc import ABCMeta, ABC
      from dataclasses import dataclass
      from typing import Any, ClassVar, NoReturn, Protocol
      
      from tools.setup.domain import BootstrapConfig, PyProjectProfile
      from tools.setup.logging import ErrorLog
      from tools.setup.ui import SetupConsole
      
      
      _STID_PATTERN = re.compile(r"^[a-z0-9_]+$")
      
      
      @dataclass(slots=True)
      class BaseStepContext:
          config: BootstrapConfig
          profile: PyProjectProfile
          console: SetupConsole
          log: ErrorLog
      
      
      class BaseStepCore(ABC):
          """Minimale gemeinsame Basis für alle Steps, nur für Typen/Registry."""
          stid: ClassVar[str]
          prio: ClassVar[int]
      
      
      class BaseStepMeta(ABCMeta):
          """
          Metaklasse für Setup-Steps.
      
          Validiert:
          - stid existiert und ist ein String
          - stid erfüllt das Pattern [a-z0-9_]+
          - stid ist über alle Steps eindeutig
          """
      
          _registry: dict[str, type[Any]] = {}
      
          @staticmethod
          def throw(
                  name: str,
                  stid: object,
                  reason: str | None = None,
                  obj: str | None = None,
                  exc: type[Exception] = ValueError,
          ) -> NoReturn:
              msg = "Step {name} mit stid {id} ist ungültig{reason}{obj}.".format(
                  name=name,
                  id=stid,
                  reason=f", weil diese {reason}" if reason else "",
                  obj=f" [{obj}]" if obj else "",
              )
              raise exc(msg)
      
      
          def __init__(
                  cls,
                  name: str,
                  bases: tuple[type, ...],
                  namespace: dict[str, Any],
                  **kwargs: Any,  # type: ignore[override]
          ) -> None:
              super().__init__(name, bases, namespace, **kwargs)
      
              # Basis-Klasse selbst nicht validieren
              if name == "BaseStep":
                  return
      
              registry = BaseStepMeta._registry
      
              # dataclass(slots=True)-Sonderfall: Klasse wird neu erzeugt
              for existing_stid, existing_cls in list(registry.items()):
                  if (
                          existing_cls.__name__ == cls.__name__
                          and existing_cls.__module__ == cls.__module__
                          and existing_cls is not cls
                  ):
                      registry[existing_stid] = cls
                      return
      
              stid = getattr(cls, "stid", None)
      
              rsn: str = ""
              obj: str = ""
              err: type[Exception] | None = None
      
              if not isinstance(stid, str) or not stid:
                  rsn = "leer ist"
                  obj = "BaseStep.stid"
                  err = TypeError
              else:
                  if not _STID_PATTERN.fullmatch(stid):
                      rsn = f"nicht dem Pattern {_STID_PATTERN.pattern} entspricht"
                      obj = f"BaseStep.stid={stid!r}"
                      err = ValueError
                  elif stid in registry and registry[stid] is not cls:
                      rsn = "bereits genutzt wird"
                      obj = registry[stid].__name__
                      err = ValueError
      
              if err is not None:
                  BaseStepMeta.throw(
                      name=name,
                      stid=stid,
                      reason=rsn,
                      obj=obj,
                      exc=err,
                  )
      
              if err is not None:
                  BaseStepMeta.throw(
                      name=name,
                      stid=stid,
                      reason=rsn,
                      obj=obj,
                      exc=err,
                  )
      
              registry[stid] = cls
      
      
          @classmethod
          def registry(mcls) -> dict[str, type[Any]]:
              """Optionale Debug-API, falls du die registrierten Steps inspizieren willst."""
              return dict(mcls._registry)
  - rel_path: setup/steps/base/result.py
    hash: 66044abf381f901da2263fb560c74f479cc435347a3147459cd193d3c6dee08f
    content: |
      # tools/setup/steps/base/result.py
      from __future__ import annotations
      
      from dataclasses import dataclass
      from typing import Generic, TypeVar
      
      V = TypeVar("V", covariant=True)
      
      
      @dataclass(slots=True)
      class _BaseResult:
          """
          Standardisiertes Ergebnis von Einheiten
          innerhalb eines Arbeitsschrittes.
      
          - ok         → fachliches Ergebnis
          - cause      → technischer Grund (Error-Code / Kategorie)
          - details    → Rohdetails (z. B. CLI-Output, Traceback-Auszug)
          - label      → für Progress/Statusanzeige (Testname, Paketname, Contract)
          """
          ok: bool
          cause: str = ""
          details: str = ""
          error_hint: str = ""
      
      
      @dataclass(slots=True)
      class PrepareResult(_BaseResult, Generic[V]):
          """Ergebnis eines prepare(...)-Aufrufs."""
          payload: V | None = None
      
      
      @dataclass(slots=True)
      class StepResult(_BaseResult):
          """Standardisiertes Ergebnis eines Steps."""
          label: str = ""
      
          @classmethod
          def success(cls, *, label: str = "", details: str = "") -> StepResult:
              return cls(
                  ok=True,
                  cause="",
                  details=details,
                  label=label,
                  error_hint="",
              )
      
          @classmethod
          def failure(
                  cls,
                  *,
                  cause: str,
                  details: str,
                  label: str = "",
                  error_hint: str | None = None,
          ) -> StepResult:
              text = details or "keine Ausgabe"
              return cls(
                  ok=False,
                  cause=cause or "step_failed",
                  details=text,
                  label=label,
                  error_hint=error_hint or text,
              )
  - rel_path: setup/steps/base/step.py
    hash: b14beb211b24e446b328779ec4332423cb40e39f0acbac138a9cbcd6d708c0c8
    content: |-
      # tools/setup/steps/base/step.py
      from __future__ import annotations
      
      import time
      import traceback
      from abc import ABC, abstractmethod
      from collections.abc import Iterable
      from dataclasses import dataclass, field
      from typing import Any, Generic, Mapping, TypeVar, ClassVar
      
      from tools.setup.steps.base.result import StepResult
      from tools.setup.steps.base.decorator import handle_step
      from tools.setup.steps.base.meta import BaseStepMeta, BaseStepContext, BaseStepCore
      from tools.setup.ui import CATALOG
      from tools.setup.ui.output.error import error
      from tools.setup.ui.progress import ProgressMode, ProgressStep
      
      T = TypeVar("T")  # Typ des prepare()-Ergebnisses
      
      
      @dataclass(slots=True)
      class BaseStep(
          BaseStepCore,
          Generic[T],
          ABC,
          metaclass=BaseStepMeta,
      ):
          """
          Abstrakte Basis eines Setup-Schritts.
      
          Verantwortlichkeiten:
          - Konfiguration (options)
          - Textausgabe (output)
          - Vorbereitungsphase (prepare)
          - fachliche Ausführung (step)
          - zentrale Orchestrierung (run)
          """
      
          mode: ProgressMode = ProgressMode.AUTO
          stid: ClassVar[str] = "base"
          prio: ClassVar[int] = 0
      
          _error_block: str | None = field(default=None, init=False, repr=False)
          _prepared: T | None = field(default=None, init=False, repr=False)
      
      
          @property
          def name(self) -> str:
              return type(self).__name__
      
      
          @property
          def auto_install(self) -> bool:
              """
              Flag für automatische Installation in prepare().
              Default: False – Steps überschreiben bei Bedarf.
              Globale Voreinstellung kann über ctx.profile.auto_install interpretiert werden.
              """
              return False
      
      
          def options(self, ctx: BaseStepContext) -> dict[str, object]:
              """
              Liefert Step-spezifische Optionen aus [tool.setup.options.<stid>].
              """
              raw: Mapping[str, Any] | None = ctx.profile.step_options.get(self.stid)
              return dict(raw or {})
      
      
          @staticmethod
          def _iter_units(prepared: T | None) -> Iterable[Any]:
              """
              Standard-Implementierung:
              - kein prepared → keine Units
              - sonst genau EINE Unit = der gesamte Payload
      
              Steps, die mehrere Arbeitseinheiten haben (Contracts, Dependencies,
              Test-Suites, ...), überschreiben diese Methode und liefern eine
              Sequenz von „Units“.
              """
              return () if prepared is None else (prepared,)
      
      
          def estimate_total(self, prepared: T | None) -> int | None:
              """
              Standard: Anzahl Units als Progress-Gesamtlänge, falls zählbar.
              Spezielle Steps können das überschreiben (z. B. Gewichtung).
              """
              units = list(self._iter_units(prepared))
              return len(units) if units else 1
      
      
          def output(
                  self,
                  ctx: BaseStepContext,
                  *,
                  field: str = "default",
                  **extra: object,
          ) -> str:
              """
              Liefert einen formatierten Text aus setup_ui.toml mit Fallback.
              """
              placeholders: dict[str, object] = {
                  "step": self.name,
                  "env": ctx.config.platform.name,
                  "type": self.stid,
                  "module": self.name,
                  **extra,
              }
      
              status = str(extra.get("status", "")).strip()
              cause = str(extra.get("cause", "")).strip()
              parts = [p for p in (status, cause) if p]
      
              fallback: str = (
                  f"Setup-{self.stid} {self.name}"
                  if field == "header" else
                  f"{self.name}: {' – '.join(parts)}" if parts else self.name
              )
      
              for block in (self.name, "step_default"):
                  if text := CATALOG.format(block, field=field, default="", **placeholders):
                      return text
      
              return fallback
      
      
          # noinspection PyMethodMayBeStatic
          def _ensure(
                  self,
                  ctx: BaseStepContext,
                  *,
                  spec: str | None = None,
                  cmd: Iterable[str] | None = None,
          ) -> bool:
              """
              Führe eine Installation über tools.setup.utils.install aus.
              """
              from tools.setup.utils import install  # Lazy import
              assert (spec is not None) ^ (cmd is not None)
      
              kwargs: dict[str, object] = {"cmd": cmd} if cmd else {
                  "python": str(ctx.config.venv_python),
                  "spec": spec,
              }
      
              rc, *_ = install(
                  cwd=ctx.config.repo_root,
                  **kwargs,
              )
      
              return rc == 0
      
      
          def prepare(self, ctx: BaseStepContext) -> T | None:
              """Optionaler Vorbereitungsschritt, wenn Arbeitsschritt dies erfordert."""
              return None
      
      
          @abstractmethod
          def _step_impl(
                  self,
                  ctx: BaseStepContext,
                  prepared: T | None,
                  progress: ProgressStep | None,
          ) -> StepResult:
              """Fachlicher Kern des Arbeitsschritts."""
              raise NotImplementedError
      
      
          def step(
                  self,
                  ctx: BaseStepContext,
                  prepared: T | None,
                  progress: ProgressStep | None,
          ) -> bool:
              impl = type(self)._step_impl
              wrapped = handle_step(impl) # type: ignore[misc]
              return wrapped(self, ctx, prepared, progress)
      
      
          def run(self, ctx: BaseStepContext) -> bool:
              """
              Orchestriert den Arbeitsschritt.
      
              Ablauf:
              1. prepare(...) liefert Payload
              2. iter_units(...) wandelt Payload in „Units“ um
              3. Progress-Gesamtlänge aus estimate_total(...) / Units
              4. Für jede Unit genau ein step(...)-Aufruf
              """
              self._error_block = None
              self._prepared = self.prepare(ctx)
      
              # Units aus prepared ableiten (1D/2D egal – die Step-Klasse definiert das)
              units = list(self._iter_units(self._prepared))
              has_units = bool(units)
      
              header_text = self.output(ctx, field="header") or f"Setup-{self.stid} {self.name}"
      
              with self.mode.make_context(header_text, ctx.console) as progress:
                  if progress is not None:
                      total_hint = self.estimate_total(self._prepared)
                      if total_hint is None:
                          # Fallback: Anzahl Units, wenn vorhanden
                          total_hint = len(units) if has_units else None
      
                      if isinstance(total_hint, int):
                          progress.set_total(total_hint)
      
                  ok = True
      
                  try:
                      if not has_units:
                          ok = self.step(ctx, None, progress)
                      else:
                          for unit in units:
                              if not self.step(ctx, unit, progress):
                                  ok = False
                                  break
      
                  except BaseException as exc:
                      exc_type_name = type(exc).__name__
                      exc_message = str(exc) or repr(exc)
                      tb_text = "".join(
                          traceback.format_exception(type(exc), exc, exc.__traceback__),
                      )
      
                      msg = self.output(
                          ctx,
                          field="failure",
                          cause=exc_type_name,
                          details=exc_message,
                      )
      
                      if progress is not None:
                          progress.set_status(msg)
                          # keine Entscheidung über „fertig“, nur Status setzen
      
                      block = error(
                          step=self.name,
                          stid=self.stid,
                          exc_type=exc_type_name,
                          message=exc_message,
                          traceback_text=tb_text,
                      )
                      self._error_block = block
                      ctx.console.error(block)
      
                      ctx.log.write_error(
                          section=self.name,
                          message=msg,
                          details=tb_text,
                      )
      
                      ok = False  # wichtig: nur Flag setzen, kein return
      
                  if progress is not None:
                      total = getattr(progress, "total", None)
                      completed = getattr(progress, "completed", 0)
      
                      # Nur bei Erfolg auf 100 % ziehen:
                      if ok and isinstance(total, int) and (delta := total - completed) > 0:
                          progress.advance(delta)
      
                      if ok:
                          progress.mark_finished()
                      else:
                          progress.mark_failed()
      
                  if not ok and self._error_block:
                      ctx.console.error(self._error_block)
      
                  time.sleep(0.5)
                  return ok
  - rel_path: setup/steps/create_env.py
    hash: 645685179895c8883fad5343af77520f52147987ca04c6691e8f4a7f2040f5b3
    content: |-
      # tools/setup/steps/create_env.py
      from __future__ import annotations
      
      import sys
      from dataclasses import dataclass
      from typing import ClassVar, override
      
      from tools.setup.steps.base import BaseStep, BaseStepContext, StepResult
      from tools.setup.ui.progress import ProgressStep
      from tools.setup.utils import run_command
      
      
      @dataclass(slots=True)
      class CreateEnvStep(BaseStep[None]):
          """
          Setup-Schritt zum Erzeugen der Projekt-Virtualenv.
          """
      
          # Registrierung über BaseStepCore
          stid: ClassVar[str] = "create_env"
          prio: ClassVar[int] = sys.maxsize - 1000
      
      
          @override
          def _step_impl(
              self,
              ctx: BaseStepContext,
              prepared: None,
              progress: ProgressStep | None,
          ) -> StepResult:
              # Host-Python verwenden, um die venv zu erstellen
              argv = (sys.executable, "-m", "venv", str(ctx.config.venv_dir))
              result = run_command(argv, cwd=str(ctx.config.repo_root))
      
              if result.returncode == 0:
                  return StepResult(
                      ok=True,
                      label="Virtuelle Umgebung erstellt/gefunden.",
                      details=result.stdout or "",
                  )
      
      
              details = (result.stdout or "") + (result.stderr or "")
              return StepResult(
                  ok=False,
                  cause="create_env_failed",
                  details=details or "keine Ausgabe",
                  label="create_env",
                  error_hint="Erzeugen der virtuellen Umgebung ist fehlgeschlagen.",
              )
  - rel_path: setup/steps/install_deps.py
    hash: 0a37ce40b10141be00ca261acce752203a1726c46cb135c7d6b5b2dca150546e
    content: |-
      # tools/setup/steps/install_deps.py
      from __future__ import annotations
      
      from collections.abc import Sequence
      from dataclasses import dataclass
      from itertools import chain
      from typing import ClassVar, override
      
      from tools.setup.steps.base import (
          BaseStep,
          BaseStepContext,
          StepResult,
          PrepareResult,
          handle_prepare,
      )
      from tools.setup.ui import CATALOG
      from tools.setup.ui.progress import ProgressStep
      from tools.setup.utils import run_command, short_output
      
      Command = tuple[tuple[str, ...], str]  # (argv, label)
      
      
      @dataclass(slots=True)
      class InstallDepsStep(BaseStep[Sequence[Command]]):
          """
          Setup-Schritt zur Installation der Projekt-Abhängigkeiten aus pyproject.toml.
      
          Strategie:
          - Projekt im Editable-Modus installieren: python -m pip install -e .
          - Laufzeit-Dependencies aus [project].dependencies einzeln installieren
          - Dev-Dependencies aus [project.optional-dependencies].dev einzeln installieren
          """
      
          stid: ClassVar[str] = "dependencies"
          prio: ClassVar[int] = 9999
      
          @override
          def estimate_total(self, prepared: Sequence[Command] | None) -> int | None:
              if prepared:
                  return len(prepared)
              return 1
      
      
          @override
          @handle_prepare
          def prepare(self, ctx: BaseStepContext) -> PrepareResult:
              """
              Erzeugt die Liste von Installations-Kommandos aus dem bereits geladenen
              PyProjectProfile (runtime_requirements + dev_requirements).
              """
              python = str(ctx.config.venv_python)
              base = (python, "-m", "pip", "install")
      
              commands: list[Command] = [((*base, "-e", "."), "Projekt (editable)")]
      
              for name, spec in chain(
                  ctx.profile.runtime_requirements.items(),
                  ctx.profile.dev_requirements.items(),
              ):
                  label = f"{name}{spec}"
                  commands.append(((*base, label), label))
      
              return PrepareResult(
                  ok=True,
                  payload=tuple(commands),
              )
      
      
          @override
          def _step_impl(
              self,
              ctx: BaseStepContext,
              prepared: Sequence[Command] | None,
              progress: ProgressStep | None,
          ) -> StepResult:
              assert prepared is not None, "InstallDepsStep.prepare() muss Commands liefern."
      
              cwd = str(ctx.config.repo_root)
              total = len(prepared) or 1
              empty_output = "keine Ausgabe"
      
              def fmt(field: str, default: str, **kwargs: object) -> str:
                  return CATALOG.format(
                      "step_default",
                      field=field,
                      default=default,
                      **kwargs,
                  )
      
              def status(field: str, default: str, **kwargs: object) -> None:
                  if progress is not None:
                      progress.set_status(fmt(field, default, **kwargs))
      
              if total:
                  status(
                      "progress_running",
                      "Running  /   {details}",
                      details=f"Installiere Abhängigkeiten ({total} Pakete)",
                  )
      
              ok = True
              cause: str | None = None
              last_label = ""
              last_details = ""
              error_hint: str | None = None
      
              for index, (argv, label) in enumerate(prepared, start=1):
                  last_label = label
      
                  # Laufender Status: welches Paket wird gerade installiert?
                  status(
                      "progress_running",
                      "Running  /   {details}",
                      details=fmt(
                          "install_details",
                          "Installiere: {package} ({index}/{total})",
                          package=label,
                          index=index,
                          total=total,
                      ),
                  )
      
                  result = run_command(argv, cwd=cwd)
                  raw = (result.stdout or "") + (result.stderr or "")
                  last_details = raw or empty_output
      
                  if result.returncode == 0:
                      if progress is not None:
                          progress.advance(1)
                      continue
      
                  # Fehlerfall
                  ok = False
                  cause = "pip_install_failed"
                  short = short_output(raw) or last_details
      
                  # Hier darf es ruhig sofort einen roten Status geben;
                  status(
                      "progress_failed",
                      "Failed   /   {details}",
                      details=fmt(
                          "install_failed",
                          "{package}: {details}",
                          package=label,
                          details=short,
                      ),
                  )
      
                  error_hint = f"{label}: {short}"
                  break
      
              # Auf Summen-Label mappen:
              # - Erfolg  → „Alle Abhängigkeiten installiert.“
              # - Fehler  → Name des zuletzt fehlgeschlagenen Pakets
              label = (
                  CATALOG.format(
                      "step_default",
                      field="install_done",
                      default="Alle Abhängigkeiten installiert.",
                  )
                  if ok
                  else last_label
              )
      
              return StepResult(
                  ok=ok,
                  cause=cause or "",
                  details=last_details or empty_output,
                  label=label,
                  error_hint=error_hint or "",
              )
  - rel_path: setup/steps/linter_check.py
    hash: 418b79f9d49d08416f4fd30c7cf249ca7cb330060494b128439f0ab6f8f4da64
    content: |-
      # tools/setup/steps/linter_check.py
      from __future__ import annotations
      
      import logging
      from collections.abc import Mapping
      from dataclasses import dataclass
      from typing import Any, ClassVar, override
      
      from tools.setup.steps.base import (
          BaseStep,
          BaseStepContext,
          StepResult,
          PrepareResult,
          handle_prepare,
      )
      from tools.setup.ui import CATALOG
      from tools.setup.ui.progress import ProgressStep
      from tools.setup.utils import module, run_single
      
      
      logger = logging.getLogger(__name__)
      
      @dataclass(slots=True)
      class EvaluateImportsStep(BaseStep[tuple[str, ...]]):
          """
          Setup-Schritt zum Ausführen von import-linter (Import-Regelprüfung).
          """
      
          stid: ClassVar[str] = "import_linter"
          prio: ClassVar[int] = 40
      
          @override
          @property
          def auto_install(self) -> bool:
              """import-linter darf bei Bedarf automatisch nachinstalliert werden."""
              return True
      
      
          def _prepare_error(
              self,
              default_msg: str,
              *,
              exc_info: str | None,
              output: str,
          ) -> PrepareResult[tuple[str, ...]]:
              """
              Gemeinsame Fehlererzeugung für die Prepare-Phase:
              - klassifiziert Fehler (install / probe)
              - erzeugt ein einheitliches PrepareResult
              """
              cause, details = module.classify(
                  exc_info=exc_info,
                  output=output,
                  module="importlinter",
              )
              text = details or output or default_msg
              return PrepareResult(
                  ok=False,
                  cause=cause,
                  details=text,
                  error_hint=text,
                  payload=None,
              )
      
      
          @staticmethod
          def _select_contracts(
              raw: Any,
              mode: str,
          ) -> tuple[str, ...]:
              """
              Filterschicht für Contracts:
              - liest aus der rohen Config-Liste
              - filtert nach type (forbidden / layers / all)
              - gibt eine nicht-leere Tuple-Liste zurück
              """
              if not isinstance(raw, list):
                  return ("Konfigurationsprüfung",)
      
              def type_matches(item: Mapping[str, object]) -> bool:
                  # Typ des Contracts; leer = „egal“ (nur bei mode == "all" relevant)
                  ctype = str(item.get("type", "")).strip().lower()
                  if mode == "forbidden":
                      return ctype == "forbidden"
                  if mode == "layers":
                      return ctype == "layers"
                  return True  # "all"
      
              names = [
                  name
                  for item in raw
                  if isinstance(item, Mapping)
                  if type_matches(item)
                  if (name := str(item.get("name", "")).strip())
              ]
      
              # Fallback: mindestens eine „logische“ Einheit anzeigen
              return tuple(names) or ("Konfigurationsprüfung",)
      
      
          @override
          @handle_prepare
          def prepare(self, ctx: BaseStepContext) -> PrepareResult[tuple[str, ...]] | PrepareResult:
              """
              Prepare-Ablauf:
              1. importlinter.cli probeweise aufrufen
              2. ggf. Auto-Installation versuchen
              3. aus Profil die relevante Contract-Liste ermitteln
              """
              python = str(ctx.config.venv_python)
              cwd = ctx.config.repo_root
      
              def probe() -> tuple[bool, str, str | None]:
                  """Einmaliger Probelauf von importlinter.cli (--help) im venv."""
                  return module.evaluate(
                      python=python,
                      module="importlinter.cli",
                      cwd=cwd,
                      extra_args=("--help",),
                  )
      
              # 1. erster Probeaufruf
              ok, output, exc_info = probe()
      
              # 2. Auto-Installation, falls erlaubt und erforderlich
              if self.auto_install and not ok:
                  rc, raw_install, _ = module.install(
                      python=python,
                      spec="import-linter",
                      cwd=cwd,
                  )
                  if rc != 0:
                      # Installation fehlgeschlagen → als Prepare-Fehler melden
                      return self._prepare_error(
                          "import-linter Installation fehlgeschlagen",
                          exc_info=None,
                          output=raw_install,
                      )
      
                  # nach erfolgreicher Installation erneut probieren
                  ok, output, exc_info = probe()
      
              # 3. Probe nach evtl. Installation immer noch nicht ok → harter Fehler
              if not ok:
                  return self._prepare_error(
                      "import-linter Probe fehlgeschlagen",
                      exc_info=exc_info,
                      output=output,
                  )
      
              # 4. Contract-Liste aus Profil ableiten
              contracts_raw: Any = ctx.profile.get_path(
                  "tool",
                  "importlinter",
                  "contracts",
                  default=[],
              )
              contracts = self._select_contracts(
                  raw=contracts_raw,
                  mode=ctx.profile.linter_contracts,
              )
      
              return PrepareResult(ok=True, payload=contracts)
      
          @override
          def _step_impl(
                  self,
                  ctx: BaseStepContext,
                  prepared: tuple[str, ...] | None,
                  progress: ProgressStep | None,
          ) -> StepResult:
              tests = prepared or (None,)
      
              tests_done_label = CATALOG.format(
                  "RunTestsStep",
                  field="tests_done",
                  default="Alle Tests erfolgreich.",
              )
              tests_failed_label = CATALOG.format(
                  "RunTestsStep",
                  field="tests_failed",
                  default="Tests fehlgeschlagen – Details siehe Log.",
              )
      
              def make_result(ok: bool, cause: str, details: str) -> StepResult:
                  text = details or "keine Ausgabe"
                  return StepResult(
                      ok=ok,
                      cause="" if ok else (cause or "tests_failed"),
                      details=text,
                      label=tests_done_label if ok else tests_failed_label,
                      error_hint="" if ok else text,
                  )
      
              def update_progress(index: int, total: int, nodeid: str | None) -> None:
                  if progress is None:
                      return
                  test_details = CATALOG.format(
                      "RunTestsStep",
                      field="test_details",
                      default="Test {index}/{total}: {test}",
                      index=index,
                      total=total,
                      test=nodeid or "<alle>",
                  )
                  running = CATALOG.format(
                      "step_default",
                      field="progress_running",
                      default="Running  /   {details}",
                      details=test_details,
                  )
                  progress.set_status(running)
      
              total = len(tests)
              last_details = ""
      
              for index, nodeid in enumerate(tests, start=1):
                  update_progress(index, total, nodeid)
      
                  ok, cause, details = run_single(
                      python=str(ctx.config.venv_python),
                      cwd=ctx.config.repo_root,
                      logger=logger,
                  )
                  last_details = details
      
                  if progress is not None:
                      progress.advance(1)
      
                  if not ok:
                      return make_result(False, cause, last_details)
      
              return make_result(True, "", last_details)
  - rel_path: setup/steps/test_runner.py
    hash: 6a2efa3edfc52fc5c0aa2092d45ca3f2ec060969be9e1de2a66cef39bae5fd22
    content: |-
      from __future__ import annotations
      
      import logging
      import re
      from dataclasses import dataclass
      from typing import ClassVar, override
      
      from tools.setup.steps.base import (
          BaseStep,
          BaseStepContext,
          StepResult,
          PrepareResult,
          handle_prepare,
      )
      from tools.setup.ui import CATALOG
      from tools.setup.ui.progress import ProgressStep
      from tools.setup.utils import module, run_single
      
      logger = logging.getLogger(__name__)
      
      # Beispielzeilen aus pytest --collect-only:
      # <Dir ufo-simulation-schulung>
      #   <Dir tests>
      #     <Dir core>
      #       <Dir simulation>
      #         <Dir observer>
      #           <Module test_heading_delta.py>
      #             <Class TestNormalizeHeadingDelta>
      #               <Function test_no_wrap_around_positive_small>
      _COLLECT_LINE_RE = re.compile(
          r"^(?P<indent>\s*)<(?P<kind>Dir|Module|Class|Function) (?P<name>[^>]+)>"
      )
      
      
      @dataclass(slots=True)
      class RunTestsStep(BaseStep[tuple[tuple[str, str], ...]]):
          """
          Setup-Schritt zum Ausführen der Test-Suite via pytest.
      
          prepared-Payload:
              tuple[(testfile_relpath, qualified_name), ...]
      
          Beispiel eines Eintrags:
              ("tests/core/simulation/observer/test_heading_delta.py",
               "TestNormalizeHeadingDelta::test_no_wrap_around_positive_small")
          """
      
          stid: ClassVar[str] = "tests"
          prio: ClassVar[int] = 0
      
          @override
          def estimate_total(
              self,
              prepared: tuple[tuple[str, str], ...] | None,
          ) -> int | None:
              if prepared:
                  return len(prepared)
              # Fallback: Gesamtlauf
              return 1
      
          @override
          @handle_prepare
          def prepare(self, ctx: BaseStepContext) -> PrepareResult[tuple[tuple[str, str], ...]]:
              """
              Führt `pytest --collect-only` aus und baut daraus ein 2D-Array:
      
                  [(testfile_relpath, qualified_name), ...]
      
              qualified_name ist z. B. "Class::SubClass::test_func"
              oder bei freien Funktionen einfach "test_func".
              """
              ok, output, exc_info = module.evaluate(
                  python=str(ctx.config.venv_python),
                  module="pytest",
                  cwd=ctx.config.repo_root,
                  extra_args=("--collect-only",),
              )
      
              if not ok:
                  kind, details = module.classify(
                      exc_info=exc_info,
                      output=output,
                      module="pytest",
                  )
                  text = details or output or "pytest --collect-only fehlgeschlagen"
                  return PrepareResult(
                      ok=False,
                      cause=kind,
                      details=text,
                      error_hint=text,
                      payload=None,
                  )
      
              text = output or ""
      
              # Stack über die Baumstruktur; jedes Element:
              # (kind, name, level)
              stack: list[tuple[str, str, int]] = []
              pairs: list[tuple[str, str]] = []
      
              for line in text.splitlines():
                  m = _COLLECT_LINE_RE.match(line)
                  if not m:
                      continue
      
                  indent = m.group("indent") or ""
                  level = len(indent) // 2
                  kind = m.group("kind")
                  name = m.group("name")
      
                  # Stack auf aktuelle Ebene kürzen
                  while stack and stack[-1][2] >= level:
                      stack.pop()
      
                  if kind == "Function":
                      # Wir haben eine Funktion; Module + Klassen aus dem Stack auslesen
                      if not any(k == "Module" for k, _, _ in stack):
                          continue
      
                      # Index des letzten Modules im Stack
                      module_index = max(
                          i for i, (k, _, _) in enumerate(stack) if k == "Module"
                      )
      
                      # Verzeichnisse vor dem Module-Eintrag
                      dir_parts = [
                          n
                          for k, n, _ in stack[:module_index]
                          if k == "Dir"
                      ]
                      module_name = stack[module_index][1]
      
                      # Relativer Pfad ab "tests" aufbauen
                      if "tests" in dir_parts:
                          idx = dir_parts.index("tests")
                          dir_parts = dir_parts[idx:]
                      module_path = "/".join(dir_parts + [module_name])
      
                      # Klassen zwischen Module und Function einsammeln
                      class_names = [
                          n
                          for k, n, _ in stack[module_index + 1 :]
                          if k == "Class"
                      ]
                      if class_names:
                          qualified = "::".join((*class_names, name))
                      else:
                          qualified = name
      
                      pairs.append((module_path, qualified))
                      continue
      
                  # Für Dir / Module / Class: Node in den Stack pushen
                  stack.append((kind, name, level))
      
              return PrepareResult(
                  ok=True,
                  payload=tuple(pairs),
              )
      
          @override
          def _step_impl(
                  self,
                  ctx: BaseStepContext,
                  prepared: tuple[tuple[str, str], ...] | None,
                  progress: ProgressStep | None,
          ) -> StepResult:
              python = str(ctx.config.venv_python)
              cwd = ctx.config.repo_root
      
              tests: tuple[tuple[str, str], ...] = prepared or tuple()
              total = len(tests)
      
              tests_done_label = CATALOG.format(
                  "RunTestsStep",
                  field="tests_done",
                  default="Alle Tests erfolgreich.",
              )
              tests_failed_label = CATALOG.format(
                  "RunTestsStep",
                  field="tests_failed",
                  default="Tests fehlgeschlagen – Details siehe Log.",
              )
      
              def run_with_progress(
                      *,
                      nodeid: str | None,
                      status: str | None,
              ) -> tuple[bool, str | None, str]:
                  # ====================================================
                  # Deinition interner Methoden
                  # ====================================================
                  if progress is not None and status:
                      progress.set_status(status)
      
                  ok, cause, details = run_single(
                      python=python,
                      cwd=cwd,
                      nodeid=nodeid,
                      logger=logger,
                  )
      
                  if progress is not None:
                      progress.advance(1)
      
                  return ok, cause, details or ""
      
              def make_result(ok: bool, cause: str | None, details: str) -> StepResult:
                  if ok:
                      return StepResult.success(
                          label=tests_done_label,
                          details=details,
                      )
                  return StepResult.failure(
                      cause=cause or "tests_failed",
                      details=details,
                      label=tests_failed_label,
                  )
              # ====================================================
              # Methodenstart
              # ====================================================
      
              # Fall 1: Kein einzelnes Test-Listing → Gesamtlauf
              if not tests:
                  ok, cause, details = run_with_progress(
                      nodeid=None,
                      status="Running  /   pytest-Gesamtlauf",
                  )
                  return make_result(ok, cause, details)
      
              # Fall 2: Einzelläufe mit Fortschritt
              last_ok = True
              last_cause: str | None = None
              last_details = ""
      
              for index, (file_relpath, qualified_name) in enumerate(tests, start=1):
                  nodeid = f"{file_relpath}::{qualified_name}"
                  func_name = qualified_name.split("::")[-1]
                  status = f"Running  /   Test {index}/{total}: {func_name}"
      
                  ok, cause, details = run_with_progress(
                      nodeid=nodeid,
                      status=status,
                  )
      
                  last_ok = ok
                  last_cause = cause
                  last_details = details
      
                  if not ok:
                      break
      
              return make_result(last_ok, last_cause, last_details)
  - rel_path: setup/ui/__init__.py
    hash: 1f0e990a42b38bada39f55fa230ab7ec4893132e45b372fff25fd7439766aa06
    content: |
      # tools/setup/ui/__init__.py
      from __future__ import annotations
      
      """
      Öffentliche UI-Schnittstellen für das Setup.
      """
      
      from tools.setup.ui.console import SetupConsole
      
      from tools.setup.ui.progress.step import ProgressStep
      from tools.setup.ui.progress.mode import ProgressMode
      
      from tools.setup.ui.resources import (
          TextBlock,
          TextCatalog,
          CATALOG,
      )
      from tools.setup.ui.resources.icons import (
          MessageLevel,
          ProgressStatus,
      )
      
      __all__ = [
          "SetupConsole",
          "ProgressStep",
          "ProgressMode",
          "TextBlock",
          "TextCatalog",
          "CATALOG",
          "MessageLevel",
          "ProgressStatus",
      ]
  - rel_path: setup/ui/console.py
    hash: fcc6221481c58b49330e3afb9d92fdf5e8f24c8ac90b197b6ccd743ed039b2aa
    content: |
      # tools/setup/ui/console.py
      from __future__ import annotations
      
      from dataclasses import dataclass
      
      from tools.setup.ui.resources.icons import MessageLevel
      
      
      @dataclass(slots=True)
      class SetupConsole:
          """
          Schlankes Konsolen-Frontend für das Setup ohne externe Abhängigkeiten.
      
          Bietet eine kleine, klar definierte API für Setup-Schritte.
          """
      
          # noinspection PyMethodMayBeStatic
          def _emit(self, level: MessageLevel, message: str) -> None:
              prefix = level.icon
              line = f"{prefix} {message}" if prefix else message
              print(line)
      
          # öffentliche API – von Steps verwendet
          def info(self, message: str) -> None:
              self._emit(MessageLevel.INFO, message)
      
          def warning(self, message: str) -> None:
              self._emit(MessageLevel.WARNING, message)
      
          def error(self, message: str) -> None:
              self._emit(MessageLevel.ERROR, message)
      
          def result(self, message: str, ok: bool) -> None:
              level = MessageLevel.SUCCESS if ok else MessageLevel.ERROR
              self._emit(level, message)
      
          # noinspection PyMethodMayBeStatic
          def header(self, message: str) -> None:
              # Header bewusst ohne Level-Icon, um die Einleitung nicht zu überfrachten
              print(message)
  - rel_path: setup/ui/output/__init__.py
    hash: 1acc797a9f8afa2cbb5f3f09f2789e5297b7fef7ebac47d56af8b92d9be1da27
    content: |
      from __future__ import annotations
      
      from .message import Message
      from .error import error
      
      __all__ = ["Message", "error"]
  - rel_path: setup/ui/output/error.py
    hash: e9759ec28788a5b13412b729d73d4e6975a8c2862af81011142c7dae823403f2
    content: |
      # tools/setup/ui/error.py
      from __future__ import annotations
      
      from datetime import datetime, timezone
      
      
      def error(
              *,
              step: str,
              stid: str,
              exc_type: str,
              message: str,
              traceback_text: str,
              timestamp: datetime | None = None,
      ) -> str:
          ts = timestamp or datetime.now(timezone.utc)
          iso = ts.isoformat(timespec="seconds")
      
          lines: list[str] = [
              "error:",
              f"  step: {step}",
              f"  stid: {stid}",
              f"  type: {exc_type}",
              f"  message: {message}",
              "  traceback: |",
          ]
          for line in traceback_text.rstrip().splitlines():
              lines.append(f"    {line}")
          lines.append(f"  timestamp: {iso}")
          lines.append("")
      
          return "\n".join(lines)
  - rel_path: setup/ui/output/message.py
    hash: 40938c752242a38be547f32290ab972d8cd7e9224893ff37087e879cf396991d
    content: |
      from __future__ import annotations
      
      """
      Strukturiertes Nachrichtenmodell für die Setup-Konsole.
      
      Dieses Modul kapselt den Nachrichtentyp, der von der SetupConsole
      für eine einheitliche Ausgabe verwendet wird.
      """
      
      from dataclasses import dataclass
      
      from tools.setup.ui.resources.icons import MessageLevel
      
      
      @dataclass(slots=True, frozen=True)
      class Message:
          """
          Strukturierte Nachricht für die Setup-Konsole.
      
          Attributes:
              level: Logische Stufe der Nachricht (info, success, warning, error, plain).
              content: Auszugebender Nachrichtentext (muss nichtleer sein).
          """
      
          level: MessageLevel
          content: str
      
          def __post_init__(self) -> None:
              if not self.content:
                  raise ValueError("Message.content must not be empty")
  - rel_path: setup/ui/progress/__init__.py
    hash: 180321fb53b6747e9a9e0f70468eaa091a98384f215a79d9fad5b95eb64e12f9
    content: |
      # tools/setup/ui/progress/__init__.py
      from __future__ import annotations
      
      """
      Interne Prozessdarstellungsebene für das Setup.
      
      Dieses Paket bündelt:
      - ProgressStep (Fortschrittsanzeige)
      - ProgressMode (Steuerung des Fortschrittsverhaltens)
      """
      
      from .mode import ProgressMode
      from .step import ProgressStep
      
      __all__: list[str] = ["ProgressMode", "ProgressStep"]
  - rel_path: setup/ui/progress/mode.py
    hash: 873b4c9b85def346d0cf0ee7cc84aa470fcddb53baa5720c29762cae6c19ea38
    content: |
      # tools/setup/ui/progress/mode.py
      from __future__ import annotations
      
      """
      Steuerung des Fortschrittsverhaltens von Setup-Schritten.
      """
      
      from contextlib import nullcontext
      from enum import Enum, auto
      from typing import ContextManager, TYPE_CHECKING
      
      from tools.setup.ui.console import SetupConsole
      
      if TYPE_CHECKING:
          from .step import ProgressStep
      
      
      class ProgressMode(Enum):
          """
          Steuerung des Fortschrittsverhaltens eines Setup-Schritts.
      
          NONE   → keine Fortschrittsanzeige
          AUTO   → Standard-Fortschrittsanzeige
          SIMPLE → aktuell identisch zu AUTO, für spätere Varianten reserviert
          """
      
          NONE = auto()
          AUTO = auto()
          SIMPLE = auto()
      
          def make_context(
                  self,
                  description: str,
                  console: SetupConsole,
          ) -> ContextManager["ProgressStep | None"]:
              """
              Liefert den passenden Kontextmanager:
      
              - NONE  → nullcontext(None) (kein Fortschritt)
              - AUTO/SIMPLE → ProgressStep mit initial indeterminiertem Balken.
              """
              if self is ProgressMode.NONE:
                  return nullcontext(None)
      
              from .step import ProgressStep
      
              return ProgressStep(
                  description=description,
                  total=None,
                  console=console,
              )
  - rel_path: setup/ui/progress/step.py
    hash: 5039eca1ffc14d89d3bc355a65c5882dd6b6c4fd52e75b0a2161a05d85d6756a
    content: |
      from __future__ import annotations
      
      import sys
      from dataclasses import dataclass, field
      from threading import Lock
      from types import TracebackType
      from typing import Final
      
      from tools.setup.ui.console import SetupConsole
      from tools.setup.ui.resources.icons import ProgressStatus
      
      # einfache ANSI-Farben
      _RESET = "\x1b[0m"
      _GREEN = "\x1b[32m"
      _RED = "\x1b[31m"
      _DIM = "\x1b[2m"
      
      _BAR_WIDTH: Final[int] = 40
      
      
      @dataclass(slots=True)
      class ProgressStep:
          """
          Minimalistisch-moderner Fortschritt:
      
              Setup-<stid> <StepName>: <info>      (header, 1×)
              [██░░…]  42%  ⏳ Running / ...       (eine Zeile, via \\r aktualisiert)
      
          Besonderheit:
          - Sichtbarer Fortschritt läuft immer in 1%-Schritten von alt → neu,
            auch wenn intern Sprünge wie 0 → 17 → 32 ankommen.
          """
      
          description: str
          total: int | None
          console: SetupConsole
      
          _status: ProgressStatus = field(default=ProgressStatus.STARTING, init=False, repr=False)
          _completed: int = field(default=0, init=False, repr=False)
          _status_text: str = field(default="", init=False, repr=False)
          _lock: Lock = field(default_factory=Lock, init=False, repr=False)
      
          _header_printed: bool = field(default=False, init=False, repr=False)
          _last_line: str = field(default="", init=False, repr=False)
      
          # sichtbarer Prozentwert (0–100), unabhängig von _completed
          _display_percent: int = field(default=0, init=False, repr=False)
      
          # ------------------------------------------------------------
          # Eigenschaften, die BaseStep.run erwartet
          # ------------------------------------------------------------
      
          @property
          def completed(self) -> int:
              return self._completed
      
          @property
          def status(self) -> ProgressStatus:
              return self._status
      
          # ------------------------------------------------------------
          # Kontextmanager
          # ------------------------------------------------------------
      
          def __enter__(self) -> "ProgressStep":
              with self._lock:
                  self._status = ProgressStatus.STARTING
                  self._status_text = self._status.label
                  self._completed = 0
                  self._display_percent = 0
                  self._render_locked()
              return self
      
          def __exit__(
                  self,
                  exc_type: type[BaseException] | None,
                  exc: BaseException | None,
                  tb: TracebackType | None,
          ) -> bool:
              return False
      
          # ------------------------------------------------------------
          # Öffentliche API für Steps / BaseStep.run
          # ------------------------------------------------------------
      
          def set_total(self, total: int | None) -> None:
              """
              total=None → indeterminiert (Text "Aktueller Schritt …")
              total>0    → deterministischer Prozentbalken
              """
              with self._lock:
                  self.total = total
                  if total is None:
                      self._completed = 0
                      self._display_percent = 0
                  else:
                      self._completed = min(self._completed, total)
                      if self._status is ProgressStatus.STARTING:
                          self._status = ProgressStatus.RUNNING
                          if not self._status_text:
                              self._status_text = self._status.label
                  self._render_locked()
      
          def advance(self, steps: int = 1) -> None:
              """
              Erhöht den logischen Fortschritt um `steps` und rendert neu.
              """
              with self._lock:
                  if self.total and self.total > 0:
                      self._completed = min(self.total, self._completed + steps)
                      if self._status is ProgressStatus.STARTING:
                          self._status = ProgressStatus.RUNNING
                  self._render_locked()
      
          def set_status(self, text: str) -> None:
              """
              Aktualisiert den Status-Text (z. B. "Installiere: Paket X (3/12)").
              """
              with self._lock:
                  self._status_text = text
                  self._render_locked()
      
          def mark_finished(self) -> None:
              with self._lock:
                  self._status = ProgressStatus.FINISHED
                  if self.total and self.total > 0:
                      self._completed = self.total
                  if not self._status_text:
                      self._status_text = self._status.label
                  self._render_locked(final=True)
      
          def mark_failed(self) -> None:
              with self._lock:
                  self._status = ProgressStatus.FAILED
                  if self.total and self.total > 0:
                      self._completed = self.total
                  if not self._status_text:
                      self._status_text = self._status.label
                  self._render_locked(final=True)
      
          def emit_info(self, *, step: str, message: str) -> None:
              """
              Zusatz-Infos, z. B. Debug-Hinweise während des Steps.
              """
              with self._lock:
                  # laufende Progresszeile sauber beenden
                  if self._last_line:
                      sys.stdout.write("\n")
                      sys.stdout.flush()
                      self._last_line = ""
                  print(f"info: {step}: {message}", flush=True)
      
          # ------------------------------------------------------------
          # Rendering-Helfer
          # ------------------------------------------------------------
      
          def _build_header(self) -> str:
              return self.description
      
          def _build_bar_from_percent(self, percent: int | None) -> str:
              """
              Baut den Balken aus einem Prozentwert (0–100) oder indeterminiert.
              """
              if percent is None:
                  return "Aktueller Schritt …"
      
              percent = max(0, min(100, percent))
              filled = int(_BAR_WIDTH * (percent / 100))
              empty = _BAR_WIDTH - filled
              return f"[{'█' * filled}{'░' * empty}] {percent:3d}%"
      
          def _build_status(self) -> str:
              text = self._status_text or self._status.label
              base = f"{self._status.icon} {text}"
      
              if self._status is ProgressStatus.FINISHED:
                  return f"{_GREEN}{base}{_RESET}"
              if self._status is ProgressStatus.FAILED:
                  return f"{_RED}{base}{_RESET}"
              return f"{_DIM}{base}{_RESET}"
      
          def _build_line_for_percent(self, percent: int | None) -> str:
              bar = self._build_bar_from_percent(percent)
              status = self._build_status()
              return f"{bar}  {status}"
      
          # ------------------------------------------------------------
          # Zentrales Rendering
          # ------------------------------------------------------------
      
          def _render_locked(self, *, final: bool = False) -> None:
              """
              Header einmal ausgeben, Fortschritt in 1%-Schritten von alt → neu animieren.
              """
              # Header genau einmal
              if not self._header_printed:
                  print(self._build_header(), flush=True)
                  self._header_printed = True
      
              # indeterminierter Modus: kein % → nur eine Zeile
              if self.total is None or self.total <= 0:
                  line = self._build_line_for_percent(None)
                  if line != self._last_line:
                      sys.stdout.write("\r" + line)
                      sys.stdout.flush()
                      self._last_line = line
                  if final:
                      sys.stdout.write("\n")
                      sys.stdout.flush()
                      self._last_line = ""
                  return
      
              # Ziel-Prozent aus logischem Stand
              target_ratio = self._completed / self.total if self.total else 0.0
              target_percent = max(0, min(100, int(target_ratio * 100)))
      
              # Rückwärtsbewegung clampen
              if target_percent < self._display_percent:
                  self._display_percent = target_percent
      
              # „Animation“: von aktuellem Display-Wert bis Ziel hochzählen
              start = self._display_percent
              end = target_percent
      
              if start == end and not final:
                  # nichts zu tun
                  return
      
              for p in range(start + 1, end + 1) if end > start else [start]:
                  self._display_percent = p
                  line = self._build_line_for_percent(p)
                  # Minimaler Spam-Schutz
                  if line == self._last_line:
                      continue
                  sys.stdout.write("\r" + line)
                  sys.stdout.flush()
                  self._last_line = line
      
              # finaler Abschluss → Zeilenumbruch setzen
              if final:
                  sys.stdout.write("\n")
                  sys.stdout.flush()
                  # self._last_line = ""
  - rel_path: setup/ui/resources/__init__.py
    hash: b88acb9a817a39e4d08ea6d7b4358e3a18b942d5dfb4f2e2d46e04b18d2b4eef
    content: |
      from __future__ import annotations
      
      """
      Ressourcen für UI-Texte und Icons des Setup-Prozesses.
      
      Dieses Unterpaket stellt:
      - :class:`TextBlock` als Basistyp für Textbausteine,
      - :class:`TextCatalog` als TOML-basierte Sammlung von Texten und Icons,
      - :data:`CATALOG` als vorkonfigurierte Standardinstanz
      bereit.
      """
      
      from .block import TextBlock
      from .catalog import TextCatalog, CATALOG
      
      __all__: tuple[str, ...] = (
          "TextBlock",
          "TextCatalog",
          "CATALOG",
      )
  - rel_path: setup/ui/resources/block.py
    hash: 3d4b3633b498a32f6e740d48c3c9f0885ffc67a5a94f16200f1689913f918319
    content: |
      from __future__ import annotations
      
      """
      Grundlegender Textbaustein für UI-Ressourcen im Setup.
      
      Dieses Modul definiert die generische Struktur eines Textblocks,
      der von Katalogen wie TextCatalog verwendet wird.
      """
      
      from dataclasses import dataclass
      from typing import Any, Mapping
      
      
      @dataclass(slots=True, frozen=True)
      class TextBlock:
          """
          Textbaustein mit frei definierbaren Feldern.
      
          Typische Felder (konventionell):
          - title
          - intro
          - body
          - hint
          """
      
          key: str
          fields: Mapping[str, Any]
      
          @staticmethod
          def _normalize(value: Any, default: str) -> str:
              """
              Normalisiert einen Feldwert zu einem String.
      
              None → default, alles andere → str(value).
              """
              result: str = default if value is None else str(value)
              return result
      
          def get(self, field: str, default: str = "") -> str:
              """
              Liefert ein Feld oder einen Default-Text.
      
              Args:
                  field: Feldname innerhalb des Blocks.
                  default: Rückgabewert, falls das Feld nicht existiert.
      
              Returns:
                  Feldinhalt als String oder der Default-Wert.
              """
              raw_value: Any = self.fields.get(field, default)
              result: str = self._normalize(raw_value, default)
              return result
      
          def format(self, field: str = "body", **kwargs: Any) -> str:
              """
              Formatiert ein Feld mit den gegebenen Platzhaltern.
      
              Nicht vorhandene Felder werden als leerer String behandelt.
      
              Args:
                  field: Feldname, der formatiert werden soll.
                  **kwargs: Platzhalter für die Formatierung.
      
              Returns:
                  Formatierter Text oder ein leerer String.
              """
              template: str = self.get(field, "")
              result: str = "" if not template else template.format(**kwargs)
              return result
  - rel_path: setup/ui/resources/catalog.py
    hash: deda6e93a838d8db6e47bd691ba3987e9fa48d19cc834af93b802eb953276f7a
    content: |
      from __future__ import annotations
      
      """
      Text- und Icon-Katalog für das Setup der UFO-Simulation.
      
      Dieses Modul lädt die Ressourcen aus der TOML-Datei `setup_ui.toml`
      und stellt eine Lookup-API für Texte und Icons bereit.
      """
      
      from dataclasses import dataclass
      from pathlib import Path
      from typing import Any, Final, Mapping, Optional
      
      import tomllib
      
      from tools.setup.ui.resources.block import TextBlock
      
      
      @dataclass(slots=True, frozen=True)
      class TextCatalog:
          """
          Katalog aller Textbausteine und Icons für das Setup.
      
          Lädt Inhalte aus der TOML-Ressource `setup_ui.toml` und bietet
          Zugriff über `text()`, `format()` und `icon()`.
          """
      
          _blocks: Mapping[str, TextBlock]
          _icons: Mapping[str, str]
      
          @classmethod
          def load(cls, path: Path) -> "TextCatalog":
              """
              Erzeugt einen Katalog aus der angegebenen TOML-Datei.
      
              Args:
                  path: Pfad zur TOML-Datei mit den UI-Ressourcen.
      
              Returns:
                  Initialisierter TextCatalog. Bei fehlender Datei ein leerer Katalog.
              """
              blocks: dict[str, TextBlock] = {}
              icons: dict[str, str] = {}
      
              if path.exists():
                  with path.open("rb") as f:
                      raw: dict[str, Any] = tomllib.load(f)
      
                      blocks = {
                          name: TextBlock(key=name, fields=fields)
                          for name, fields in raw.get("texts", {}).items()
                      }
      
                      icons = {name: str(value) for name, value in raw.get("icons", {}).items()}
      
              catalog: TextCatalog = cls(_blocks=blocks, _icons=icons)
              return catalog
      
          @classmethod
          def default(cls) -> "TextCatalog":
              """
              Lädt den Standard-Katalog aus `setup_ui.toml` neben diesem Modul.
              """
              path: Path = Path(__file__).with_name("setup_ui.toml")
              catalog: TextCatalog = cls.load(path)
              return catalog
      
          def _resolve_field(
                  self,
                  key: str,
                  field: str,
                  default: str,
          ) -> str:
              """
              Interner Helfer zur Feldauflösung mit Fallback.
      
              Args:
                  key: Name des Textblocks.
                  field: Feldname innerhalb des Blocks.
                  default: Fallback-Text.
      
              Returns:
                  Aufgelöster Feldwert oder Default.
              """
              block: Optional[TextBlock] = self._blocks.get(key)
              value: str = block.get(field, default) if not block is None else default
              return value
      
          def text(self, key: str, field: str = "body", default: str = "") -> str:
              """
              Liefert ein Textfeld aus dem angegebenen Block oder einen Default.
              """
              result: str = self._resolve_field(key, field, default)
              return result
      
          def format(self, key: str, field: str = "body", **kwargs: Any) -> str:
              """
              Liefert einen formatierten Text aus dem angegebenen Block.
      
              Nicht vorhandene Blöcke oder Felder liefern einen leeren String.
              """
              template: str = self._resolve_field(key, field, "")
              result: str = "" if not template else template.format(**kwargs)
              return result
      
          def icon(self, key: str, default: str) -> str:
              """
              Liefert ein Icon (Emoji oder Zeichenfolge) für den angegebenen Schlüssel.
      
              Falls kein Icon definiert ist, wird der Default-Wert verwendet.
              """
              icon_value: Optional[str] = self._icons.get(key)
              result: str = default if icon_value is None else icon_value
              return result
      
          @classmethod
          def load_catalog(cls, path: Path | None = None) -> TextCatalog:
              """
              Liefert entweder den Standardkatalog oder eine benutzerdefinierte Variante.
      
              Semantik:
              - path is None          → interner Standardkatalog (setup_ui.toml neben diesem Modul)
              - path ist ein Ordner   → es wird path / "setup_ui.toml" verwendet
              - path ist eine Datei   → genau diese Datei wird geladen
              """
              if path is None:
                  return cls.default()
      
              candidate = path
      
              # Wenn ein Verzeichnis übergeben wurde, dort nach setup_ui.toml suchen
              if candidate.is_dir():
                  candidate = candidate / "setup_ui.toml"
      
              # cls.load(...) ist bereits robust: bei fehlender Datei → leerer Katalog
              return cls.load(candidate)
      
      
      CATALOG: Final[TextCatalog] = TextCatalog.load_catalog()
  - rel_path: setup/ui/resources/icons.py
    hash: cb34792dfb6b7cd0fdd2e367d56bfe5432b74b6becbabfe4544314777a157790
    content: |
      # tools/setup/ui/resources/icons.py
      from __future__ import annotations
      
      """
      Enum-basierte Icon- und Statusdefinitionen für das Setup-UI.
      
      Dieses Modul kapselt:
      - MessageLevel: logische Stufen für Konsolenmeldungen (info, success, ...)
      - ProgressStatus: Zustände von Fortschrittsblöcken inkl. Icon-/Label-Metadaten.
      """
      
      from enum import Enum
      from functools import cached_property
      from typing import Final
      
      from tools.setup.ui.resources.catalog import CATALOG
      
      
      class MessageLevel(Enum):
          """Logische Stufen für strukturierte Konsolenausgaben."""
      
          INFO = ("info", "ℹ️", None)
          SUCCESS = ("success", "✅", "bold green")
          WARNING = ("warning", "⚠️", "yellow")
          ERROR = ("error", "❌", "bold red")
          CONTINUE = ("continue", "🚀", None)
          PLAIN = ("plain", "", None)
      
          def __init__(self, icon_key: str, fallback_icon: str, style: str | None) -> None:
              self._icon_key: Final[str] = icon_key
              self._fallback_icon: Final[str] = fallback_icon
              self.style: str | None = style
      
          @cached_property
          def icon(self) -> str:
              """Liefert das Icon aus dem Katalog oder den Fallback."""
              return CATALOG.icon(self._icon_key, self._fallback_icon)
      
      
      class ProgressStatus(Enum):
          """
          Interner Status eines Fortschrittsblocks inkl. Icon- und Label-Metadaten.
          """
      
          # Keys passend zu [icons] in setup_ui.toml: start, run, ok, fail
          STARTING = ("start", "🔄", "started")
          RUNNING = ("run", "⏳", "running")
          FINISHED = ("ok", "✅", "finished")
          FAILED = ("fail", "❌", "failed")
      
          def __init__(self, icon_key: str, fallback_icon: str, label: str) -> None:
              self._icon_key: Final[str] = icon_key
              self._fallback_icon: Final[str] = fallback_icon
              self.label: str = label
      
          @cached_property
          def icon(self) -> str:
              """Liefert das Icon aus dem Katalog oder den Fallback."""
              return CATALOG.icon(self._icon_key, self._fallback_icon)
  - rel_path: setup/ui/resources/setup_ui.toml
    hash: 1949b18caf234dd89c0cbd1ecbd2b8ca66cd592594b52fd313be686d64a48ad4
    content: |-
      [texts.setup_header]
      license = """
      UFO-Simulation Schulung – Lizenzhinweise (Kurzfassung)
      
      Dieses Schulungsprojekt basiert auf der im Repository angegebenen Lizenz.
      Die Nutzung erfolgt im Rahmen von Ausbildung, Studium und interner Schulung.
      """
      title = "──────────────────────────── UFO-Simulation – Setup ────────────────────────────"
      intro = "Willkommen zum automatisierten Setup der UFO-Simulation."
      body = """
      Dieses Programm richtet eine isolierte Python-Umgebung ein,
      installiert alle benötigten Abhängigkeiten und prüft die Installation.
      
      In diesem Setup werden nacheinander ausgeführt:
      
      1. Prüfung der Python-Version
      2. Erzeugen bzw. Wiederverwenden der virtuellen Umgebung (.venv)
      3. Installation der Runtime-Dependencies
      4. Installation der Dev-Dependencies
      5. Import-Contract-Prüfung via import-linter
      6. Ausführen der pytest-Tests zur Validierung der Installation
      
      Dies kann einen Moment dauern – bitte warte, bis alle Schritte abgeschlossen sind.
      """
      [texts.module_setup]
      default = "Setup-{typ} {module}: {info}"
      
      [texts.tests]
      skipped_hint = "pytest wurde aufgrund der Skip-Konfiguration nicht ausgeführt."
      
      [texts.args]
      default = "{type} wurde aufgrund des arguments {arg} {action}"
      
      [texts.next]
      title = "Nächste Schritte (Überblick)"
      body = """
      1. Virtuelle Umgebung aktivieren:
         {activate_cmd}
      
      2. Projekt starten ...
      """
      
      [texts.legend]
      body = """
      Legende der Symbole:
      
      {info}    – Information / Hinweis
      {success} – Schritt erfolgreich abgeschlossen
      {warning} – Warnung (Setup kann weiterlaufen, Ergebnis prüfen)
      {error}   – Fehler (Setup wird abgebrochen)
      {continue} – Hinweise zu Start und nächsten Schritten
      """
      
      [icons]
      info = "ℹ️"
      success = "✅"
      warning = "⚠️"
      error = "❌"
      continue = "🚀"
      start = "🔄"
      run = "⏳"
      ok = "✅"
      fail = "❌"
      
      [texts.step_default]
      success = "{step}: erfolgreich abgeschlossen."
      failure = "{step}: Fehler unter {env}: {cause}\n{details}"
      default = "{step}: {details}"
      
      # Neu: generische Progress-Zeile für laufende Arbeiten
      progress_running = "Running   /   {details}"
      progress_failed = "Failed     /   {details}"
      progress_finished = "Finished /   {details}"
      
      # Neu: Standard-Details für Installationsfortschritt (kann von anderen Steps wiederverwendet werden)
      install_details = "Installiere: {package} ({index}/{total})"
      install_done = "Alle Abhängigkeiten installiert."
      install_failed = "{package}: {details}"
      
      [texts.RunTestsStep]
      failure = "Tests im Schritt {step} unter {env} fehlgeschlagen: {cause}\n{details}"
  - rel_path: setup/utils/__init__.py
    hash: 1dcf3d2776eaa5b72ba75f5477ba0572273de657aa0cdcb644732c8a18185c4b
    content: |
      from __future__ import annotations
      
      """
      Gemeinsame Hilfsfunktionen für das Setup-System der UFO-Simulation.
      
      Dieses Modul bündelt die häufig verwendeten Utility-Funktionen:
      
      Es dient als schmale Fassade auf die eigentlichen Implementierungen
      in ``context`` und ``pause``.
      """
      
      from .context import run_command, short_output
      from .module import evaluate, classify, install
      from .version import ensure_venv, venv_create
      from .runner import run_single
      
      __all__: list[str] = [
          "run_command",
          "short_output",
          "evaluate",
          "classify",
          "install",
          "ensure_venv",
          "venv_create",
          "run_single"
      ]
  - rel_path: setup/utils/context.py
    hash: e14dad4aff92f1a781aa1deac84d067db3f10c43faf2af61dd215c60f40fed50
    content: |
      from __future__ import annotations
      
      import traceback
      
      """
      Technische Hilfsfunktionen für den Setup-Prozess.
      
      Dieses Modul bündelt generische Helfer wie Subprozess-Aufrufe und das
      Kürzen langer Konsolen-Ausgaben.
      """
      
      from dataclasses import dataclass
      from collections.abc import Sequence
      from typing import Final
      
      import subprocess
      
      
      @dataclass(slots=True, frozen=True)
      class CommandResult:
          """Ergebnis eines Subprozess-Aufrufs."""
      
          args: tuple[str, ...]
          returncode: int
          stdout: str
          stderr: str
      
          @property
          def ok(self) -> bool:
              """True, wenn der Prozess mit Exit-Code 0 beendet wurde."""
              return self.returncode == 0
      
      
      DEFAULT_MAX_LINES: Final[int] = 10
      
      
      def run_command(
              args: Sequence[str],
              *,
              cwd: str | None = None,
              timeout: float | None = None,
      ) -> CommandResult:
          """
          Führt einen Subprozess mit den gegebenen Argumenten aus.
      
          Args:
              args: Befehlsargumente, z. B. ("python", "-m", "pytest").
              cwd: Optionales Working-Directory.
              timeout: Optionaler Timeout in Sekunden.
      
          Returns:
              Ein CommandResult mit Exit-Code sowie stdout/stderr (immer als String).
          """
          completed = subprocess.run(
              tuple(args),
              cwd=cwd,
              timeout=timeout,
              check=False,
              text=True,
              capture_output=True,
          )
      
          return CommandResult(
              args=tuple(args),
              returncode=completed.returncode,
              stdout=completed.stdout or "",
              stderr=completed.stderr or "",
          )
      
      
      def short_output(output: str, *, max_lines: int = 40) -> str:
          """
          Begrenzt eine Ausgabe auf die ersten `max_lines` Zeilen.
      
          Leere oder whitespace-only Eingaben liefern einen leeren String.
      
          Args:
              output: Originale Ausgabe (z. B. pytest-Log).
              max_lines: Maximale Anzahl der zurückgegebenen Zeilen.
      
          Returns:
              Gekürzte Ausgabe oder ein leerer String bei leerem Input.
          """
          stripped: str = output.strip()
          result: str = ""
      
          if stripped:
              lines: list[str] = stripped.splitlines()
              line_count: int = len(lines)
      
              if line_count <= max_lines:
                  result = stripped
              else:
                  head: str = "\n".join(lines[:max_lines])
                  remaining: int = line_count - max_lines
                  result = f"{head}\n... ({remaining} weitere Zeilen ausgeblendet)"
      
          return result
  - rel_path: setup/utils/module.py
    hash: 3473ba12636fd577eb9d782297d23bfc15ac652b27605f4390686ef2d1ae7777
    content: |
      # tools/setup/utils/module.py
      from __future__ import annotations
      
      """
      Generische Hilfsfunktionen für Modul-/CLI-Prüfungen im Setup.
      
      Enthält:
      - evaluate  → `python -m <module> [args]` testweise ausführen
      - classify  → Fehlerursache grob klassifizieren
      - install   → generische Paketinstallation via `pip` oder externen Befehl
      """
      
      import subprocess
      from pathlib import Path
      from typing import Final, Iterable, overload
      
      from tools.setup.utils.context import run_command, short_output
      
      _PIP_ARGS: Final[tuple[str, ...]] = ("-m", "pip", "install", "--progress-bar", "off")
      
      
      def evaluate(
              python: str,
              module: str,
              *,
              cwd: Path | None = None,
              extra_args: tuple[str, ...] = ("--help",),
      ) -> tuple[bool, str, str | None]:
          """
          Führt einen minimalen Testlauf für `python -m <module> [extra_args]` aus.
      
          Rückgabe:
              ok       – True, wenn returncode == 0
              output   – kombinierte stdout/stderr-Ausgabe
              exc_info – Fehlermeldung, falls der Interpreter selbst nicht gestartet werden konnte
          """
      
          hold: tuple[bool, str, str | None]
      
          try:
              result = subprocess.run(
                  (python, "-m", module, *extra_args),
                  cwd=cwd,
                  capture_output=True,
                  text=True,
                  check=False,
              )
              comb = (result.stdout or "") + (result.stderr or "")
              hold = (result.returncode == 0, comb, None)
      
          except (OSError, FileNotFoundError) as exc:
              # Interpreter (z. B. .venv/bin/python) nicht auffindbar
              hold = (False, "", str(exc))
      
          return hold
      
      
      def classify(
              exc_info: str | None,
              output: str,
              *,
              module: str,
      ) -> tuple[str, str]:
          """
          Klassifiziert Fehler für einen Modulaufruf in (kind, details).
      
          kind    → "interpreter", "module_missing", "module_error"
          details → Text für Log & Ausgabe
          """
          text = (output or "").lower()
      
          match exc_info, text:
              case str() as e, _:
                  return "interpreter", e
              case None, s if "no module named" in s and module in s:
                  return "module_missing", output
              case _:
                  return "module_error", output
      
      
      @overload
      def install(
              *,
              python: str,
              spec: str,
              cwd: Path | None = None,
      ) -> tuple[int, str, str]:
          """
          Installation via `python -m pip install <spec>`.
          """
          ...
      
      
      @overload
      def install(
              *,
              cmd: Iterable[str],
              cwd: Path | None = None,
      ) -> tuple[int, str, str]:
          """
          Generischer Installationsbefehl (z. B. Installer-Skript).
          """
          ...
      
      
      def install(
              *,
              python: str | None = None,
              spec: str | None = None,
              cmd: Iterable[str] | None = None,
              cwd: Path | None = None,
      ) -> tuple[int, str, str]:
          """
          Installiert ein Paket oder führt einen generischen Installationsbefehl aus.
      
          Varianten:
              - python+spec → `python -m pip install <spec>`
              - cmd        → externer Befehl (z. B. Installer-Skript)
      
          Rückgabe:
              returncode
              raw_output   – stdout+stderr (vollständig)
              short_output – ggf. gekürzte Version für Konsolen-Anzeige
          """
      
          argv: tuple[str, ...] | None = None
      
          match python, spec, cmd:
              case str() as py, str() as s, None:
                  argv: tuple[str, ...] = (py, *_PIP_ARGS, s)
              case None, None, external if external is not None:
                  argv = tuple(external)
              case _:
                  raise ValueError(
                      "install(): entweder python+spec oder cmd angeben, nicht mehrere oder keine."
                  )
      
          result = run_command(argv, cwd=cwd)
      
          raw = (result.stdout or "") + (result.stderr or "")
          short = short_output(raw)
          return result.returncode, raw, short
  - rel_path: setup/utils/runner.py
    hash: e5e6854c7b112b14839365ecc6cf573fdaec2dbf61c5f7fe4a094964064f16c0
    content: |-
      from __future__ import annotations
      
      import logging
      from logging import Logger
      from pathlib import Path
      
      from tools.setup.utils import module
      
      
      def run_single(
          python: str,
          cwd: Path,
          nodeid: str | None = None,
          logger: Logger | None = None,
      ) -> tuple[bool, str, str]:
          """
          Führt einen einzelnen pytest-Lauf aus.
      
          Rückgabe:
              (ok, cause, details)
          """
          extra_args: tuple[str, ...] = (nodeid,) if nodeid is not None else tuple()
      
          argv = (python, "-m", "pytest", *extra_args)
      
          # Debug-Ausgabe über Standard-Logging (optional)
          if logger is not None:
              logger.debug("pytest argv: %r", argv)
      
          ok, output, exc_info = module.evaluate(
              python=python,
              module="pytest",
              cwd=cwd,  # Path, passt zu 'Path | None'
              extra_args=extra_args,
          )
          raw = output or ""
          if ok:
              return True, "", raw
      
          return (
              (False, "tests_running_error", exc_info)
              if isinstance(exc_info, str)
              else (False, "tests_failed", raw or "keine Ausgabe")
          )
  - rel_path: setup/utils/version.py
    hash: fae00f893670fe756f5554bdcd57c5f21a3818209f5b19f05eb5ffc8f6ae73e9
    content: |
      import sys
      from pathlib import Path
      from venv import create as venv_create
      
      from tools.setup.steps.base import BaseStepContext
      
      
      def check_python_version(ctx: BaseStepContext) -> tuple[bool, str, str]:
          required = ctx.profile.requires_min_python
          assert required is not None  # Profil muss eine Version liefern
      
          req_major, req_minor = required
          cur_major, cur_minor = sys.version_info[:2]
      
          if (cur_major, cur_minor) < (req_major, req_minor):
              return (
                  False,
                  "python_version_mismatch",
                  f"current={cur_major}.{cur_minor}, required>={req_major}.{req_minor}",
              )
      
          return True, "", ""
      
      
      def ensure_venv(ctx: BaseStepContext, safety_check: bool = True) -> tuple[bool, str, str]:
          venv_dir: Path = ctx.config.venv_dir
          repo_root: Path = ctx.config.repo_root
      
          # Sicherheitsgurt: venv darf nur im aktuellen Projekt liegen
          try:
              venv_dir.relative_to(repo_root)
          except ValueError:
              return (
                  False,
                  "venv_outside_repo",
                  f"venv_dir={venv_dir} liegt nicht unter repo_root={repo_root}",
              )
      
          # Optional: Name prüfen, um versehentliche Fremdpfade zu vermeiden
          if all((safety_check, venv_dir.name != ".venv")):
              return (
                  False,
                  "venv_unexpected_name",
                  f"erwartet .venv, gefunden {venv_dir.name}",
              )
      
          try:
              # Bewusster Reset: vorhandene venv wird überschrieben
              venv_create(venv_dir, with_pip=True, clear=True)
          except OSError as exc:
              return (
                  False,
                  "venv_create_failed",
                  str(exc),
              )
      
          return True, "", ""
